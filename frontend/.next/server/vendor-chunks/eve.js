/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eve";
exports.ids = ["vendor-chunks/eve"];
exports.modules = {

/***/ "(ssr)/./node_modules/eve/eve.js":
/*!*********************************!*\
  !*** ./node_modules/eve/eve.js ***!
  \*********************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n(function(glob) {\n    var version = \"0.5.4\", has = \"hasOwnProperty\", separator = /[\\.\\/]/, comaseparator = /\\s*,\\s*/, wildcard = \"*\", numsort = function(a, b) {\n        return a - b;\n    }, current_event, stop, events = {\n        n: {}\n    }, firstDefined = function() {\n        for(var i = 0, ii = this.length; i < ii; i++){\n            if (typeof this[i] != \"undefined\") {\n                return this[i];\n            }\n        }\n    }, lastDefined = function() {\n        var i = this.length;\n        while(--i){\n            if (typeof this[i] != \"undefined\") {\n                return this[i];\n            }\n        }\n    }, objtos = Object.prototype.toString, Str = String, isArray = Array.isArray || function(ar) {\n        return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n    }, /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/ eve = function(name, scope) {\n        var oldstop = stop, args = Array.prototype.slice.call(arguments, 2), listeners = eve.listeners(name), z = 0, l, indexed = [], queue = {}, out = [], ce = current_event;\n        out.firstDefined = firstDefined;\n        out.lastDefined = lastDefined;\n        current_event = name;\n        stop = 0;\n        for(var i = 0, ii = listeners.length; i < ii; i++)if (\"zIndex\" in listeners[i]) {\n            indexed.push(listeners[i].zIndex);\n            if (listeners[i].zIndex < 0) {\n                queue[listeners[i].zIndex] = listeners[i];\n            }\n        }\n        indexed.sort(numsort);\n        while(indexed[z] < 0){\n            l = queue[indexed[z++]];\n            out.push(l.apply(scope, args));\n            if (stop) {\n                stop = oldstop;\n                return out;\n            }\n        }\n        for(i = 0; i < ii; i++){\n            l = listeners[i];\n            if (\"zIndex\" in l) {\n                if (l.zIndex == indexed[z]) {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                    do {\n                        z++;\n                        l = queue[indexed[z]];\n                        l && out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                    }while (l);\n                } else {\n                    queue[l.zIndex] = l;\n                }\n            } else {\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    break;\n                }\n            }\n        }\n        stop = oldstop;\n        current_event = ce;\n        return out;\n    };\n    // Undocumented. Debug only.\n    eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/ eve.listeners = function(name) {\n        var names = isArray(name) ? name : name.split(separator), e = events, item, items, k, i, ii, j, jj, nes, es = [\n            e\n        ], out = [];\n        for(i = 0, ii = names.length; i < ii; i++){\n            nes = [];\n            for(j = 0, jj = es.length; j < jj; j++){\n                e = es[j].n;\n                items = [\n                    e[names[i]],\n                    e[wildcard]\n                ];\n                k = 2;\n                while(k--){\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    /*\\\n     * eve.separator\n     [ method ]\n\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n     * here. Be aware that if you pass a string longer than one character it will be treated as\n     * a list of characters.\n\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n    \\*/ eve.separator = function(sep) {\n        if (sep) {\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n            sep = \"[\" + sep + \"]\";\n            separator = new RegExp(sep);\n        } else {\n            separator = /[\\.\\/]/;\n        }\n    };\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     - name (array) if you don’t want to use separators, you can use array of strings\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/ eve.on = function(name, f) {\n        if (typeof f != \"function\") {\n            return function() {};\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [\n            name\n        ] : Str(name).split(comaseparator);\n        for(var i = 0, ii = names.length; i < ii; i++){\n            (function(name) {\n                var names = isArray(name) ? name : Str(name).split(separator), e = events, exist;\n                for(var i = 0, ii = names.length; i < ii; i++){\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {\n                        n: {}\n                    });\n                }\n                e.f = e.f || [];\n                for(i = 0, ii = e.f.length; i < ii; i++)if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            })(names[i]);\n        }\n        return function(zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/ eve.f = function(event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function() {\n            eve.apply(null, [\n                event,\n                null\n            ].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/ eve.stop = function() {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/ eve.nt = function(subname) {\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n        }\n        return cur;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/ eve.nts = function() {\n        return isArray(current_event) ? current_event : current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/ /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/ eve.off = eve.unbind = function(name, f) {\n        if (!name) {\n            eve._events = events = {\n                n: {}\n            };\n            return;\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [\n            name\n        ] : Str(name).split(comaseparator);\n        if (names.length > 1) {\n            for(var i = 0, ii = names.length; i < ii; i++){\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = isArray(name) ? name : Str(name).split(separator);\n        var e, key, splice, i, ii, j, jj, cur = [\n            events\n        ], inodes = [];\n        for(i = 0, ii = names.length; i < ii; i++){\n            for(j = 0; j < cur.length; j += splice.length - 2){\n                splice = [\n                    j,\n                    1\n                ];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                        inodes.unshift({\n                            n: e,\n                            name: names[i]\n                        });\n                    }\n                } else {\n                    for(key in e)if (e[has](key)) {\n                        splice.push(e[key]);\n                        inodes.unshift({\n                            n: e,\n                            name: key\n                        });\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for(i = 0, ii = cur.length; i < ii; i++){\n            e = cur[i];\n            while(e.n){\n                if (f) {\n                    if (e.f) {\n                        for(j = 0, jj = e.f.length; j < jj; j++)if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for(key in e.n)if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for(j = 0, jj = funcs.length; j < jj; j++)if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for(key in e.n)if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n        // prune inner nodes in path\n        prune: for(i = 0, ii = inodes.length; i < ii; i++){\n            e = inodes[i];\n            for(key in e.n[e.name].f){\n                continue prune;\n            }\n            for(key in e.n[e.name].n){\n                continue prune;\n            }\n            // is empty\n            delete e.n[e.name];\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/ eve.once = function(name, f) {\n        var f2 = function() {\n            eve.off(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/ eve.version = version;\n    eve.toString = function() {\n        return \"You are running Eve \" + version;\n    };\n    glob.eve = eve;\n     true && module.exports ? module.exports = eve :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return eve;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n})( false ? 0 : this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGtHQUFDLEdBQUc1QixDQUFjNEI7QUFDeEwsR0FBRyxNQUE0QixHQUFHMkQsQ0FBTUEsR0FBRyxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2Vic2l0ZXYzLy4vbm9kZV9tb2R1bGVzL2V2ZS9ldmUuanM/ODliYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgXFxcXFxuLy8g4pSCIEV2ZSAwLjUuNCAtIEphdmFTY3JpcHQgRXZlbnRzIExpYnJhcnkgICAgICAgICAgICAgICAgICAgICAg4pSCIFxcXFxcbi8vIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpCBcXFxcXG4vLyDilIIgQXV0aG9yIERtaXRyeSBCYXJhbm92c2tpeSAoaHR0cDovL2RtaXRyeS5iYXJhbm92c2tpeS5jb20vKSDilIIgXFxcXFxuLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcXFxcblxuKGZ1bmN0aW9uIChnbG9iKSB7XG4gICAgdmFyIHZlcnNpb24gPSBcIjAuNS40XCIsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgc2VwYXJhdG9yID0gL1tcXC5cXC9dLyxcbiAgICAgICAgY29tYXNlcGFyYXRvciA9IC9cXHMqLFxccyovLFxuICAgICAgICB3aWxkY2FyZCA9IFwiKlwiLFxuICAgICAgICBudW1zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudF9ldmVudCxcbiAgICAgICAgc3RvcCxcbiAgICAgICAgZXZlbnRzID0ge246IHt9fSxcbiAgICAgICAgZmlyc3REZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYXN0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvYmp0b3MgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcikge1xuICAgICAgICAgICAgcmV0dXJuIGFyIGluc3RhbmNlb2YgQXJyYXkgfHwgb2JqdG9zLmNhbGwoYXIpID09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfSxcbiAgICAvKlxcXG4gICAgICogZXZlXG4gICAgIFsgbWV0aG9kIF1cblxuICAgICAqIEZpcmVzIGV2ZW50IHdpdGggZ2l2ZW4gYG5hbWVgLCBnaXZlbiBzY29wZSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cblxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgKmV2ZW50KiwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZFxuICAgICAtIHNjb3BlIChvYmplY3QpIGNvbnRleHQgZm9yIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAtIHZhcmFyZ3MgKC4uLikgdGhlIHJlc3Qgb2YgYXJndW1lbnRzIHdpbGwgYmUgc2VudCB0byBldmVudCBoYW5kbGVyc1xuXG4gICAgID0gKG9iamVjdCkgYXJyYXkgb2YgcmV0dXJuZWQgdmFsdWVzIGZyb20gdGhlIGxpc3RlbmVycy4gQXJyYXkgaGFzIHR3byBtZXRob2RzIGAuZmlyc3REZWZpbmVkKClgIGFuZCBgLmxhc3REZWZpbmVkKClgIHRvIGdldCBmaXJzdCBvciBsYXN0IG5vdCBgdW5kZWZpbmVkYCB2YWx1ZS5cbiAgICBcXCovXG4gICAgICAgIGV2ZSA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIG9sZHN0b3AgPSBzdG9wLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGV2ZS5saXN0ZW5lcnMobmFtZSksXG4gICAgICAgICAgICAgICAgeiA9IDAsXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBpbmRleGVkID0gW10sXG4gICAgICAgICAgICAgICAgcXVldWUgPSB7fSxcbiAgICAgICAgICAgICAgICBvdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBjZSA9IGN1cnJlbnRfZXZlbnQ7XG4gICAgICAgICAgICBvdXQuZmlyc3REZWZpbmVkID0gZmlyc3REZWZpbmVkO1xuICAgICAgICAgICAgb3V0Lmxhc3REZWZpbmVkID0gbGFzdERlZmluZWQ7XG4gICAgICAgICAgICBjdXJyZW50X2V2ZW50ID0gbmFtZTtcbiAgICAgICAgICAgIHN0b3AgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChcInpJbmRleFwiIGluIGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChsaXN0ZW5lcnNbaV0uekluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLnpJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbbGlzdGVuZXJzW2ldLnpJbmRleF0gPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXhlZC5zb3J0KG51bXNvcnQpO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4ZWRbel0gPCAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IHF1ZXVlW2luZGV4ZWRbeisrXV07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBvbGRzdG9wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbCA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ6SW5kZXhcIiBpbiBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsLnpJbmRleCA9PSBpbmRleGVkW3pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHorKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gcXVldWVbaW5kZXhlZFt6XV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2wuekluZGV4XSA9IGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3AgPSBvbGRzdG9wO1xuICAgICAgICAgICAgY3VycmVudF9ldmVudCA9IGNlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAvLyBVbmRvY3VtZW50ZWQuIERlYnVnIG9ubHkuXG4gICAgZXZlLl9ldmVudHMgPSBldmVudHM7XG4gICAgLypcXFxuICAgICAqIGV2ZS5saXN0ZW5lcnNcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHdoaWNoIGdpdmVzIHlvdSBhcnJheSBvZiBhbGwgZXZlbnQgaGFuZGxlcnMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBieSB0aGUgZ2l2ZW4gYG5hbWVgLlxuXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZFxuXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBldmVudCBoYW5kbGVyc1xuICAgIFxcKi9cbiAgICBldmUubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IG5hbWUgOiBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlID0gZXZlbnRzLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBqaixcbiAgICAgICAgICAgIG5lcyxcbiAgICAgICAgICAgIGVzID0gW2VdLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlID0gZXNbal0ubjtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtlW25hbWVzW2ldXSwgZVt3aWxkY2FyZF1dO1xuICAgICAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGl0ZW0uZiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcyA9IG5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5zZXBhcmF0b3JcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSWYgZm9yIHNvbWUgcmVhc29ucyB5b3UgZG9u4oCZdCBsaWtlIGRlZmF1bHQgc2VwYXJhdG9ycyAoYC5gIG9yIGAvYCkgeW91IGNhbiBzcGVjaWZ5IHlvdXJzXG4gICAgICogaGVyZS4gQmUgYXdhcmUgdGhhdCBpZiB5b3UgcGFzcyBhIHN0cmluZyBsb25nZXIgdGhhbiBvbmUgY2hhcmFjdGVyIGl0IHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgICAqIGEgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuXG4gICAgIC0gc2VwYXJhdG9yIChzdHJpbmcpIG5ldyBzZXBhcmF0b3IuIEVtcHR5IHN0cmluZyByZXNldHMgdG8gZGVmYXVsdDogYC5gIG9yIGAvYC5cbiAgICBcXCovXG4gICAgZXZlLnNlcGFyYXRvciA9IGZ1bmN0aW9uIChzZXApIHtcbiAgICAgICAgaWYgKHNlcCkge1xuICAgICAgICAgICAgc2VwID0gU3RyKHNlcCkucmVwbGFjZSgvKD89W1xcLlxcXlxcXVxcW1xcLV0pL2csIFwiXFxcXFwiKTtcbiAgICAgICAgICAgIHNlcCA9IFwiW1wiICsgc2VwICsgXCJdXCI7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSAvW1xcLlxcL10vO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lLiBZb3UgY2FuIHVzZSB3aWxkY2FyZHMg4oCcYCpg4oCdIGZvciB0aGUgbmFtZXM6XG4gICAgIHwgZXZlLm9uKFwiKi51bmRlci4qXCIsIGYpO1xuICAgICB8IGV2ZShcIm1vdXNlLnVuZGVyLmZsb29yXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIG5hbWUgKGFycmF5KSBpZiB5b3UgZG9u4oCZdCB3YW50IHRvIHVzZSBzZXBhcmF0b3JzLCB5b3UgY2FuIHVzZSBhcnJheSBvZiBzdHJpbmdzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHJldHVybmVkIGZ1bmN0aW9uIGFjY2VwdHMgYSBzaW5nbGUgbnVtZXJpYyBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIHotaW5kZXggb2YgdGhlIGhhbmRsZXIuIEl0IGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIG9ubHkgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNvbWUgc3Vic2V0IG9mIGhhbmRsZXJzIHdpbGwgYmUgaW52b2tlZCBpbiBhIGdpdmVuIG9yZGVyLCBkZXNwaXRlIG9mIHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LlxuICAgICA+IEV4YW1wbGU6XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgZWF0SXQpKDIpO1xuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIHNjcmVhbSk7XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgY2F0Y2hJdCkoMSk7XG4gICAgICogVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGBjYXRjaEl0YCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYGVhdEl0YC5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHB1dCB5b3VyIGhhbmRsZXIgYmVmb3JlIG5vbi1pbmRleGVkIGhhbmRsZXJzLCBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUuXG4gICAgICogTm90ZTogSSBhc3N1bWUgbW9zdCBvZiB0aGUgdGltZSB5b3UgZG9u4oCZdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHotaW5kZXgsIGJ1dCBpdOKAmXMgbmljZSB0byBoYXZlIHRoaXMgZmVhdHVyZSDigJxqdXN0IGluIGNhc2XigJ0uXG4gICAgXFwqL1xuICAgIGV2ZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZiAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gaXNBcnJheShuYW1lWzBdKSA/IG5hbWUgOiBbbmFtZV0gOiBTdHIobmFtZSkuc3BsaXQoY29tYXNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IGlzQXJyYXkobmFtZSkgPyBuYW1lIDogU3RyKG5hbWUpLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIGUgPSBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUuaGFzT3duUHJvcGVydHkobmFtZXNbaV0pICYmIGVbbmFtZXNbaV1dIHx8IChlW25hbWVzW2ldXSA9IHtuOiB7fX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmYgPSBlLmYgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlLmYubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGUuZltpXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICFleGlzdCAmJiBlLmYucHVzaChmKTtcbiAgICAgICAgICAgIH0obmFtZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHpJbmRleCkge1xuICAgICAgICAgICAgaWYgKCt6SW5kZXggPT0gK3pJbmRleCkge1xuICAgICAgICAgICAgICAgIGYuekluZGV4ID0gK3pJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuZlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgZmlyZSBnaXZlbiBldmVudCB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBBcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcmVzdWx0IGZ1bmN0aW9uIHdpbGwgYmUgYWxzb1xuICAgICAqIGNvbmNhdGVkIHRvIHRoZSBsaXN0IG9mIGZpbmFsIGFyZ3VtZW50cy5cbiAgICAgfCBlbC5vbmNsaWNrID0gZXZlLmYoXCJjbGlja1wiLCAxLCAyKTtcbiAgICAgfCBldmUub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICB8ICAgICBjb25zb2xlLmxvZyhhLCBiLCBjKTsgLy8gMSwgMiwgW2V2ZW50IG9iamVjdF1cbiAgICAgfCB9KTtcbiAgICAgLSBldmVudCAoc3RyaW5nKSBldmVudCBuYW1lXG4gICAgIC0gdmFyYXJncyAo4oCmKSBhbmQgYW55IG90aGVyIGFyZ3VtZW50c1xuICAgICA9IChmdW5jdGlvbikgcG9zc2libGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICBldmUuZiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUuYXBwbHkobnVsbCwgW2V2ZW50LCBudWxsXS5jb25jYXQoYXR0cnMpLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSXMgdXNlZCBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlciB0byBzdG9wIHRoZSBldmVudCwgcHJldmVudGluZyBhbnkgc3Vic2VxdWVudCBsaXN0ZW5lcnMgZnJvbSBmaXJpbmcuXG4gICAgXFwqL1xuICAgIGV2ZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wID0gMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgIC0gc3VibmFtZSAoc3RyaW5nKSAjb3B0aW9uYWwgc3VibmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgaWYgYHN1Ym5hbWVgIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBvclxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAsIGlmIGN1cnJlbnQgZXZlbnTigJlzIG5hbWUgY29udGFpbnMgYHN1Ym5hbWVgXG4gICAgXFwqL1xuICAgIGV2ZS5udCA9IGZ1bmN0aW9uIChzdWJuYW1lKSB7XG4gICAgICAgIHZhciBjdXIgPSBpc0FycmF5KGN1cnJlbnRfZXZlbnQpID8gY3VycmVudF9ldmVudC5qb2luKFwiLlwiKSA6IGN1cnJlbnRfZXZlbnQ7XG4gICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlxcXFwufFxcXFwvfF4pXCIgKyBzdWJuYW1lICsgXCIoPzpcXFxcLnxcXFxcL3wkKVwiKS50ZXN0KGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb3VsZCBiZSB1c2VkIGluc2lkZSBldmVudCBoYW5kbGVyIHRvIGZpZ3VyZSBvdXQgYWN0dWFsIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqKlxuICAgICAqKlxuICAgICA9IChhcnJheSkgbmFtZXMgb2YgdGhlIGV2ZW50XG4gICAgXFwqL1xuICAgIGV2ZS5udHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KGN1cnJlbnRfZXZlbnQpID8gY3VycmVudF9ldmVudCA6IGN1cnJlbnRfZXZlbnQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub2ZmXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGZ1bmN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnQgbGlzdGVuZXJzIGFzc2lnbmVkIHRvIGdpdmVuIG5hbWUuXG4gICAgICogSWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCBhbGwgdGhlIGV2ZW50cyB3aWxsIGJlIGNsZWFyZWQuXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogZXZlLnVuYmluZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBldmUub2ZmXG4gICAgXFwqL1xuICAgIGV2ZS5vZmYgPSBldmUudW5iaW5kID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBldmUuX2V2ZW50cyA9IGV2ZW50cyA9IHtuOiB7fX07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IGlzQXJyYXkobmFtZVswXSkgPyBuYW1lIDogW25hbWVdIDogU3RyKG5hbWUpLnNwbGl0KGNvbWFzZXBhcmF0b3IpO1xuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGV2ZS5vZmYobmFtZXNbaV0sIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IG5hbWUgOiBTdHIobmFtZSkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzcGxpY2UsXG4gICAgICAgICAgICBpLCBpaSwgaiwgamosXG4gICAgICAgICAgICBjdXIgPSBbZXZlbnRzXSxcbiAgICAgICAgICAgIGlub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXIubGVuZ3RoOyBqICs9IHNwbGljZS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlID0gW2osIDFdO1xuICAgICAgICAgICAgICAgIGUgPSBjdXJbal0ubjtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gIT0gd2lsZGNhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbmFtZXNbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucHVzaChlW25hbWVzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlKSBpZiAoZVtoYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5wdXNoKGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5zcGxpY2UuYXBwbHkoY3VyLCBzcGxpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gY3VyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSBjdXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoZS5uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBlLmYubGVuZ3RoOyBqIDwgamo7IGorKykgaWYgKGUuZltqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5mLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFlLmYubGVuZ3RoICYmIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZS5uKSBpZiAoZS5uW2hhc10oa2V5KSAmJiBlLm5ba2V5XS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3MgPSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBmdW5jcy5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZnVuY3Nbal0gPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jcy5sZW5ndGggJiYgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZS5mO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUgPSBlLm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJ1bmUgaW5uZXIgbm9kZXMgaW4gcGF0aFxuICAgICAgICBwcnVuZTogZm9yIChpID0gMCwgaWkgPSBpbm9kZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZSA9IGlub2Rlc1tpXTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGUubltlLm5hbWVdLmYpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgZW1wdHkgKGhhcyBsaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgY29udGludWUgcHJ1bmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBlLm5bZS5uYW1lXS5uKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVtcHR5IChoYXMgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY29udGludWUgcHJ1bmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpcyBlbXB0eVxuICAgICAgICAgICAgZGVsZXRlIGUubltlLm5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9uY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJpbmRzIGdpdmVuIGV2ZW50IGhhbmRsZXIgd2l0aCBhIGdpdmVuIG5hbWUgdG8gb25seSBydW4gb25jZSB0aGVuIHVuYmluZCBpdHNlbGYuXG4gICAgIHwgZXZlLm9uY2UoXCJsb2dpblwiLCBmKTtcbiAgICAgfCBldmUoXCJsb2dpblwiKTsgLy8gdHJpZ2dlcnMgZlxuICAgICB8IGV2ZShcImxvZ2luXCIpOyAvLyBubyBsaXN0ZW5lcnNcbiAgICAgKiBVc2UgQGV2ZSB0byB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICoqXG4gICAgID0gKGZ1bmN0aW9uKSBzYW1lIHJldHVybiBmdW5jdGlvbiBhcyBAZXZlLm9uXG4gICAgXFwqL1xuICAgIGV2ZS5vbmNlID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIGYyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlLm9mZihuYW1lLCBmMik7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXZlLm9uKG5hbWUsIGYyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUudmVyc2lvblxuICAgICBbIHByb3BlcnR5IChzdHJpbmcpIF1cbiAgICAgKipcbiAgICAgKiBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuXG4gICAgXFwqL1xuICAgIGV2ZS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBldmUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIllvdSBhcmUgcnVubmluZyBFdmUgXCIgKyB2ZXJzaW9uO1xuICAgIH07XG4gICAgZ2xvYi5ldmUgPSBldmU7XG4gICAgdHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBldmUgOiB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcImV2ZVwiLCBbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlOyB9KSA6IGdsb2IuZXZlID0gZXZlO1xufSkodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcyk7XG4iXSwibmFtZXMiOlsiZ2xvYiIsInZlcnNpb24iLCJoYXMiLCJzZXBhcmF0b3IiLCJjb21hc2VwYXJhdG9yIiwid2lsZGNhcmQiLCJudW1zb3J0IiwiYSIsImIiLCJjdXJyZW50X2V2ZW50Iiwic3RvcCIsImV2ZW50cyIsIm4iLCJmaXJzdERlZmluZWQiLCJpIiwiaWkiLCJsZW5ndGgiLCJsYXN0RGVmaW5lZCIsIm9ianRvcyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiU3RyIiwiU3RyaW5nIiwiaXNBcnJheSIsIkFycmF5IiwiYXIiLCJjYWxsIiwiZXZlIiwibmFtZSIsInNjb3BlIiwib2xkc3RvcCIsImFyZ3MiLCJzbGljZSIsImFyZ3VtZW50cyIsImxpc3RlbmVycyIsInoiLCJsIiwiaW5kZXhlZCIsInF1ZXVlIiwib3V0IiwiY2UiLCJwdXNoIiwiekluZGV4Iiwic29ydCIsImFwcGx5IiwiX2V2ZW50cyIsIm5hbWVzIiwic3BsaXQiLCJlIiwiaXRlbSIsIml0ZW1zIiwiayIsImoiLCJqaiIsIm5lcyIsImVzIiwiY29uY2F0IiwiZiIsInNlcCIsInJlcGxhY2UiLCJSZWdFeHAiLCJvbiIsImV4aXN0IiwiaGFzT3duUHJvcGVydHkiLCJldmVudCIsImF0dHJzIiwibnQiLCJzdWJuYW1lIiwiY3VyIiwiam9pbiIsInRlc3QiLCJudHMiLCJvZmYiLCJ1bmJpbmQiLCJrZXkiLCJzcGxpY2UiLCJpbm9kZXMiLCJ1bnNoaWZ0IiwiZnVuY3MiLCJwcnVuZSIsIm9uY2UiLCJmMiIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZpbmUiLCJhbWQiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eve/eve.js\n");

/***/ })

};
;