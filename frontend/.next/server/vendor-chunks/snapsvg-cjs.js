/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snapsvg-cjs";
exports.ids = ["vendor-chunks/snapsvg-cjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/snapsvg-cjs/dist/snap.svg-cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/snapsvg-cjs/dist/snap.svg-cjs.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("window.eve = __webpack_require__(/*! eve */ \"(ssr)/./node_modules/eve/eve.js\");\n// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar mina = function(eve1) {\n    var animations = {}, requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n        setTimeout(callback, 16, new Date().getTime());\n        return true;\n    }, requestID, isArray = Array.isArray || function(a) {\n        return a instanceof Array || Object.prototype.toString.call(a) == \"[object Array]\";\n    }, idgen = 0, idprefix = \"M\" + (+new Date).toString(36), ID = function() {\n        return idprefix + (idgen++).toString(36);\n    }, diff = function(a, b, A, B) {\n        if (isArray(a)) {\n            res = [];\n            for(var i = 0, ii = a.length; i < ii; i++){\n                res[i] = diff(a[i], b, A[i], B);\n            }\n            return res;\n        }\n        var dif = (A - a) / (B - b);\n        return function(bb) {\n            return a + dif * (bb - b);\n        };\n    }, timer = Date.now || function() {\n        return +new Date;\n    }, sta = function(val) {\n        var a = this;\n        if (val == null) {\n            return a.s;\n        }\n        var ds = a.s - val;\n        a.b += a.dur * ds;\n        a.B += a.dur * ds;\n        a.s = val;\n    }, speed = function(val) {\n        var a = this;\n        if (val == null) {\n            return a.spd;\n        }\n        a.spd = val;\n    }, duration = function(val) {\n        var a = this;\n        if (val == null) {\n            return a.dur;\n        }\n        a.s = a.s * val / a.dur;\n        a.dur = val;\n    }, stopit = function() {\n        var a = this;\n        delete animations[a.id];\n        a.update();\n        eve1(\"mina.stop.\" + a.id, a);\n    }, pause = function() {\n        var a = this;\n        if (a.pdif) {\n            return;\n        }\n        delete animations[a.id];\n        a.update();\n        a.pdif = a.get() - a.b;\n    }, resume = function() {\n        var a = this;\n        if (!a.pdif) {\n            return;\n        }\n        a.b = a.get() - a.pdif;\n        delete a.pdif;\n        animations[a.id] = a;\n        frame();\n    }, update = function() {\n        var a = this, res1;\n        if (isArray(a.start)) {\n            res1 = [];\n            for(var j = 0, jj = a.start.length; j < jj; j++){\n                res1[j] = +a.start[j] + (a.end[j] - a.start[j]) * a.easing(a.s);\n            }\n        } else {\n            res1 = +a.start + (a.end - a.start) * a.easing(a.s);\n        }\n        a.set(res1);\n    }, frame = function(timeStamp) {\n        // Manual invokation?\n        if (!timeStamp) {\n            // Frame loop stopped?\n            if (!requestID) {\n                // Start frame loop...\n                requestID = requestAnimFrame(frame);\n            }\n            return;\n        }\n        var len = 0;\n        for(var i in animations)if (animations.hasOwnProperty(i)) {\n            var a = animations[i], b = a.get(), res1;\n            len++;\n            a.s = (b - a.b) / (a.dur / a.spd);\n            if (a.s >= 1) {\n                delete animations[i];\n                a.s = 1;\n                len--;\n                (function(a) {\n                    setTimeout(function() {\n                        eve1(\"mina.finish.\" + a.id, a);\n                    });\n                })(a);\n            }\n            a.update();\n        }\n        requestID = len ? requestAnimFrame(frame) : false;\n    }, /*\\\n     * mina\n     [ method ]\n     **\n     * Generic animation of numbers\n     **\n     - a (number) start _slave_ number\n     - A (number) end _slave_ number\n     - b (number) start _master_ number (start time in general case)\n     - B (number) end _master_ number (end time in general case)\n     - get (function) getter of _master_ number (see @mina.time)\n     - set (function) setter of _slave_ number\n     - easing (function) #optional easing function, default is @mina.linear\n     = (object) animation descriptor\n     o {\n     o         id (string) animation id,\n     o         start (number) start _slave_ number,\n     o         end (number) end _slave_ number,\n     o         b (number) start _master_ number,\n     o         s (number) animation status (0..1),\n     o         dur (number) animation duration,\n     o         spd (number) animation speed,\n     o         get (function) getter of _master_ number (see @mina.time),\n     o         set (function) setter of _slave_ number,\n     o         easing (function) easing function, default is @mina.linear,\n     o         status (function) status getter/setter,\n     o         speed (function) speed getter/setter,\n     o         duration (function) duration getter/setter,\n     o         stop (function) animation stopper\n     o         pause (function) pauses the animation\n     o         resume (function) resumes the animation\n     o         update (function) calles setter with the right value of the animation\n     o }\n    \\*/ mina = function(a, A, b, B, get, set, easing) {\n        var anim = {\n            id: ID(),\n            start: a,\n            end: A,\n            b: b,\n            s: 0,\n            dur: B - b,\n            spd: 1,\n            get: get,\n            set: set,\n            easing: easing || mina.linear,\n            status: sta,\n            speed: speed,\n            duration: duration,\n            stop: stopit,\n            pause: pause,\n            resume: resume,\n            update: update\n        };\n        animations[anim.id] = anim;\n        var len = 0, i;\n        for(i in animations)if (animations.hasOwnProperty(i)) {\n            len++;\n            if (len == 2) {\n                break;\n            }\n        }\n        len == 1 && frame();\n        return anim;\n    };\n    /*\\\n     * mina.time\n     [ method ]\n     **\n     * Returns the current time. Equivalent to:\n     | function () {\n     |     return (new Date).getTime();\n     | }\n    \\*/ mina.time = timer;\n    /*\\\n     * mina.getById\n     [ method ]\n     **\n     * Returns an animation by its id\n     - id (string) animation's id\n     = (object) See @mina\n    \\*/ mina.getById = function(id) {\n        return animations[id] || null;\n    };\n    /*\\\n     * mina.linear\n     [ method ]\n     **\n     * Default linear easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.linear = function(n) {\n        return n;\n    };\n    /*\\\n     * mina.easeout\n     [ method ]\n     **\n     * Easeout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.easeout = function(n) {\n        return Math.pow(n, 1.7);\n    };\n    /*\\\n     * mina.easein\n     [ method ]\n     **\n     * Easein easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.easein = function(n) {\n        return Math.pow(n, .48);\n    };\n    /*\\\n     * mina.easeinout\n     [ method ]\n     **\n     * Easeinout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.easeinout = function(n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        var q = .48 - n / 1.04, Q = Math.sqrt(.1734 + q * q), x = Q - q, X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + .5;\n        return (1 - t) * 3 * t * t + t * t * t;\n    };\n    /*\\\n     * mina.backin\n     [ method ]\n     **\n     * Backin easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.backin = function(n) {\n        if (n == 1) {\n            return 1;\n        }\n        var s = 1.70158;\n        return n * n * ((s + 1) * n - s);\n    };\n    /*\\\n     * mina.backout\n     [ method ]\n     **\n     * Backout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.backout = function(n) {\n        if (n == 0) {\n            return 0;\n        }\n        n = n - 1;\n        var s = 1.70158;\n        return n * n * ((s + 1) * n + s) + 1;\n    };\n    /*\\\n     * mina.elastic\n     [ method ]\n     **\n     * Elastic easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.elastic = function(n) {\n        if (n == !!n) {\n            return n;\n        }\n        return Math.pow(2, -10 * n) * Math.sin((n - .075) * (2 * Math.PI) / .3) + 1;\n    };\n    /*\\\n     * mina.bounce\n     [ method ]\n     **\n     * Bounce easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/ mina.bounce = function(n) {\n        var s = 7.5625, p = 2.75, l;\n        if (n < 1 / p) {\n            l = s * n * n;\n        } else {\n            if (n < 2 / p) {\n                n -= 1.5 / p;\n                l = s * n * n + .75;\n            } else {\n                if (n < 2.5 / p) {\n                    n -= 2.25 / p;\n                    l = s * n * n + .9375;\n                } else {\n                    n -= 2.625 / p;\n                    l = s * n * n + .984375;\n                }\n            }\n        }\n        return l;\n    };\n    window.mina = mina;\n    return mina;\n}(typeof eve == \"undefined\" ? function() {} : eve);\n// Copyright (c) 2013 - 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar Snap = function(root) {\n    Snap.version = \"0.5.1\";\n    /*\\\n * Snap\n [ method ]\n **\n * Creates a drawing surface or wraps existing SVG element.\n **\n - width (number|string) width of surface\n - height (number|string) height of surface\n * or\n - DOM (SVGElement) element to be wrapped into Snap structure\n * or\n - array (array) array of elements (will return set of elements)\n * or\n - query (string) CSS query selector\n = (object) @Element\n\\*/ function Snap(w, h) {\n        if (w) {\n            if (w.nodeType) {\n                return wrap(w);\n            }\n            if (is(w, \"array\") && Snap.set) {\n                return Snap.set.apply(Snap, w);\n            }\n            if (w instanceof Element) {\n                return w;\n            }\n            if (h == null) {\n                try {\n                    w = glob.doc.querySelector(String(w));\n                    return wrap(w);\n                } catch (e) {\n                    return null;\n                }\n            }\n        }\n        w = w == null ? \"100%\" : w;\n        h = h == null ? \"100%\" : h;\n        return new Paper(w, h);\n    }\n    Snap.toString = function() {\n        return \"Snap v\" + this.version;\n    };\n    Snap._ = {};\n    var glob = {\n        win: root.window,\n        doc: root.window.document\n    };\n    Snap._.glob = glob;\n    var has = \"hasOwnProperty\", Str = String, toFloat = parseFloat, toInt = parseInt, math1 = Math, mmax = math1.max, mmin = math1.min, abs = math1.abs, pow = math1.pow, PI = math1.PI, round = math1.round, E = \"\", S = \" \", objectToString = Object.prototype.toString, ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i, colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i, bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/, separator = Snap._.separator = /[,\\s]+/, whitespace = /[\\s]/g, commaSpaces = /[\\s]*,[\\s]*/, hsrg = {\n        hs: 1,\n        rg: 1\n    }, pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig, tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig, pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/ig, idgen = 0, idprefix = \"S\" + (+new Date).toString(36), ID = function(el) {\n        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n    }, xlink = \"http://www.w3.org/1999/xlink\", xmlns = \"http://www.w3.org/2000/svg\", hub = {}, /*\\\n     * Snap.url\n     [ method ]\n     **\n     * Wraps path into `\"url('<path>')\"`.\n     - value (string) path\n     = (string) wrapped path\n    \\*/ URL = Snap.url = function(url) {\n        return \"url('#\" + url + \"')\";\n    };\n    function $(el, attr) {\n        if (attr) {\n            if (el == \"#text\") {\n                el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n            }\n            if (el == \"#comment\") {\n                el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n            }\n            if (typeof el == \"string\") {\n                el = $(el);\n            }\n            if (typeof attr == \"string\") {\n                if (el.nodeType == 1) {\n                    if (attr.substring(0, 6) == \"xlink:\") {\n                        return el.getAttributeNS(xlink, attr.substring(6));\n                    }\n                    if (attr.substring(0, 4) == \"xml:\") {\n                        return el.getAttributeNS(xmlns, attr.substring(4));\n                    }\n                    return el.getAttribute(attr);\n                } else if (attr == \"text\") {\n                    return el.nodeValue;\n                } else {\n                    return null;\n                }\n            }\n            if (el.nodeType == 1) {\n                for(var key in attr)if (attr[has](key)) {\n                    var val = Str(attr[key]);\n                    if (val) {\n                        if (key.substring(0, 6) == \"xlink:\") {\n                            el.setAttributeNS(xlink, key.substring(6), val);\n                        } else if (key.substring(0, 4) == \"xml:\") {\n                            el.setAttributeNS(xmlns, key.substring(4), val);\n                        } else {\n                            el.setAttribute(key, val);\n                        }\n                    } else {\n                        el.removeAttribute(key);\n                    }\n                }\n            } else if (\"text\" in attr) {\n                el.nodeValue = attr.text;\n            }\n        } else {\n            el = glob.doc.createElementNS(xmlns, el);\n        }\n        return el;\n    }\n    Snap._.$ = $;\n    Snap._.id = ID;\n    function getAttrs(el) {\n        var attrs = el.attributes, name, out = {};\n        for(var i = 0; i < attrs.length; i++){\n            if (attrs[i].namespaceURI == xlink) {\n                name = \"xlink:\";\n            } else {\n                name = \"\";\n            }\n            name += attrs[i].name;\n            out[name] = attrs[i].textContent;\n        }\n        return out;\n    }\n    function is(o, type) {\n        type = Str.prototype.toLowerCase.call(type);\n        if (type == \"finite\") {\n            return isFinite(o);\n        }\n        if (type == \"array\" && (o instanceof Array || Array.isArray && Array.isArray(o))) {\n            return true;\n        }\n        return type == \"null\" && o === null || type == typeof o && o !== null || type == \"object\" && o === Object(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;\n    }\n    /*\\\n * Snap.format\n [ method ]\n **\n * Replaces construction of type `{<name>}` to the corresponding argument\n **\n - token (string) string to format\n - json (object) object which properties are used as a replacement\n = (string) formatted string\n > Usage\n | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n |     x: 10,\n |     y: 20,\n |     dim: {\n |         width: 40,\n |         height: 50,\n |         \"negative width\": -40\n |     }\n | }));\n\\*/ Snap.format = function() {\n        var tokenRegex = /\\{([^\\}]+)\\}/g, objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, replacer = function(all, key, obj) {\n            var res1 = obj;\n            key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n                if (res1) {\n                    if (name in res1) {\n                        res1 = res1[name];\n                    }\n                    typeof res1 == \"function\" && isFunc && (res1 = res1());\n                }\n            });\n            res1 = (res1 == null || res1 == obj ? all : res1) + \"\";\n            return res1;\n        };\n        return function(str, obj) {\n            return Str(str).replace(tokenRegex, function(all, key) {\n                return replacer(all, key, obj);\n            });\n        };\n    }();\n    function clone(obj) {\n        if (typeof obj == \"function\" || Object(obj) !== obj) {\n            return obj;\n        }\n        var res1 = new obj.constructor;\n        for(var key in obj)if (obj[has](key)) {\n            res1[key] = clone(obj[key]);\n        }\n        return res1;\n    }\n    Snap._.clone = clone;\n    function repush(array, item) {\n        for(var i = 0, ii = array.length; i < ii; i++)if (array[i] === item) {\n            return array.push(array.splice(i, 1)[0]);\n        }\n    }\n    function cacher(f, scope, postprocessor) {\n        function newf() {\n            var arg = Array.prototype.slice.call(arguments, 0), args = arg.join(\"␀\"), cache = newf.cache = newf.cache || {}, count = newf.count = newf.count || [];\n            if (cache[has](args)) {\n                repush(count, args);\n                return postprocessor ? postprocessor(cache[args]) : cache[args];\n            }\n            count.length >= 1e3 && delete cache[count.shift()];\n            count.push(args);\n            cache[args] = f.apply(scope, arg);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        return newf;\n    }\n    Snap._.cacher = cacher;\n    function angle(x1, y1, x2, y2, x3, y3) {\n        if (x3 == null) {\n            var x = x1 - x2, y = y1 - y2;\n            if (!x && !y) {\n                return 0;\n            }\n            return (180 + math1.atan2(-y, -x) * 180 / PI + 360) % 360;\n        } else {\n            return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n        }\n    }\n    function rad(deg) {\n        return deg % 360 * PI / 180;\n    }\n    function deg(rad) {\n        return rad * 180 / PI % 360;\n    }\n    function x_y() {\n        return this.x + S + this.y;\n    }\n    function x_y_w_h() {\n        return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n    }\n    /*\\\n * Snap.rad\n [ method ]\n **\n * Transform angle to radians\n - deg (number) angle in degrees\n = (number) angle in radians\n\\*/ Snap.rad = rad;\n    /*\\\n * Snap.deg\n [ method ]\n **\n * Transform angle to degrees\n - rad (number) angle in radians\n = (number) angle in degrees\n\\*/ Snap.deg = deg;\n    /*\\\n * Snap.sin\n [ method ]\n **\n * Equivalent to `Math.sin()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) sin\n\\*/ Snap.sin = function(angle) {\n        return math1.sin(Snap.rad(angle));\n    };\n    /*\\\n * Snap.tan\n [ method ]\n **\n * Equivalent to `Math.tan()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) tan\n\\*/ Snap.tan = function(angle) {\n        return math1.tan(Snap.rad(angle));\n    };\n    /*\\\n * Snap.cos\n [ method ]\n **\n * Equivalent to `Math.cos()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) cos\n\\*/ Snap.cos = function(angle) {\n        return math1.cos(Snap.rad(angle));\n    };\n    /*\\\n * Snap.asin\n [ method ]\n **\n * Equivalent to `Math.asin()` only works with degrees, not radians.\n - num (number) value\n = (number) asin in degrees\n\\*/ Snap.asin = function(num) {\n        return Snap.deg(math1.asin(num));\n    };\n    /*\\\n * Snap.acos\n [ method ]\n **\n * Equivalent to `Math.acos()` only works with degrees, not radians.\n - num (number) value\n = (number) acos in degrees\n\\*/ Snap.acos = function(num) {\n        return Snap.deg(math1.acos(num));\n    };\n    /*\\\n * Snap.atan\n [ method ]\n **\n * Equivalent to `Math.atan()` only works with degrees, not radians.\n - num (number) value\n = (number) atan in degrees\n\\*/ Snap.atan = function(num) {\n        return Snap.deg(math1.atan(num));\n    };\n    /*\\\n * Snap.atan2\n [ method ]\n **\n * Equivalent to `Math.atan2()` only works with degrees, not radians.\n - num (number) value\n = (number) atan2 in degrees\n\\*/ Snap.atan2 = function(num) {\n        return Snap.deg(math1.atan2(num));\n    };\n    /*\\\n * Snap.angle\n [ method ]\n **\n * Returns an angle between two or three points\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n - x3 (number) #optional x coord of third point\n - y3 (number) #optional y coord of third point\n = (number) angle in degrees\n\\*/ Snap.angle = angle;\n    /*\\\n * Snap.len\n [ method ]\n **\n * Returns distance between two points\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/ Snap.len = function(x1, y1, x2, y2) {\n        return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n    };\n    /*\\\n * Snap.len2\n [ method ]\n **\n * Returns squared distance between two points\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/ Snap.len2 = function(x1, y1, x2, y2) {\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n    };\n    /*\\\n * Snap.closestPoint\n [ method ]\n **\n * Returns closest point to a given one on a given path.\n - path (Element) path element\n - x (number) x coord of a point\n - y (number) y coord of a point\n = (object) in format\n {\n    x (number) x coord of the point on the path\n    y (number) y coord of the point on the path\n    length (number) length of the path to the point\n    distance (number) distance from the given point to the path\n }\n\\*/ // Copied from http://bl.ocks.org/mbostock/8027637\n    Snap.closestPoint = function(path, x, y) {\n        function distance2(p) {\n            var dx = p.x - x, dy = p.y - y;\n            return dx * dx + dy * dy;\n        }\n        var pathNode = path.node, pathLength = pathNode.getTotalLength(), precision = pathLength / pathNode.pathSegList.numberOfItems * .125, best, bestLength, bestDistance = Infinity;\n        // linear scan for coarse approximation\n        for(var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision){\n            if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n                best = scan;\n                bestLength = scanLength;\n                bestDistance = scanDistance;\n            }\n        }\n        // binary search for precise estimate\n        precision *= .5;\n        while(precision > .5){\n            var before, after, beforeLength, afterLength, beforeDistance, afterDistance;\n            if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n                best = before;\n                bestLength = beforeLength;\n                bestDistance = beforeDistance;\n            } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n                best = after;\n                bestLength = afterLength;\n                bestDistance = afterDistance;\n            } else {\n                precision *= .5;\n            }\n        }\n        best = {\n            x: best.x,\n            y: best.y,\n            length: bestLength,\n            distance: Math.sqrt(bestDistance)\n        };\n        return best;\n    };\n    /*\\\n * Snap.is\n [ method ]\n **\n * Handy replacement for the `typeof` operator\n - o (…) any object or primitive\n - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n = (boolean) `true` if given value is of given type\n\\*/ Snap.is = is;\n    /*\\\n * Snap.snapTo\n [ method ]\n **\n * Snaps given value to given grid\n - values (array|number) given array of values or step of the grid\n - value (number) value to adjust\n - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n = (number) adjusted value\n\\*/ Snap.snapTo = function(values, value, tolerance) {\n        tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n        if (is(values, \"array\")) {\n            var i = values.length;\n            while(i--)if (abs(values[i] - value) <= tolerance) {\n                return values[i];\n            }\n        } else {\n            values = +values;\n            var rem = value % values;\n            if (rem < tolerance) {\n                return value - rem;\n            }\n            if (rem > values - tolerance) {\n                return value - rem + values;\n            }\n        }\n        return value;\n    };\n    // Colour\n    /*\\\n * Snap.getRGB\n [ method ]\n **\n * Parses color string as RGB object\n - color (string) color string in one of the following formats:\n # <ul>\n #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>\n #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>\n #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\n #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>\n # </ul>\n * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) true if string can't be parsed\n o }\n\\*/ Snap.getRGB = cacher(function(colour) {\n        if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n            return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                error: 1,\n                toString: rgbtoString\n            };\n        }\n        if (colour == \"none\") {\n            return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                toString: rgbtoString\n            };\n        }\n        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n        if (!colour) {\n            return {\n                r: -1,\n                g: -1,\n                b: -1,\n                hex: \"none\",\n                error: 1,\n                toString: rgbtoString\n            };\n        }\n        var res1, red, green, blue, opacity, t, values, rgb = colour.match(colourRegExp);\n        if (rgb) {\n            if (rgb[2]) {\n                blue = toInt(rgb[2].substring(5), 16);\n                green = toInt(rgb[2].substring(3, 5), 16);\n                red = toInt(rgb[2].substring(1, 3), 16);\n            }\n            if (rgb[3]) {\n                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n                green = toInt((t = rgb[3].charAt(2)) + t, 16);\n                red = toInt((t = rgb[3].charAt(1)) + t, 16);\n            }\n            if (rgb[4]) {\n                values = rgb[4].split(commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            }\n            if (rgb[5]) {\n                values = rgb[5].split(commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red /= 100);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green /= 100);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue /= 100);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return Snap.hsb2rgb(red, green, blue, opacity);\n            }\n            if (rgb[6]) {\n                values = rgb[6].split(commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red /= 100);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green /= 100);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue /= 100);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return Snap.hsl2rgb(red, green, blue, opacity);\n            }\n            red = mmin(math1.round(red), 255);\n            green = mmin(math1.round(green), 255);\n            blue = mmin(math1.round(blue), 255);\n            opacity = mmin(mmax(opacity, 0), 1);\n            rgb = {\n                r: red,\n                g: green,\n                b: blue,\n                toString: rgbtoString\n            };\n            rgb.hex = \"#\" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);\n            rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n            return rgb;\n        }\n        return {\n            r: -1,\n            g: -1,\n            b: -1,\n            hex: \"none\",\n            error: 1,\n            toString: rgbtoString\n        };\n    }, Snap);\n    /*\\\n * Snap.hsb\n [ method ]\n **\n * Converts HSB values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - b (number) value or brightness\n = (string) hex representation of the color\n\\*/ Snap.hsb = cacher(function(h, s, b) {\n        return Snap.hsb2rgb(h, s, b).hex;\n    });\n    /*\\\n * Snap.hsl\n [ method ]\n **\n * Converts HSL values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (string) hex representation of the color\n\\*/ Snap.hsl = cacher(function(h, s, l) {\n        return Snap.hsl2rgb(h, s, l).hex;\n    });\n    /*\\\n * Snap.rgb\n [ method ]\n **\n * Converts RGB values to a hex representation of the color\n - r (number) red\n - g (number) green\n - b (number) blue\n = (string) hex representation of the color\n\\*/ Snap.rgb = cacher(function(r, g1, b, o) {\n        if (is(o, \"finite\")) {\n            var round = math1.round;\n            return \"rgba(\" + [\n                round(r),\n                round(g1),\n                round(b),\n                +o.toFixed(2)\n            ] + \")\";\n        }\n        return \"#\" + (16777216 | b | g1 << 8 | r << 16).toString(16).slice(1);\n    });\n    var toHex = function(color) {\n        var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0], red = \"rgb(255, 0, 0)\";\n        toHex = cacher(function(color) {\n            if (color.toLowerCase() == \"red\") {\n                return red;\n            }\n            i.style.color = red;\n            i.style.color = color;\n            var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n            return out == red ? null : out;\n        });\n        return toHex(color);\n    }, hsbtoString = function() {\n        return \"hsb(\" + [\n            this.h,\n            this.s,\n            this.b\n        ] + \")\";\n    }, hsltoString = function() {\n        return \"hsl(\" + [\n            this.h,\n            this.s,\n            this.l\n        ] + \")\";\n    }, rgbtoString = function() {\n        return this.opacity == 1 || this.opacity == null ? this.hex : \"rgba(\" + [\n            this.r,\n            this.g,\n            this.b,\n            this.opacity\n        ] + \")\";\n    }, prepareRGB = function(r, g1, b) {\n        if (g1 == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n            b = r.b;\n            g1 = r.g;\n            r = r.r;\n        }\n        if (g1 == null && is(r, string)) {\n            var clr = Snap.getRGB(r);\n            r = clr.r;\n            g1 = clr.g;\n            b = clr.b;\n        }\n        if (r > 1 || g1 > 1 || b > 1) {\n            r /= 255;\n            g1 /= 255;\n            b /= 255;\n        }\n        return [\n            r,\n            g1,\n            b\n        ];\n    }, packageRGB = function(r, g1, b, o) {\n        r = math1.round(r * 255);\n        g1 = math1.round(g1 * 255);\n        b = math1.round(b * 255);\n        var rgb = {\n            r: r,\n            g: g1,\n            b: b,\n            opacity: is(o, \"finite\") ? o : 1,\n            hex: Snap.rgb(r, g1, b),\n            toString: rgbtoString\n        };\n        is(o, \"finite\") && (rgb.opacity = o);\n        return rgb;\n    };\n    /*\\\n * Snap.color\n [ method ]\n **\n * Parses the color string and returns an object featuring the color's component values\n - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n = (object) Combined RGB/HSB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••,\n o     error (boolean) `true` if string can't be parsed,\n o     h (number) hue,\n o     s (number) saturation,\n o     v (number) value (brightness),\n o     l (number) lightness\n o }\n\\*/ Snap.color = function(clr) {\n        var rgb;\n        if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n            rgb = Snap.hsb2rgb(clr);\n            clr.r = rgb.r;\n            clr.g = rgb.g;\n            clr.b = rgb.b;\n            clr.opacity = 1;\n            clr.hex = rgb.hex;\n        } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n            rgb = Snap.hsl2rgb(clr);\n            clr.r = rgb.r;\n            clr.g = rgb.g;\n            clr.b = rgb.b;\n            clr.opacity = 1;\n            clr.hex = rgb.hex;\n        } else {\n            if (is(clr, \"string\")) {\n                clr = Snap.getRGB(clr);\n            }\n            if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n                rgb = Snap.rgb2hsl(clr);\n                clr.h = rgb.h;\n                clr.s = rgb.s;\n                clr.l = rgb.l;\n                rgb = Snap.rgb2hsb(clr);\n                clr.v = rgb.b;\n            } else {\n                clr = {\n                    hex: \"none\"\n                };\n                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n                clr.error = 1;\n            }\n        }\n        clr.toString = rgbtoString;\n        return clr;\n    };\n    /*\\\n * Snap.hsb2rgb\n [ method ]\n **\n * Converts HSB values to an RGB object\n - h (number) hue\n - s (number) saturation\n - v (number) value or brightness\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n\\*/ Snap.hsb2rgb = function(h, s, v, o) {\n        if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n            v = h.b;\n            s = h.s;\n            o = h.o;\n            h = h.h;\n        }\n        h *= 360;\n        var R, G, B, X, C;\n        h = h % 360 / 60;\n        C = v * s;\n        X = C * (1 - abs(h % 2 - 1));\n        R = G = B = v - C;\n        h = ~~h;\n        R += [\n            C,\n            X,\n            0,\n            0,\n            X,\n            C\n        ][h];\n        G += [\n            X,\n            C,\n            C,\n            X,\n            0,\n            0\n        ][h];\n        B += [\n            0,\n            0,\n            X,\n            C,\n            C,\n            X\n        ][h];\n        return packageRGB(R, G, B, o);\n    };\n    /*\\\n * Snap.hsl2rgb\n [ method ]\n **\n * Converts HSL values to an RGB object\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #••••••\n o }\n\\*/ Snap.hsl2rgb = function(h, s, l, o) {\n        if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n            l = h.l;\n            s = h.s;\n            h = h.h;\n        }\n        if (h > 1 || s > 1 || l > 1) {\n            h /= 360;\n            s /= 100;\n            l /= 100;\n        }\n        h *= 360;\n        var R, G, B, X, C;\n        h = h % 360 / 60;\n        C = 2 * s * (l < .5 ? l : 1 - l);\n        X = C * (1 - abs(h % 2 - 1));\n        R = G = B = l - C / 2;\n        h = ~~h;\n        R += [\n            C,\n            X,\n            0,\n            0,\n            X,\n            C\n        ][h];\n        G += [\n            X,\n            C,\n            C,\n            X,\n            0,\n            0\n        ][h];\n        B += [\n            0,\n            0,\n            X,\n            C,\n            C,\n            X\n        ][h];\n        return packageRGB(R, G, B, o);\n    };\n    /*\\\n * Snap.rgb2hsb\n [ method ]\n **\n * Converts RGB values to an HSB object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSB object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     b (number) brightness\n o }\n\\*/ Snap.rgb2hsb = function(r, g1, b) {\n        b = prepareRGB(r, g1, b);\n        r = b[0];\n        g1 = b[1];\n        b = b[2];\n        var H, S, V, C;\n        V = mmax(r, g1, b);\n        C = V - mmin(r, g1, b);\n        H = C == 0 ? null : V == r ? (g1 - b) / C : V == g1 ? (b - r) / C + 2 : (r - g1) / C + 4;\n        H = (H + 360) % 6 * 60 / 360;\n        S = C == 0 ? 0 : C / V;\n        return {\n            h: H,\n            s: S,\n            b: V,\n            toString: hsbtoString\n        };\n    };\n    /*\\\n * Snap.rgb2hsl\n [ method ]\n **\n * Converts RGB values to an HSL object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSL object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     l (number) luminosity\n o }\n\\*/ Snap.rgb2hsl = function(r, g1, b) {\n        b = prepareRGB(r, g1, b);\n        r = b[0];\n        g1 = b[1];\n        b = b[2];\n        var H, S, L, M, m, C;\n        M = mmax(r, g1, b);\n        m = mmin(r, g1, b);\n        C = M - m;\n        H = C == 0 ? null : M == r ? (g1 - b) / C : M == g1 ? (b - r) / C + 2 : (r - g1) / C + 4;\n        H = (H + 360) % 6 * 60 / 360;\n        L = (M + m) / 2;\n        S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);\n        return {\n            h: H,\n            s: S,\n            l: L,\n            toString: hsltoString\n        };\n    };\n    // Transformations\n    /*\\\n * Snap.parsePathString\n [ method ]\n **\n * Utility method\n **\n * Parses given path string into an array of arrays of path segments\n - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n = (array) array of segments\n\\*/ Snap.parsePathString = function(pathString) {\n        if (!pathString) {\n            return null;\n        }\n        var pth = Snap.path(pathString);\n        if (pth.arr) {\n            return Snap.path.clone(pth.arr);\n        }\n        var paramCounts = {\n            a: 7,\n            c: 6,\n            o: 2,\n            h: 1,\n            l: 2,\n            m: 2,\n            r: 4,\n            q: 4,\n            s: 4,\n            t: 2,\n            v: 1,\n            u: 3,\n            z: 0\n        }, data = [];\n        if (is(pathString, \"array\") && is(pathString[0], \"array\")) {\n            data = Snap.path.clone(pathString);\n        }\n        if (!data.length) {\n            Str(pathString).replace(pathCommand, function(a, b, c) {\n                var params = [], name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    b && params.push(+b);\n                });\n                if (name == \"m\" && params.length > 2) {\n                    data.push([\n                        b\n                    ].concat(params.splice(0, 2)));\n                    name = \"l\";\n                    b = b == \"m\" ? \"l\" : \"L\";\n                }\n                if (name == \"o\" && params.length == 1) {\n                    data.push([\n                        b,\n                        params[0]\n                    ]);\n                }\n                if (name == \"r\") {\n                    data.push([\n                        b\n                    ].concat(params));\n                } else while(params.length >= paramCounts[name]){\n                    data.push([\n                        b\n                    ].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) {\n                        break;\n                    }\n                }\n            });\n        }\n        data.toString = Snap.path.toString;\n        pth.arr = Snap.path.clone(data);\n        return data;\n    };\n    /*\\\n * Snap.parseTransformString\n [ method ]\n **\n * Utility method\n **\n * Parses given transform string into an array of transformations\n - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n = (array) array of transformations\n\\*/ var parseTransformString = Snap.parseTransformString = function(TString) {\n        if (!TString) {\n            return null;\n        }\n        var paramCounts = {\n            r: 3,\n            s: 4,\n            t: 2,\n            m: 6\n        }, data = [];\n        if (is(TString, \"array\") && is(TString[0], \"array\")) {\n            data = Snap.path.clone(TString);\n        }\n        if (!data.length) {\n            Str(TString).replace(tCommand, function(a, b, c) {\n                var params = [], name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    b && params.push(+b);\n                });\n                data.push([\n                    b\n                ].concat(params));\n            });\n        }\n        data.toString = Snap.path.toString;\n        return data;\n    };\n    function svgTransform2string(tstr) {\n        var res1 = [];\n        tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function(all, name, params) {\n            params = params.split(/\\s*,\\s*|\\s+/);\n            if (name == \"rotate\" && params.length == 1) {\n                params.push(0, 0);\n            }\n            if (name == \"scale\") {\n                if (params.length > 2) {\n                    params = params.slice(0, 2);\n                } else if (params.length == 2) {\n                    params.push(0, 0);\n                }\n                if (params.length == 1) {\n                    params.push(params[0], 0, 0);\n                }\n            }\n            if (name == \"skewX\") {\n                res1.push([\n                    \"m\",\n                    1,\n                    0,\n                    math1.tan(rad(params[0])),\n                    1,\n                    0,\n                    0\n                ]);\n            } else if (name == \"skewY\") {\n                res1.push([\n                    \"m\",\n                    1,\n                    math1.tan(rad(params[0])),\n                    0,\n                    1,\n                    0,\n                    0\n                ]);\n            } else {\n                res1.push([\n                    name.charAt(0)\n                ].concat(params));\n            }\n            return all;\n        });\n        return res1;\n    }\n    Snap._.svgTransform2string = svgTransform2string;\n    Snap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\n    function transform2matrix(tstr, bbox) {\n        var tdata = parseTransformString(tstr), m = new Snap.Matrix;\n        if (tdata) {\n            for(var i = 0, ii = tdata.length; i < ii; i++){\n                var t = tdata[i], tlen = t.length, command = Str(t[0]).toLowerCase(), absolute = t[0] != command, inver = absolute ? m.invert() : 0, x1, y1, x2, y2, bb;\n                if (command == \"t\" && tlen == 2) {\n                    m.translate(t[1], 0);\n                } else if (command == \"t\" && tlen == 3) {\n                    if (absolute) {\n                        x1 = inver.x(0, 0);\n                        y1 = inver.y(0, 0);\n                        x2 = inver.x(t[1], t[2]);\n                        y2 = inver.y(t[1], t[2]);\n                        m.translate(x2 - x1, y2 - y1);\n                    } else {\n                        m.translate(t[1], t[2]);\n                    }\n                } else if (command == \"r\") {\n                    if (tlen == 2) {\n                        bb = bb || bbox;\n                        m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                    } else if (tlen == 4) {\n                        if (absolute) {\n                            x2 = inver.x(t[2], t[3]);\n                            y2 = inver.y(t[2], t[3]);\n                            m.rotate(t[1], x2, y2);\n                        } else {\n                            m.rotate(t[1], t[2], t[3]);\n                        }\n                    }\n                } else if (command == \"s\") {\n                    if (tlen == 2 || tlen == 3) {\n                        bb = bb || bbox;\n                        m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                    } else if (tlen == 4) {\n                        if (absolute) {\n                            x2 = inver.x(t[2], t[3]);\n                            y2 = inver.y(t[2], t[3]);\n                            m.scale(t[1], t[1], x2, y2);\n                        } else {\n                            m.scale(t[1], t[1], t[2], t[3]);\n                        }\n                    } else if (tlen == 5) {\n                        if (absolute) {\n                            x2 = inver.x(t[3], t[4]);\n                            y2 = inver.y(t[3], t[4]);\n                            m.scale(t[1], t[2], x2, y2);\n                        } else {\n                            m.scale(t[1], t[2], t[3], t[4]);\n                        }\n                    }\n                } else if (command == \"m\" && tlen == 7) {\n                    m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n                }\n            }\n        }\n        return m;\n    }\n    Snap._.transform2matrix = transform2matrix;\n    Snap._unit2px = unit2px;\n    var contains = glob.doc.contains || glob.doc.compareDocumentPosition ? function(a, b) {\n        var adown = a.nodeType == 9 ? a.documentElement : a, bup = b && b.parentNode;\n        return a == bup || !!(bup && bup.nodeType == 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n    } : function(a, b) {\n        if (b) {\n            while(b){\n                b = b.parentNode;\n                if (b == a) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    function getSomeDefs(el) {\n        var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || el.node.parentNode && wrap(el.node.parentNode) || Snap.select(\"svg\") || Snap(0, 0), pdefs = p.select(\"defs\"), defs = pdefs == null ? false : pdefs.node;\n        if (!defs) {\n            defs = make(\"defs\", p.node).node;\n        }\n        return defs;\n    }\n    function getSomeSVG(el) {\n        return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n    }\n    Snap._.getSomeDefs = getSomeDefs;\n    Snap._.getSomeSVG = getSomeSVG;\n    function unit2px(el, name, value) {\n        var svg = getSomeSVG(el).node, out = {}, mgr = svg.querySelector(\".svg---mgr\");\n        if (!mgr) {\n            mgr = $(\"rect\");\n            $(mgr, {\n                x: -9e9,\n                y: -9e9,\n                width: 10,\n                height: 10,\n                \"class\": \"svg---mgr\",\n                fill: \"none\"\n            });\n            svg.appendChild(mgr);\n        }\n        function getW(val) {\n            if (val == null) {\n                return E;\n            }\n            if (val == +val) {\n                return val;\n            }\n            $(mgr, {\n                width: val\n            });\n            try {\n                return mgr.getBBox().width;\n            } catch (e) {\n                return 0;\n            }\n        }\n        function getH(val) {\n            if (val == null) {\n                return E;\n            }\n            if (val == +val) {\n                return val;\n            }\n            $(mgr, {\n                height: val\n            });\n            try {\n                return mgr.getBBox().height;\n            } catch (e) {\n                return 0;\n            }\n        }\n        function set(nam, f) {\n            if (name == null) {\n                out[nam] = f(el.attr(nam) || 0);\n            } else if (nam == name) {\n                out = f(value == null ? el.attr(nam) || 0 : value);\n            }\n        }\n        switch(el.type){\n            case \"rect\":\n                set(\"rx\", getW);\n                set(\"ry\", getH);\n            case \"image\":\n                set(\"width\", getW);\n                set(\"height\", getH);\n            case \"text\":\n                set(\"x\", getW);\n                set(\"y\", getH);\n                break;\n            case \"circle\":\n                set(\"cx\", getW);\n                set(\"cy\", getH);\n                set(\"r\", getW);\n                break;\n            case \"ellipse\":\n                set(\"cx\", getW);\n                set(\"cy\", getH);\n                set(\"rx\", getW);\n                set(\"ry\", getH);\n                break;\n            case \"line\":\n                set(\"x1\", getW);\n                set(\"x2\", getW);\n                set(\"y1\", getH);\n                set(\"y2\", getH);\n                break;\n            case \"marker\":\n                set(\"refX\", getW);\n                set(\"markerWidth\", getW);\n                set(\"refY\", getH);\n                set(\"markerHeight\", getH);\n                break;\n            case \"radialGradient\":\n                set(\"fx\", getW);\n                set(\"fy\", getH);\n                break;\n            case \"tspan\":\n                set(\"dx\", getW);\n                set(\"dy\", getH);\n                break;\n            default:\n                set(name, getW);\n        }\n        svg.removeChild(mgr);\n        return out;\n    }\n    /*\\\n * Snap.select\n [ method ]\n **\n * Wraps a DOM element specified by CSS selector as @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/ Snap.select = function(query) {\n        query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n        return wrap(glob.doc.querySelector(query));\n    };\n    /*\\\n * Snap.selectAll\n [ method ]\n **\n * Wraps DOM elements specified by CSS selector as set or array of @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/ Snap.selectAll = function(query) {\n        var nodelist = glob.doc.querySelectorAll(query), set = (Snap.set || Array)();\n        for(var i = 0; i < nodelist.length; i++){\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    function add2group(list) {\n        if (!is(list, \"array\")) {\n            list = Array.prototype.slice.call(arguments, 0);\n        }\n        var i = 0, j = 0, node = this.node;\n        while(this[i])delete this[i++];\n        for(i = 0; i < list.length; i++){\n            if (list[i].type == \"set\") {\n                list[i].forEach(function(el) {\n                    node.appendChild(el.node);\n                });\n            } else {\n                node.appendChild(list[i].node);\n            }\n        }\n        var children = node.childNodes;\n        for(i = 0; i < children.length; i++){\n            this[j++] = wrap(children[i]);\n        }\n        return this;\n    }\n    // Hub garbage collector every 10s\n    setInterval(function() {\n        for(var key in hub)if (hub[has](key)) {\n            var el = hub[key], node = el.node;\n            if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n                delete hub[key];\n            }\n        }\n    }, 1e4);\n    function Element(el) {\n        if (el.snap in hub) {\n            return hub[el.snap];\n        }\n        var svg;\n        try {\n            svg = el.ownerSVGElement;\n        } catch (e) {}\n        /*\\\n     * Element.node\n     [ property (object) ]\n     **\n     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n     > Usage\n     | // draw a circle at coordinate 10,10 with radius of 10\n     | var c = paper.circle(10, 10, 10);\n     | c.node.onclick = function () {\n     |     c.attr(\"fill\", \"red\");\n     | };\n    \\*/ this.node = el;\n        if (svg) {\n            this.paper = new Paper(svg);\n        }\n        /*\\\n     * Element.type\n     [ property (string) ]\n     **\n     * SVG tag name of the given element.\n    \\*/ this.type = el.tagName || el.nodeName;\n        var id = this.id = ID(this);\n        this.anims = {};\n        this._ = {\n            transform: []\n        };\n        el.snap = id;\n        hub[id] = this;\n        if (this.type == \"g\") {\n            this.add = add2group;\n        }\n        if (this.type in {\n            g: 1,\n            mask: 1,\n            pattern: 1,\n            symbol: 1\n        }) {\n            for(var method in Paper.prototype)if (Paper.prototype[has](method)) {\n                this[method] = Paper.prototype[method];\n            }\n        }\n    }\n    /*\\\n     * Element.attr\n     [ method ]\n     **\n     * Gets or sets given attributes of the element.\n     **\n     - params (object) contains key-value pairs of attributes you want to set\n     * or\n     - param (string) name of the attribute\n     = (Element) the current element\n     * or\n     = (string) value of attribute\n     > Usage\n     | el.attr({\n     |     fill: \"#fc0\",\n     |     stroke: \"#000\",\n     |     strokeWidth: 2, // CamelCase...\n     |     \"fill-opacity\": 0.5, // or dash-separated names\n     |     width: \"*=2\" // prefixed values\n     | });\n     | console.log(el.attr(\"fill\")); // #fc0\n     * Prefixed values in format `\"+=10\"` supported. All four operations\n     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n     * and `-`: `\"+=2em\"`.\n    \\*/ Element.prototype.attr = function(params, value) {\n        var el = this, node = el.node;\n        if (!params) {\n            if (node.nodeType != 1) {\n                return {\n                    text: node.nodeValue\n                };\n            }\n            var attr = node.attributes, out = {};\n            for(var i = 0, ii = attr.length; i < ii; i++){\n                out[attr[i].nodeName] = attr[i].nodeValue;\n            }\n            return out;\n        }\n        if (is(params, \"string\")) {\n            if (arguments.length > 1) {\n                var json = {};\n                json[params] = value;\n                params = json;\n            } else {\n                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n            }\n        }\n        for(var att in params){\n            if (params[has](att)) {\n                eve(\"snap.util.attr.\" + att, el, params[att]);\n            }\n        }\n        return el;\n    };\n    /*\\\n * Snap.parse\n [ method ]\n **\n * Parses SVG fragment and converts it into a @Fragment\n **\n - svg (string) SVG string\n = (Fragment) the @Fragment\n\\*/ Snap.parse = function(svg) {\n        var f = glob.doc.createDocumentFragment(), full = true, div = glob.doc.createElement(\"div\");\n        svg = Str(svg);\n        if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n            svg = \"<svg>\" + svg + \"</svg>\";\n            full = false;\n        }\n        div.innerHTML = svg;\n        svg = div.getElementsByTagName(\"svg\")[0];\n        if (svg) {\n            if (full) {\n                f = svg;\n            } else {\n                while(svg.firstChild){\n                    f.appendChild(svg.firstChild);\n                }\n            }\n        }\n        return new Fragment(f);\n    };\n    function Fragment(frag) {\n        this.node = frag;\n    }\n    /*\\\n * Snap.fragment\n [ method ]\n **\n * Creates a DOM fragment from a given list of elements or strings\n **\n - varargs (…) SVG string\n = (Fragment) the @Fragment\n\\*/ Snap.fragment = function() {\n        var args = Array.prototype.slice.call(arguments, 0), f = glob.doc.createDocumentFragment();\n        for(var i = 0, ii = args.length; i < ii; i++){\n            var item = args[i];\n            if (item.node && item.node.nodeType) {\n                f.appendChild(item.node);\n            }\n            if (item.nodeType) {\n                f.appendChild(item);\n            }\n            if (typeof item == \"string\") {\n                f.appendChild(Snap.parse(item).node);\n            }\n        }\n        return new Fragment(f);\n    };\n    function make(name, parent) {\n        var res1 = $(name);\n        parent.appendChild(res1);\n        var el = wrap(res1);\n        return el;\n    }\n    function Paper(w, h) {\n        var res1, desc, defs, proto = Paper.prototype;\n        if (w && w.tagName && w.tagName.toLowerCase() == \"svg\") {\n            if (w.snap in hub) {\n                return hub[w.snap];\n            }\n            var doc = w.ownerDocument;\n            res1 = new Element(w);\n            desc = w.getElementsByTagName(\"desc\")[0];\n            defs = w.getElementsByTagName(\"defs\")[0];\n            if (!desc) {\n                desc = $(\"desc\");\n                desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n                res1.node.appendChild(desc);\n            }\n            if (!defs) {\n                defs = $(\"defs\");\n                res1.node.appendChild(defs);\n            }\n            res1.defs = defs;\n            for(var key in proto)if (proto[has](key)) {\n                res1[key] = proto[key];\n            }\n            res1.paper = res1.root = res1;\n        } else {\n            res1 = make(\"svg\", glob.doc.body);\n            $(res1.node, {\n                height: h,\n                version: 1.1,\n                width: w,\n                xmlns: xmlns\n            });\n        }\n        return res1;\n    }\n    function wrap(dom) {\n        if (!dom) {\n            return dom;\n        }\n        if (dom instanceof Element || dom instanceof Fragment) {\n            return dom;\n        }\n        if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n            return new Paper(dom);\n        }\n        if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n            return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n        }\n        return new Element(dom);\n    }\n    Snap._.make = make;\n    Snap._.wrap = wrap;\n    /*\\\n * Paper.el\n [ method ]\n **\n * Creates an element on paper with a given name and no attributes\n **\n - name (string) tag name\n - attr (object) attributes\n = (Element) the current element\n > Usage\n | var c = paper.circle(10, 10, 10); // is the same as...\n | var c = paper.el(\"circle\").attr({\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n | // and the same as\n | var c = paper.el(\"circle\", {\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n\\*/ Paper.prototype.el = function(name, attr) {\n        var el = make(name, this.node);\n        attr && el.attr(attr);\n        return el;\n    };\n    /*\\\n * Element.children\n [ method ]\n **\n * Returns array of all the children of the element.\n = (array) array of Elements\n\\*/ Element.prototype.children = function() {\n        var out = [], ch = this.node.childNodes;\n        for(var i = 0, ii = ch.length; i < ii; i++){\n            out[i] = Snap(ch[i]);\n        }\n        return out;\n    };\n    function jsonFiller(root, o) {\n        for(var i = 0, ii = root.length; i < ii; i++){\n            var item = {\n                type: root[i].type,\n                attr: root[i].attr()\n            }, children = root[i].children();\n            o.push(item);\n            if (children.length) {\n                jsonFiller(children, item.childNodes = []);\n            }\n        }\n    }\n    /*\\\n * Element.toJSON\n [ method ]\n **\n * Returns object representation of the given element and all its children.\n = (object) in format\n o {\n o     type (string) this.type,\n o     attr (object) attributes map,\n o     childNodes (array) optional array of children in the same format\n o }\n\\*/ Element.prototype.toJSON = function() {\n        var out = [];\n        jsonFiller([\n            this\n        ], out);\n        return out[0];\n    };\n    // default\n    eve.on(\"snap.util.getattr\", function() {\n        var att = eve.nt();\n        att = att.substring(att.lastIndexOf(\".\") + 1);\n        var css = att.replace(/[A-Z]/g, function(letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n        if (cssAttr[has](css)) {\n            return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n        } else {\n            return $(this.node, att);\n        }\n    });\n    var cssAttr = {\n        \"alignment-baseline\": 0,\n        \"baseline-shift\": 0,\n        \"clip\": 0,\n        \"clip-path\": 0,\n        \"clip-rule\": 0,\n        \"color\": 0,\n        \"color-interpolation\": 0,\n        \"color-interpolation-filters\": 0,\n        \"color-profile\": 0,\n        \"color-rendering\": 0,\n        \"cursor\": 0,\n        \"direction\": 0,\n        \"display\": 0,\n        \"dominant-baseline\": 0,\n        \"enable-background\": 0,\n        \"fill\": 0,\n        \"fill-opacity\": 0,\n        \"fill-rule\": 0,\n        \"filter\": 0,\n        \"flood-color\": 0,\n        \"flood-opacity\": 0,\n        \"font\": 0,\n        \"font-family\": 0,\n        \"font-size\": 0,\n        \"font-size-adjust\": 0,\n        \"font-stretch\": 0,\n        \"font-style\": 0,\n        \"font-variant\": 0,\n        \"font-weight\": 0,\n        \"glyph-orientation-horizontal\": 0,\n        \"glyph-orientation-vertical\": 0,\n        \"image-rendering\": 0,\n        \"kerning\": 0,\n        \"letter-spacing\": 0,\n        \"lighting-color\": 0,\n        \"marker\": 0,\n        \"marker-end\": 0,\n        \"marker-mid\": 0,\n        \"marker-start\": 0,\n        \"mask\": 0,\n        \"opacity\": 0,\n        \"overflow\": 0,\n        \"pointer-events\": 0,\n        \"shape-rendering\": 0,\n        \"stop-color\": 0,\n        \"stop-opacity\": 0,\n        \"stroke\": 0,\n        \"stroke-dasharray\": 0,\n        \"stroke-dashoffset\": 0,\n        \"stroke-linecap\": 0,\n        \"stroke-linejoin\": 0,\n        \"stroke-miterlimit\": 0,\n        \"stroke-opacity\": 0,\n        \"stroke-width\": 0,\n        \"text-anchor\": 0,\n        \"text-decoration\": 0,\n        \"text-rendering\": 0,\n        \"unicode-bidi\": 0,\n        \"visibility\": 0,\n        \"word-spacing\": 0,\n        \"writing-mode\": 0\n    };\n    eve.on(\"snap.util.attr\", function(value) {\n        var att = eve.nt(), attr = {};\n        att = att.substring(att.lastIndexOf(\".\") + 1);\n        attr[att] = value;\n        var style = att.replace(/-(\\w)/gi, function(all, letter) {\n            return letter.toUpperCase();\n        }), css = att.replace(/[A-Z]/g, function(letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n        if (cssAttr[has](css)) {\n            this.node.style[style] = value == null ? E : value;\n        } else {\n            $(this.node, attr);\n        }\n    });\n    (function(proto) {})(Paper.prototype);\n    // simple ajax\n    /*\\\n * Snap.ajax\n [ method ]\n **\n * Simple implementation of Ajax\n **\n - url (string) URL\n - postData (object|string) data for post request\n - callback (function) callback\n - scope (object) #optional scope of callback\n * or\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\\*/ Snap.ajax = function(url, postData, callback, scope) {\n        var req = new XMLHttpRequest, id = ID();\n        if (req) {\n            if (is(postData, \"function\")) {\n                scope = callback;\n                callback = postData;\n                postData = null;\n            } else if (is(postData, \"object\")) {\n                var pd = [];\n                for(var key in postData)if (postData.hasOwnProperty(key)) {\n                    pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n                }\n                postData = pd.join(\"&\");\n            }\n            req.open(postData ? \"POST\" : \"GET\", url, true);\n            if (postData) {\n                req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n            }\n            if (callback) {\n                eve.once(\"snap.ajax.\" + id + \".0\", callback);\n                eve.once(\"snap.ajax.\" + id + \".200\", callback);\n                eve.once(\"snap.ajax.\" + id + \".304\", callback);\n            }\n            req.onreadystatechange = function() {\n                if (req.readyState != 4) return;\n                eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n            };\n            if (req.readyState == 4) {\n                return req;\n            }\n            req.send(postData);\n            return req;\n        }\n    };\n    /*\\\n * Snap.load\n [ method ]\n **\n * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n **\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n\\*/ Snap.load = function(url, callback, scope) {\n        Snap.ajax(url, function(req) {\n            var f = Snap.parse(req.responseText);\n            scope ? callback.call(scope, f) : callback(f);\n        });\n    };\n    var getOffset = function(elem) {\n        var box = elem.getBoundingClientRect(), doc = elem.ownerDocument, body = doc.body, docElem = doc.documentElement, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop, left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n        return {\n            y: top,\n            x: left\n        };\n    };\n    /*\\\n * Snap.getElementByPoint\n [ method ]\n **\n * Returns you topmost element under given point.\n **\n = (object) Snap element object\n - x (number) x coordinate from the top left corner of the window\n - y (number) y coordinate from the top left corner of the window\n > Usage\n | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\\*/ Snap.getElementByPoint = function(x, y) {\n        var paper = this, svg = paper.canvas, target = glob.doc.elementFromPoint(x, y);\n        if (glob.win.opera && target.tagName == \"svg\") {\n            var so = getOffset(target), sr = target.createSVGRect();\n            sr.x = x - so.x;\n            sr.y = y - so.y;\n            sr.width = sr.height = 1;\n            var hits = target.getIntersectionList(sr, null);\n            if (hits.length) {\n                target = hits[hits.length - 1];\n            }\n        }\n        if (!target) {\n            return null;\n        }\n        return wrap(target);\n    };\n    /*\\\n * Snap.plugin\n [ method ]\n **\n * Let you write plugins. You pass in a function with five arguments, like this:\n | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n |     Snap.newmethod = function () {};\n |     Element.prototype.newmethod = function () {};\n |     Paper.prototype.newmethod = function () {};\n | });\n * Inside the function you have access to all main objects (and their\n * prototypes). This allow you to extend anything you want.\n **\n - f (function) your plugin body\n\\*/ Snap.plugin = function(f) {\n        f(Snap, Element, Paper, glob, Fragment);\n    };\n    glob.win.Snap = Snap;\n    return Snap;\n}(window || this);\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype, is = Snap.is, Str = String, unit2px = Snap._unit2px, $ = Snap._.$, make = Snap._.make, getSomeDefs = Snap._.getSomeDefs, has = \"hasOwnProperty\", wrap = Snap._.wrap;\n    /*\\\n     * Element.getBBox\n     [ method ]\n     **\n     * Returns the bounding box descriptor for the given element\n     **\n     = (object) bounding box descriptor:\n     o {\n     o     cx: (number) x of the center,\n     o     cy: (number) x of the center,\n     o     h: (number) height,\n     o     height: (number) height,\n     o     path: (string) path command for the box,\n     o     r0: (number) radius of a circle that fully encloses the box,\n     o     r1: (number) radius of the smallest circle that can be enclosed,\n     o     r2: (number) radius of the largest circle that can be enclosed,\n     o     vb: (string) box as a viewbox command,\n     o     w: (number) width,\n     o     width: (number) width,\n     o     x2: (number) x of the right side,\n     o     x: (number) x of the left side,\n     o     y2: (number) y of the bottom edge,\n     o     y: (number) y of the top edge\n     o }\n    \\*/ elproto.getBBox = function(isWithoutTransform) {\n        if (this.type == \"tspan\") {\n            return Snap._.box(this.node.getClientRects().item(0));\n        }\n        if (!Snap.Matrix || !Snap.path) {\n            return this.node.getBBox();\n        }\n        var el = this, m = new Snap.Matrix;\n        if (el.removed) {\n            return Snap._.box();\n        }\n        while(el.type == \"use\"){\n            if (!isWithoutTransform) {\n                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n            }\n            if (el.original) {\n                el = el.original;\n            } else {\n                var href = el.attr(\"xlink:href\");\n                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n            }\n        }\n        var _ = el._, pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n        try {\n            if (isWithoutTransform) {\n                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n                return Snap._.box(_.bboxwt);\n            } else {\n                el.realPath = pathfinder(el);\n                el.matrix = el.transform().localMatrix;\n                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n                return Snap._.box(_.bbox);\n            }\n        } catch (e) {\n            // Firefox doesn’t give you bbox of hidden element\n            return Snap._.box();\n        }\n    };\n    var propString = function() {\n        return this.string;\n    };\n    function extractTransform(el, tstr) {\n        if (tstr == null) {\n            var doReturn = true;\n            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n                tstr = el.node.getAttribute(\"gradientTransform\");\n            } else if (el.type == \"pattern\") {\n                tstr = el.node.getAttribute(\"patternTransform\");\n            } else {\n                tstr = el.node.getAttribute(\"transform\");\n            }\n            if (!tstr) {\n                return new Snap.Matrix;\n            }\n            tstr = Snap._.svgTransform2string(tstr);\n        } else {\n            if (!Snap._.rgTransform.test(tstr)) {\n                tstr = Snap._.svgTransform2string(tstr);\n            } else {\n                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || \"\");\n            }\n            if (is(tstr, \"array\")) {\n                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n            }\n            el._.transform = tstr;\n        }\n        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n        if (doReturn) {\n            return m;\n        } else {\n            el.matrix = m;\n        }\n    }\n    /*\\\n     * Element.transform\n     [ method ]\n     **\n     * Gets or sets transformation of the element\n     **\n     - tstr (string) transform string in Snap or SVG format\n     = (Element) the current element\n     * or\n     = (object) transformation descriptor:\n     o {\n     o     string (string) transform string,\n     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n     o     global (string) global transformation as string,\n     o     local (string) local transformation as string,\n     o     toString (function) returns `string` property\n     o }\n    \\*/ elproto.transform = function(tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            var papa = this, global = new Snap.Matrix(this.node.getCTM()), local = extractTransform(this), ms = [\n                local\n            ], m = new Snap.Matrix, i, localString = local.toTransformString(), string1 = Str(local) == Str(this.matrix) ? Str(_.transform) : localString;\n            while(papa.type != \"svg\" && (papa = papa.parent())){\n                ms.push(extractTransform(papa));\n            }\n            i = ms.length;\n            while(i--){\n                m.add(ms[i]);\n            }\n            return {\n                string: string1,\n                globalMatrix: global,\n                totalMatrix: m,\n                localMatrix: local,\n                diffMatrix: global.clone().add(local.invert()),\n                global: global.toTransformString(),\n                total: m.toTransformString(),\n                local: localString,\n                toString: propString\n            };\n        }\n        if (tstr instanceof Snap.Matrix) {\n            this.matrix = tstr;\n            this._.transform = tstr.toTransformString();\n        } else {\n            extractTransform(this, tstr);\n        }\n        if (this.node) {\n            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n                $(this.node, {\n                    gradientTransform: this.matrix\n                });\n            } else if (this.type == \"pattern\") {\n                $(this.node, {\n                    patternTransform: this.matrix\n                });\n            } else {\n                $(this.node, {\n                    transform: this.matrix\n                });\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.parent\n     [ method ]\n     **\n     * Returns the element's parent\n     **\n     = (Element) the parent element\n    \\*/ elproto.parent = function() {\n        return wrap(this.node.parentNode);\n    };\n    /*\\\n     * Element.append\n     [ method ]\n     **\n     * Appends the given element to current one\n     **\n     - el (Element|Set) element to append\n     = (Element) the parent element\n    \\*/ /*\\\n     * Element.add\n     [ method ]\n     **\n     * See @Element.append\n    \\*/ elproto.append = elproto.add = function(el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this;\n                el.forEach(function(el) {\n                    it.add(el);\n                });\n                return this;\n            }\n            el = wrap(el);\n            this.node.appendChild(el.node);\n            el.paper = this.paper;\n        }\n        return this;\n    };\n    /*\\\n     * Element.appendTo\n     [ method ]\n     **\n     * Appends the current element to the given one\n     **\n     - el (Element) parent element to append to\n     = (Element) the child element\n    \\*/ elproto.appendTo = function(el) {\n        if (el) {\n            el = wrap(el);\n            el.append(this);\n        }\n        return this;\n    };\n    /*\\\n     * Element.prepend\n     [ method ]\n     **\n     * Prepends the given element to the current one\n     **\n     - el (Element) element to prepend\n     = (Element) the parent element\n    \\*/ elproto.prepend = function(el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this, first;\n                el.forEach(function(el) {\n                    if (first) {\n                        first.after(el);\n                    } else {\n                        it.prepend(el);\n                    }\n                    first = el;\n                });\n                return this;\n            }\n            el = wrap(el);\n            var parent = el.parent();\n            this.node.insertBefore(el.node, this.node.firstChild);\n            this.add && this.add();\n            el.paper = this.paper;\n            this.parent() && this.parent().add();\n            parent && parent.add();\n        }\n        return this;\n    };\n    /*\\\n     * Element.prependTo\n     [ method ]\n     **\n     * Prepends the current element to the given one\n     **\n     - el (Element) parent element to prepend to\n     = (Element) the child element\n    \\*/ elproto.prependTo = function(el) {\n        el = wrap(el);\n        el.prepend(this);\n        return this;\n    };\n    /*\\\n     * Element.before\n     [ method ]\n     **\n     * Inserts given element before the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/ elproto.before = function(el) {\n        if (el.type == \"set\") {\n            var it = this;\n            el.forEach(function(el) {\n                var parent = el.parent();\n                it.node.parentNode.insertBefore(el.node, it.node);\n                parent && parent.add();\n            });\n            this.parent().add();\n            return this;\n        }\n        el = wrap(el);\n        var parent = el.parent();\n        this.node.parentNode.insertBefore(el.node, this.node);\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.after\n     [ method ]\n     **\n     * Inserts given element after the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/ elproto.after = function(el) {\n        el = wrap(el);\n        var parent = el.parent();\n        if (this.node.nextSibling) {\n            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n        } else {\n            this.node.parentNode.appendChild(el.node);\n        }\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/ elproto.insertBefore = function(el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/ elproto.insertAfter = function(el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the DOM\n     = (Element) the detached element\n    \\*/ elproto.remove = function() {\n        var parent = this.parent();\n        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n        delete this.paper;\n        this.removed = true;\n        parent && parent.add();\n        return this;\n    };\n    /*\\\n     * Element.select\n     [ method ]\n     **\n     * Gathers the nested @Element matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Element) result of query selection\n    \\*/ elproto.select = function(query) {\n        return wrap(this.node.querySelector(query));\n    };\n    /*\\\n     * Element.selectAll\n     [ method ]\n     **\n     * Gathers nested @Element objects matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Set|array) result of query selection\n    \\*/ elproto.selectAll = function(query) {\n        var nodelist = this.node.querySelectorAll(query), set = (Snap.set || Array)();\n        for(var i = 0; i < nodelist.length; i++){\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    /*\\\n     * Element.asPX\n     [ method ]\n     **\n     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n     **\n     - attr (string) attribute name\n     - value (string) #optional attribute value\n     = (Element) result of query selection\n    \\*/ elproto.asPX = function(attr, value) {\n        if (value == null) {\n            value = this.attr(attr);\n        }\n        return +unit2px(this, attr, value);\n    };\n    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n    /*\\\n     * Element.use\n     [ method ]\n     **\n     * Creates a `<use>` element linked to the current element\n     **\n     = (Element) the `<use>` element\n    \\*/ elproto.use = function() {\n        var use, id = this.node.id;\n        if (!id) {\n            id = this.id;\n            $(this.node, {\n                id: id\n            });\n        }\n        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" || this.type == \"pattern\") {\n            use = make(this.type, this.node.parentNode);\n        } else {\n            use = make(\"use\", this.node.parentNode);\n        }\n        $(use.node, {\n            \"xlink:href\": \"#\" + id\n        });\n        use.original = this;\n        return use;\n    };\n    function fixids(el) {\n        var els = el.selectAll(\"*\"), it, url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/, ids = [], uses = {};\n        function urltest(it, name) {\n            var val = $(it.node, name);\n            val = val && val.match(url);\n            val = val && val[2];\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function(id) {\n                    var attr = {};\n                    attr[name] = Snap.url(id);\n                    $(it.node, attr);\n                });\n            }\n        }\n        function linktest(it) {\n            var val = $(it.node, \"xlink:href\");\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function(id) {\n                    it.attr(\"xlink:href\", \"#\" + id);\n                });\n            }\n        }\n        for(var i = 0, ii = els.length; i < ii; i++){\n            it = els[i];\n            urltest(it, \"fill\");\n            urltest(it, \"stroke\");\n            urltest(it, \"filter\");\n            urltest(it, \"mask\");\n            urltest(it, \"clip-path\");\n            linktest(it);\n            var oldid = $(it.node, \"id\");\n            if (oldid) {\n                $(it.node, {\n                    id: it.id\n                });\n                ids.push({\n                    old: oldid,\n                    id: it.id\n                });\n            }\n        }\n        for(i = 0, ii = ids.length; i < ii; i++){\n            var fs = uses[ids[i].old];\n            if (fs) {\n                for(var j = 0, jj = fs.length; j < jj; j++){\n                    fs[j](ids[i].id);\n                }\n            }\n        }\n    }\n    /*\\\n     * Element.clone\n     [ method ]\n     **\n     * Creates a clone of the element and inserts it after the element\n     **\n     = (Element) the clone\n    \\*/ elproto.clone = function() {\n        var clone = wrap(this.node.cloneNode(true));\n        if ($(clone.node, \"id\")) {\n            $(clone.node, {\n                id: clone.id\n            });\n        }\n        fixids(clone);\n        clone.insertAfter(this);\n        return clone;\n    };\n    /*\\\n     * Element.toDefs\n     [ method ]\n     **\n     * Moves element to the shared `<defs>` area\n     **\n     = (Element) the element\n    \\*/ elproto.toDefs = function() {\n        var defs = getSomeDefs(this);\n        defs.appendChild(this.node);\n        return this;\n    };\n    /*\\\n     * Element.toPattern\n     [ method ]\n     **\n     * Creates a `<pattern>` element from the current element\n     **\n     * To create a pattern you have to specify the pattern rect:\n     - x (string|number)\n     - y (string|number)\n     - width (string|number)\n     - height (string|number)\n     = (Element) the `<pattern>` element\n     * You can use pattern later on as an argument for `fill` attribute:\n     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n     |         fill: \"none\",\n     |         stroke: \"#bada55\",\n     |         strokeWidth: 5\n     |     }).pattern(0, 0, 10, 10),\n     |     c = paper.circle(200, 200, 100);\n     | c.attr({\n     |     fill: p\n     | });\n    \\*/ elproto.pattern = elproto.toPattern = function(x, y, width, height) {\n        var p = make(\"pattern\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        $(p.node, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            id: p.id,\n            viewBox: [\n                x,\n                y,\n                width,\n                height\n            ].join(\" \")\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    // SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n    // SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n    /*\\\n     * Element.marker\n     [ method ]\n     **\n     * Creates a `<marker>` element from the current element\n     **\n     * To create a marker you have to specify the bounding rect and reference point:\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - refX (number)\n     - refY (number)\n     = (Element) the `<marker>` element\n     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n    \\*/ // TODO add usage for markers\n    elproto.marker = function(x, y, width, height, refX, refY) {\n        var p = make(\"marker\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            refX = x.refX || x.cx;\n            refY = x.refY || x.cy;\n            x = x.x;\n        }\n        $(p.node, {\n            viewBox: [\n                x,\n                y,\n                width,\n                height\n            ].join(\" \"),\n            markerWidth: width,\n            markerHeight: height,\n            orient: \"auto\",\n            refX: refX || 0,\n            refY: refY || 0,\n            id: p.id\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    var eldata = {};\n    /*\\\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value associated with given key. (Don’t confuse\n     * with `data-` attributes)\n     *\n     * See also @Element.removeData\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n    \\*/ elproto.data = function(key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0) {\n            eve(\"snap.data.get.\" + this.id, this, data, null);\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (Snap.is(key, \"object\")) {\n                for(var i in key)if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"snap.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*\\\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     - key (string) #optional key\n     = (object) @Element\n    \\*/ elproto.removeData = function(key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*\\\n     * Element.outerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n     *\n     * See also @Element.innerSVG\n     = (string) SVG code for the element\n    \\*/ /*\\\n     * Element.toString\n     [ method ]\n     **\n     * See @Element.outerSVG\n    \\*/ elproto.outerSVG = elproto.toString = toString(1);\n    /*\\\n     * Element.innerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n     = (string) SVG code for the element\n    \\*/ elproto.innerSVG = toString();\n    function toString(type) {\n        return function() {\n            var res1 = type ? \"<\" + this.type : \"\", attr = this.node.attributes, chld = this.node.childNodes;\n            if (type) {\n                for(var i = 0, ii = attr.length; i < ii; i++){\n                    res1 += \" \" + attr[i].name + '=\"' + attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n                }\n            }\n            if (chld.length) {\n                type && (res1 += \">\");\n                for(i = 0, ii = chld.length; i < ii; i++){\n                    if (chld[i].nodeType == 3) {\n                        res1 += chld[i].nodeValue;\n                    } else if (chld[i].nodeType == 1) {\n                        res1 += wrap(chld[i]).toString();\n                    }\n                }\n                type && (res1 += \"</\" + this.type + \">\");\n            } else {\n                type && (res1 += \"/>\");\n            }\n            return res1;\n        };\n    }\n    elproto.toDataURL = function() {\n        if (window && window.btoa) {\n            var bb = this.getBBox(), svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n                x: +bb.x.toFixed(3),\n                y: +bb.y.toFixed(3),\n                width: +bb.width.toFixed(3),\n                height: +bb.height.toFixed(3),\n                contents: this.outerSVG()\n            });\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        }\n    };\n    /*\\\n     * Fragment.select\n     [ method ]\n     **\n     * See @Element.select\n    \\*/ Fragment.prototype.select = elproto.select;\n    /*\\\n     * Fragment.selectAll\n     [ method ]\n     **\n     * See @Element.selectAll\n    \\*/ Fragment.prototype.selectAll = elproto.selectAll;\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var objectToString = Object.prototype.toString, Str = String, math1 = Math, E = \"\";\n    function Matrix(a, b, c, d, e, f) {\n        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n            return;\n        }\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function(matrixproto) {\n        /*\\\n         * Matrix.add\n         [ method ]\n         **\n         * Adds the given matrix to existing one\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/ matrixproto.add = function(a, b, c, d, e, f) {\n            if (a && a instanceof Matrix) {\n                return this.add(a.a, a.b, a.c, a.d, a.e, a.f);\n            }\n            var aNew = a * this.a + b * this.c, bNew = a * this.b + b * this.d;\n            this.e += e * this.a + f * this.c;\n            this.f += e * this.b + f * this.d;\n            this.c = c * this.a + d * this.c;\n            this.d = c * this.b + d * this.d;\n            this.a = aNew;\n            this.b = bNew;\n            return this;\n        };\n        /*\\\n         * Matrix.multLeft\n         [ method ]\n         **\n         * Multiplies a passed affine transform to the left: M * this.\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/ Matrix.prototype.multLeft = function(a, b, c, d, e, f) {\n            if (a && a instanceof Matrix) {\n                return this.multLeft(a.a, a.b, a.c, a.d, a.e, a.f);\n            }\n            var aNew = a * this.a + c * this.b, cNew = a * this.c + c * this.d, eNew = a * this.e + c * this.f + e;\n            this.b = b * this.a + d * this.b;\n            this.d = b * this.c + d * this.d;\n            this.f = b * this.e + d * this.f + f;\n            this.a = aNew;\n            this.c = cNew;\n            this.e = eNew;\n            return this;\n        };\n        /*\\\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns an inverted version of the matrix\n         = (object) @Matrix\n        \\*/ matrixproto.invert = function() {\n            var me = this, x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*\\\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns a copy of the matrix\n         = (object) @Matrix\n        \\*/ matrixproto.clone = function() {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*\\\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         - x (number) horizontal offset distance\n         - y (number) vertical offset distance\n        \\*/ matrixproto.translate = function(x, y) {\n            this.e += x * this.a + y * this.c;\n            this.f += x * this.b + y * this.d;\n            return this;\n        };\n        /*\\\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         - x (number) amount to be scaled, with `1` resulting in no change\n         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n         - cx (number) #optional horizontal origin point from which to scale\n         - cy (number) #optional vertical origin point from which to scale\n         * Default cx, cy is the middle point of the element.\n        \\*/ matrixproto.scale = function(x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.translate(cx, cy);\n            this.a *= x;\n            this.b *= x;\n            this.c *= y;\n            this.d *= y;\n            (cx || cy) && this.translate(-cx, -cy);\n            return this;\n        };\n        /*\\\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         - a (number) angle of rotation, in degrees\n         - x (number) horizontal origin point from which to rotate\n         - y (number) vertical origin point from which to rotate\n        \\*/ matrixproto.rotate = function(a, x, y) {\n            a = Snap.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math1.cos(a).toFixed(9), sin = +math1.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            return this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*\\\n         * Matrix.skewX\n         [ method ]\n         **\n         * Skews the matrix along the x-axis\n         - x (number) Angle to skew along the x-axis (in degrees).\n        \\*/ matrixproto.skewX = function(x) {\n            return this.skew(x, 0);\n        };\n        /*\\\n         * Matrix.skewY\n         [ method ]\n         **\n         * Skews the matrix along the y-axis\n         - y (number) Angle to skew along the y-axis (in degrees).\n        \\*/ matrixproto.skewY = function(y) {\n            return this.skew(0, y);\n        };\n        /*\\\n         * Matrix.skew\n         [ method ]\n         **\n         * Skews the matrix\n         - y (number) Angle to skew along the y-axis (in degrees).\n         - x (number) Angle to skew along the x-axis (in degrees).\n        \\*/ matrixproto.skew = function(x, y) {\n            x = x || 0;\n            y = y || 0;\n            x = Snap.rad(x);\n            y = Snap.rad(y);\n            var c = math1.tan(x).toFixed(9);\n            var b = math1.tan(y).toFixed(9);\n            return this.add(1, b, c, 1, 0, 0);\n        };\n        /*\\\n         * Matrix.x\n         [ method ]\n         **\n         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         - x (number)\n         - y (number)\n         = (number) x\n        \\*/ matrixproto.x = function(x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*\\\n         * Matrix.y\n         [ method ]\n         **\n         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         - x (number)\n         - y (number)\n         = (number) y\n        \\*/ matrixproto.y = function(x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function(i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function() {\n            return \"matrix(\" + [\n                this.get(0),\n                this.get(1),\n                this.get(2),\n                this.get(3),\n                this.get(4),\n                this.get(5)\n            ].join() + \")\";\n        };\n        matrixproto.offset = function() {\n            return [\n                this.e.toFixed(4),\n                this.f.toFixed(4)\n            ];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math1.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*\\\n         * Matrix.determinant\n         [ method ]\n         **\n         * Finds determinant of the given matrix.\n         = (number) determinant\n        \\*/ matrixproto.determinant = function() {\n            return this.a * this.d - this.b * this.c;\n        };\n        /*\\\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n        \\*/ matrixproto.split = function() {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n            // scale and shear\n            var row = [\n                [\n                    this.a,\n                    this.b\n                ],\n                [\n                    this.c,\n                    this.d\n                ]\n            ];\n            out.scalex = math1.sqrt(norm(row[0]));\n            normalize(row[0]);\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [\n                row[1][0] - row[0][0] * out.shear,\n                row[1][1] - row[0][1] * out.shear\n            ];\n            out.scaley = math1.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n            if (this.determinant() < 0) {\n                out.scalex = -out.scalex;\n            }\n            // rotation\n            var sin = row[0][1], cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = Snap.deg(math1.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = Snap.deg(math1.asin(sin));\n            }\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*\\\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Returns transform string that represents given matrix\n         = (string) transform string\n        \\*/ matrixproto.toTransformString = function(shorter) {\n            var s = shorter || this.split();\n            if (!+s.shear.toFixed(9)) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return (s.dx || s.dy ? \"t\" + [\n                    +s.dx.toFixed(4),\n                    +s.dy.toFixed(4)\n                ] : E) + (s.rotate ? \"r\" + [\n                    +s.rotate.toFixed(4),\n                    0,\n                    0\n                ] : E) + (s.scalex != 1 || s.scaley != 1 ? \"s\" + [\n                    s.scalex,\n                    s.scaley,\n                    0,\n                    0\n                ] : E);\n            } else {\n                return \"m\" + [\n                    this.get(0),\n                    this.get(1),\n                    this.get(2),\n                    this.get(3),\n                    this.get(4),\n                    this.get(5)\n                ];\n            }\n        };\n    })(Matrix.prototype);\n    /*\\\n     * Snap.Matrix\n     [ method ]\n     **\n     * Matrix constructor, extend on your own risk.\n     * To create matrices use @Snap.matrix.\n    \\*/ Snap.Matrix = Matrix;\n    /*\\\n     * Snap.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns a matrix based on the given parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     * or\n     - svgMatrix (SVGMatrix)\n     = (object) @Matrix\n    \\*/ Snap.matrix = function(a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var has = \"hasOwnProperty\", make = Snap._.make, wrap = Snap._.wrap, is = Snap.is, getSomeDefs = Snap._.getSomeDefs, reURLValue = /^url\\((['\"]?)([^)]+)\\1\\)$/, $ = Snap._.$, URL = Snap.url, Str = String, separator = Snap._.separator, E = \"\";\n    /*\\\n     * Snap.deurl\n     [ method ]\n     **\n     * Unwraps path from `\"url(<path>)\"`.\n     - value (string) url path\n     = (string) unwrapped path\n    \\*/ Snap.deurl = function(value) {\n        var res1 = String(value).match(reURLValue);\n        return res1 ? res1[2] : value;\n    };\n    // Attributes event handlers\n    eve.on(\"snap.util.attr.mask\", function(value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value.type == \"mask\") {\n                var mask = value;\n            } else {\n                mask = make(\"mask\", getSomeDefs(this));\n                mask.node.appendChild(value.node);\n            }\n            !mask.node.id && $(mask.node, {\n                id: mask.id\n            });\n            $(this.node, {\n                mask: URL(mask.id)\n            });\n        }\n    });\n    (function(clipIt) {\n        eve.on(\"snap.util.attr.clip\", clipIt);\n        eve.on(\"snap.util.attr.clip-path\", clipIt);\n        eve.on(\"snap.util.attr.clipPath\", clipIt);\n    })(function(value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            var clip, node = value.node;\n            while(node){\n                if (node.nodeName === \"clipPath\") {\n                    clip = new Element(node);\n                    break;\n                }\n                if (node.nodeName === \"svg\") {\n                    clip = undefined;\n                    break;\n                }\n                node = node.parentNode;\n            }\n            if (!clip) {\n                clip = make(\"clipPath\", getSomeDefs(this));\n                clip.node.appendChild(value.node);\n                !clip.node.id && $(clip.node, {\n                    id: clip.id\n                });\n            }\n            $(this.node, {\n                \"clip-path\": URL(clip.node.id || clip.id)\n            });\n        }\n    });\n    function fillStroke(name) {\n        return function(value) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1 && (value.node.firstChild.tagName == \"radialGradient\" || value.node.firstChild.tagName == \"linearGradient\" || value.node.firstChild.tagName == \"pattern\")) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value instanceof Element) {\n                if (value.type == \"radialGradient\" || value.type == \"linearGradient\" || value.type == \"pattern\") {\n                    if (!value.node.id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    var fill = URL(value.node.id);\n                } else {\n                    fill = value.attr(name);\n                }\n            } else {\n                fill = Snap.color(value);\n                if (fill.error) {\n                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n                    if (grad) {\n                        if (!grad.node.id) {\n                            $(grad.node, {\n                                id: grad.id\n                            });\n                        }\n                        fill = URL(grad.node.id);\n                    } else {\n                        fill = value;\n                    }\n                } else {\n                    fill = Str(fill);\n                }\n            }\n            var attrs = {};\n            attrs[name] = fill;\n            $(this.node, attrs);\n            this.node.style[name] = E;\n        };\n    }\n    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n    eve.on(\"snap.util.grad.parse\", function parseGrad(string1) {\n        string1 = Str(string1);\n        var tokens = string1.match(gradrg);\n        if (!tokens) {\n            return null;\n        }\n        var type = tokens[1], params = tokens[2], stops = tokens[3];\n        params = params.split(/\\s*,\\s*/).map(function(el) {\n            return +el == el ? +el : el;\n        });\n        if (params.length == 1 && params[0] == 0) {\n            params = [];\n        }\n        stops = stops.split(\"-\");\n        stops = stops.map(function(el) {\n            el = el.split(\":\");\n            var out = {\n                color: el[0]\n            };\n            if (el[1]) {\n                out.offset = parseFloat(el[1]);\n            }\n            return out;\n        });\n        var len = stops.length, start = 0, j = 0;\n        function seed(i, end) {\n            var step = (end - start) / (i - j);\n            for(var k = j; k < i; k++){\n                stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n            }\n            j = i;\n            start = end;\n        }\n        len--;\n        for(var i = 0; i < len; i++)if (\"offset\" in stops[i]) {\n            seed(i, stops[i].offset);\n        }\n        stops[len].offset = stops[len].offset || 100;\n        seed(len, stops[len].offset);\n        return {\n            type: type,\n            params: params,\n            stops: stops\n        };\n    });\n    eve.on(\"snap.util.attr.d\", function(value) {\n        eve.stop();\n        if (is(value, \"array\") && is(value[0], \"array\")) {\n            value = Snap.path.toString.call(value);\n        }\n        value = Str(value);\n        if (value.match(/[ruo]/i)) {\n            value = Snap.path.toAbsolute(value);\n        }\n        $(this.node, {\n            d: value\n        });\n    })(-1);\n    eve.on(\"snap.util.attr.#text\", function(value) {\n        eve.stop();\n        value = Str(value);\n        var txt = glob.doc.createTextNode(value);\n        while(this.node.firstChild){\n            this.node.removeChild(this.node.firstChild);\n        }\n        this.node.appendChild(txt);\n    })(-1);\n    eve.on(\"snap.util.attr.path\", function(value) {\n        eve.stop();\n        this.attr({\n            d: value\n        });\n    })(-1);\n    eve.on(\"snap.util.attr.class\", function(value) {\n        eve.stop();\n        this.node.className.baseVal = value;\n    })(-1);\n    eve.on(\"snap.util.attr.viewBox\", function(value) {\n        var vb;\n        if (is(value, \"object\") && \"x\" in value) {\n            vb = [\n                value.x,\n                value.y,\n                value.width,\n                value.height\n            ].join(\" \");\n        } else if (is(value, \"array\")) {\n            vb = value.join(\" \");\n        } else {\n            vb = value;\n        }\n        $(this.node, {\n            viewBox: vb\n        });\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.transform\", function(value) {\n        this.transform(value);\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.r\", function(value) {\n        if (this.type == \"rect\") {\n            eve.stop();\n            $(this.node, {\n                rx: value,\n                ry: value\n            });\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.textpath\", function(value) {\n        eve.stop();\n        if (this.type == \"text\") {\n            var id, tp, node;\n            if (!value && this.textPath) {\n                tp = this.textPath;\n                while(tp.node.firstChild){\n                    this.node.appendChild(tp.node.firstChild);\n                }\n                tp.remove();\n                delete this.textPath;\n                return;\n            }\n            if (is(value, \"string\")) {\n                var defs = getSomeDefs(this), path = wrap(defs.parentNode).path(value);\n                defs.appendChild(path.node);\n                id = path.id;\n                path.attr({\n                    id: id\n                });\n            } else {\n                value = wrap(value);\n                if (value instanceof Element) {\n                    id = value.attr(\"id\");\n                    if (!id) {\n                        id = value.id;\n                        value.attr({\n                            id: id\n                        });\n                    }\n                }\n            }\n            if (id) {\n                tp = this.textPath;\n                node = this.node;\n                if (tp) {\n                    tp.attr({\n                        \"xlink:href\": \"#\" + id\n                    });\n                } else {\n                    tp = $(\"textPath\", {\n                        \"xlink:href\": \"#\" + id\n                    });\n                    while(node.firstChild){\n                        tp.appendChild(node.firstChild);\n                    }\n                    node.appendChild(tp);\n                    this.textPath = wrap(tp);\n                }\n            }\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.text\", function(value) {\n        if (this.type == \"text\") {\n            var i = 0, node = this.node, tuner = function(chunk) {\n                var out = $(\"tspan\");\n                if (is(chunk, \"array\")) {\n                    for(var i = 0; i < chunk.length; i++){\n                        out.appendChild(tuner(chunk[i]));\n                    }\n                } else {\n                    out.appendChild(glob.doc.createTextNode(chunk));\n                }\n                out.normalize && out.normalize();\n                return out;\n            };\n            while(node.firstChild){\n                node.removeChild(node.firstChild);\n            }\n            var tuned = tuner(value);\n            while(tuned.firstChild){\n                node.appendChild(tuned.firstChild);\n            }\n        }\n        eve.stop();\n    })(-1);\n    function setFontSize(value) {\n        eve.stop();\n        if (value == +value) {\n            value += \"px\";\n        }\n        this.node.style.fontSize = value;\n    }\n    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n    eve.on(\"snap.util.getattr.transform\", function() {\n        eve.stop();\n        return this.transform();\n    })(-1);\n    eve.on(\"snap.util.getattr.textpath\", function() {\n        eve.stop();\n        return this.textPath;\n    })(-1);\n    // Markers\n    (function() {\n        function getter(end) {\n            return function() {\n                eve.stop();\n                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n                if (style == \"none\") {\n                    return style;\n                } else {\n                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n                }\n            };\n        }\n        function setter(end) {\n            return function(value) {\n                eve.stop();\n                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n                if (value == \"\" || !value) {\n                    this.node.style[name] = \"none\";\n                    return;\n                }\n                if (value.type == \"marker\") {\n                    var id = value.node.id;\n                    if (!id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    this.node.style[name] = URL(id);\n                    return;\n                }\n            };\n        }\n        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n    })();\n    eve.on(\"snap.util.getattr.r\", function() {\n        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n            eve.stop();\n            return $(this.node, \"rx\");\n        }\n    })(-1);\n    function textExtract(node) {\n        var out = [];\n        var children = node.childNodes;\n        for(var i = 0, ii = children.length; i < ii; i++){\n            var chi = children[i];\n            if (chi.nodeType == 3) {\n                out.push(chi.nodeValue);\n            }\n            if (chi.tagName == \"tspan\") {\n                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n                    out.push(chi.firstChild.nodeValue);\n                } else {\n                    out.push(textExtract(chi));\n                }\n            }\n        }\n        return out;\n    }\n    eve.on(\"snap.util.getattr.text\", function() {\n        if (this.type == \"text\" || this.type == \"tspan\") {\n            eve.stop();\n            var out = textExtract(this.node);\n            return out.length == 1 ? out[0] : out;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.#text\", function() {\n        return this.node.textContent;\n    })(-1);\n    eve.on(\"snap.util.getattr.fill\", function(internal) {\n        if (internal) {\n            return;\n        }\n        eve.stop();\n        var value = eve(\"snap.util.getattr.fill\", this, true).firstDefined();\n        return Snap(Snap.deurl(value)) || value;\n    })(-1);\n    eve.on(\"snap.util.getattr.stroke\", function(internal) {\n        if (internal) {\n            return;\n        }\n        eve.stop();\n        var value = eve(\"snap.util.getattr.stroke\", this, true).firstDefined();\n        return Snap(Snap.deurl(value)) || value;\n    })(-1);\n    eve.on(\"snap.util.getattr.viewBox\", function() {\n        eve.stop();\n        var vb = $(this.node, \"viewBox\");\n        if (vb) {\n            vb = vb.split(separator);\n            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.points\", function() {\n        var p = $(this.node, \"points\");\n        eve.stop();\n        if (p) {\n            return p.split(separator);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.path\", function() {\n        var p = $(this.node, \"d\");\n        eve.stop();\n        return p;\n    })(-1);\n    eve.on(\"snap.util.getattr.class\", function() {\n        return this.node.className.baseVal;\n    })(-1);\n    function getFontSize() {\n        eve.stop();\n        return this.node.style.fontSize;\n    }\n    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n});\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var rgNotSpace = /\\S+/g, rgBadSpace = /[\\t\\r\\n\\f]/g, rgTrim = /(^\\s+|\\s+$)/g, Str = String, elproto = Element.prototype;\n    /*\\\n     * Element.addClass\n     [ method ]\n     **\n     * Adds given class name or list of class names to the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/ elproto.addClass = function(value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [], elem = this.node, className = elem.className.baseVal, curClasses = className.match(rgNotSpace) || [], j, pos, clazz, finalValue;\n        if (classes.length) {\n            j = 0;\n            while(clazz = classes[j++]){\n                pos = curClasses.indexOf(clazz);\n                if (!~pos) {\n                    curClasses.push(clazz);\n                }\n            }\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.removeClass\n     [ method ]\n     **\n     * Removes given class name or list of class names from the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/ elproto.removeClass = function(value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [], elem = this.node, className = elem.className.baseVal, curClasses = className.match(rgNotSpace) || [], j, pos, clazz, finalValue;\n        if (curClasses.length) {\n            j = 0;\n            while(clazz = classes[j++]){\n                pos = curClasses.indexOf(clazz);\n                if (~pos) {\n                    curClasses.splice(pos, 1);\n                }\n            }\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.hasClass\n     [ method ]\n     **\n     * Checks if the element has a given class name in the list of class names applied to it.\n     - value (string) class name\n     **\n     = (boolean) `true` if the element has given class\n    \\*/ elproto.hasClass = function(value) {\n        var elem = this.node, className = elem.className.baseVal, curClasses = className.match(rgNotSpace) || [];\n        return !!~curClasses.indexOf(value);\n    };\n    /*\\\n     * Element.toggleClass\n     [ method ]\n     **\n     * Add or remove one or more classes from the element, depending on either\n     * the class’s presence or the value of the `flag` argument.\n     - value (string) class name or space separated list of class names\n     - flag (boolean) value to determine whether the class should be added or removed\n     **\n     = (Element) original element.\n    \\*/ elproto.toggleClass = function(value, flag) {\n        if (flag != null) {\n            if (flag) {\n                return this.addClass(value);\n            } else {\n                return this.removeClass(value);\n            }\n        }\n        var classes = (value || \"\").match(rgNotSpace) || [], elem = this.node, className = elem.className.baseVal, curClasses = className.match(rgNotSpace) || [], j, pos, clazz, finalValue;\n        j = 0;\n        while(clazz = classes[j++]){\n            pos = curClasses.indexOf(clazz);\n            if (~pos) {\n                curClasses.splice(pos, 1);\n            } else {\n                curClasses.push(clazz);\n            }\n        }\n        finalValue = curClasses.join(\" \");\n        if (className != finalValue) {\n            elem.className.baseVal = finalValue;\n        }\n        return this;\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var operators = {\n        \"+\": function(x, y) {\n            return x + y;\n        },\n        \"-\": function(x, y) {\n            return x - y;\n        },\n        \"/\": function(x, y) {\n            return x / y;\n        },\n        \"*\": function(x, y) {\n            return x * y;\n        }\n    }, Str = String, reUnit = /[a-z]+$/i, reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function(val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    eve.on(\"snap.util.attr\", function(val) {\n        var plus = Str(val).match(reAddon);\n        if (plus) {\n            var evnt = eve.nt(), name = evnt.substring(evnt.lastIndexOf(\".\") + 1), a = this.attr(name), atr = {};\n            eve.stop();\n            var unit = plus[3] || \"\", aUnit = a.match(reUnit), op = operators[plus[1]];\n            if (aUnit && aUnit == unit) {\n                val = op(parseFloat(a), +plus[2]);\n            } else {\n                a = this.asPX(name);\n                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n            }\n            if (isNaN(a) || isNaN(val)) {\n                return;\n            }\n            atr[name] = val;\n            this.attr(atr);\n        }\n    })(-10);\n    eve.on(\"snap.util.equal\", function(name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"), el = this, bplus = Str(b).match(reAddon);\n        if (bplus) {\n            eve.stop();\n            var unit = bplus[3] || \"\", aUnit = a.match(reUnit), op = operators[bplus[1]];\n            if (aUnit && aUnit == unit) {\n                return {\n                    from: parseFloat(a),\n                    to: op(parseFloat(a), +bplus[2]),\n                    f: getUnit(aUnit)\n                };\n            } else {\n                a = this.asPX(name);\n                return {\n                    from: a,\n                    to: op(a, this.asPX(name, bplus[2] + unit)),\n                    f: getNumber\n                };\n            }\n        }\n    })(-10);\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var proto = Paper.prototype, is = Snap.is;\n    /*\\\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - rx (number) #optional horizontal radius for rounded corners, default is 0\n     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n     = (object) the `rect` element\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n    \\*/ proto.rect = function(x, y, w, h, rx, ry) {\n        var attr;\n        if (ry == null) {\n            ry = rx;\n        }\n        if (is(x, \"object\") && x == \"[object Object]\") {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n            if (rx != null) {\n                attr.rx = rx;\n                attr.ry = ry;\n            }\n        }\n        return this.el(\"rect\", attr);\n    };\n    /*\\\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) the `circle` element\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n    \\*/ proto.circle = function(cx, cy, r) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                r: r\n            };\n        }\n        return this.el(\"circle\", attr);\n    };\n    var preload = function() {\n        function onerror() {\n            this.parentNode.removeChild(this);\n        }\n        return function(src, f) {\n            var img = glob.doc.createElement(\"img\"), body = glob.doc.body;\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n            img.onload = function() {\n                f.call(img);\n                img.onload = img.onerror = null;\n                body.removeChild(img);\n            };\n            img.onerror = onerror;\n            body.appendChild(img);\n            img.src = src;\n        };\n    }();\n    /*\\\n     * Paper.image\n     [ method ]\n     **\n     * Places an image on the surface\n     **\n     - src (string) URI of the source image\n     - x (number) x offset position\n     - y (number) y offset position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) the `image` element\n     * or\n     = (object) Snap element object with type `image`\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n    \\*/ proto.image = function(src, x, y, width, height) {\n        var el = this.el(\"image\");\n        if (is(src, \"object\") && \"src\" in src) {\n            el.attr(src);\n        } else if (src != null) {\n            var set = {\n                \"xlink:href\": src,\n                preserveAspectRatio: \"none\"\n            };\n            if (x != null && y != null) {\n                set.x = x;\n                set.y = y;\n            }\n            if (width != null && height != null) {\n                set.width = width;\n                set.height = height;\n            } else {\n                preload(src, function() {\n                    Snap._.$(el.node, {\n                        width: this.offsetWidth,\n                        height: this.offsetHeight\n                    });\n                });\n            }\n            Snap._.$(el.node, set);\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) the `ellipse` element\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n    \\*/ proto.ellipse = function(cx, cy, rx, ry) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                rx: rx,\n                ry: ry\n            };\n        }\n        return this.el(\"ellipse\", attr);\n    };\n    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n    /*\\\n     * Paper.path\n     [ method ]\n     **\n     * Creates a `<path>` element using the given string as the path's definition\n     - pathString (string) #optional path string in SVG format\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n     | \"M10,20L30,40\"\n     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n    \\*/ proto.path = function(d) {\n        var attr;\n        if (is(d, \"object\") && !is(d, \"array\")) {\n            attr = d;\n        } else if (d) {\n            attr = {\n                d: d\n            };\n        }\n        return this.el(\"path\", attr);\n    };\n    /*\\\n     * Paper.g\n     [ method ]\n     **\n     * Creates a group element\n     **\n     - varargs (…) #optional elements to nest within the group\n     = (object) the `g` element\n     **\n     > Usage\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g(c2, c1); // note that the order of elements is different\n     * or\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g();\n     | g.add(c2, c1);\n    \\*/ /*\\\n     * Paper.group\n     [ method ]\n     **\n     * See @Paper.g\n    \\*/ proto.group = proto.g = function(first) {\n        var attr, el = this.el(\"g\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.svg\n     [ method ]\n     **\n     * Creates a nested SVG element.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `svg` element\n     **\n    \\*/ proto.svg = function(x, y, width, height, vbx, vby, vbw, vbh) {\n        var attrs = {};\n        if (is(x, \"object\") && y == null) {\n            attrs = x;\n        } else {\n            if (x != null) {\n                attrs.x = x;\n            }\n            if (y != null) {\n                attrs.y = y;\n            }\n            if (width != null) {\n                attrs.width = width;\n            }\n            if (height != null) {\n                attrs.height = height;\n            }\n            if (vbx != null && vby != null && vbw != null && vbh != null) {\n                attrs.viewBox = [\n                    vbx,\n                    vby,\n                    vbw,\n                    vbh\n                ];\n            }\n        }\n        return this.el(\"svg\", attrs);\n    };\n    /*\\\n     * Paper.mask\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a mask.\n     **\n     = (object) the `mask` element\n     **\n    \\*/ proto.mask = function(first) {\n        var attr, el = this.el(\"mask\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ptrn\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except it’s a pattern.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `pattern` element\n     **\n    \\*/ proto.ptrn = function(x, y, width, height, vx, vy, vw, vh) {\n        if (is(x, \"object\")) {\n            var attr = x;\n        } else {\n            attr = {\n                patternUnits: \"userSpaceOnUse\"\n            };\n            if (x) {\n                attr.x = x;\n            }\n            if (y) {\n                attr.y = y;\n            }\n            if (width != null) {\n                attr.width = width;\n            }\n            if (height != null) {\n                attr.height = height;\n            }\n            if (vx != null && vy != null && vw != null && vh != null) {\n                attr.viewBox = [\n                    vx,\n                    vy,\n                    vw,\n                    vh\n                ];\n            } else {\n                attr.viewBox = [\n                    x || 0,\n                    y || 0,\n                    width || 0,\n                    height || 0\n                ];\n            }\n        }\n        return this.el(\"pattern\", attr);\n    };\n    /*\\\n     * Paper.use\n     [ method ]\n     **\n     * Creates a <use> element.\n     - id (string) @optional id of element to link\n     * or\n     - id (Element) @optional element to link\n     **\n     = (object) the `use` element\n     **\n    \\*/ proto.use = function(id) {\n        if (id != null) {\n            if (id instanceof Element) {\n                if (!id.attr(\"id\")) {\n                    id.attr({\n                        id: Snap._.id(id)\n                    });\n                }\n                id = id.attr(\"id\");\n            }\n            if (String(id).charAt() == \"#\") {\n                id = id.substring(1);\n            }\n            return this.el(\"use\", {\n                \"xlink:href\": \"#\" + id\n            });\n        } else {\n            return Element.prototype.use.call(this);\n        }\n    };\n    /*\\\n     * Paper.symbol\n     [ method ]\n     **\n     * Creates a <symbol> element.\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     = (object) the `symbol` element\n     **\n    \\*/ proto.symbol = function(vx, vy, vw, vh) {\n        var attr = {};\n        if (vx != null && vy != null && vw != null && vh != null) {\n            attr.viewBox = [\n                vx,\n                vy,\n                vw,\n                vh\n            ];\n        }\n        return this.el(\"symbol\", attr);\n    };\n    /*\\\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n     = (object) the `text` element\n     **\n     > Usage\n     | var t1 = paper.text(50, 50, \"Snap\");\n     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n     | // Text path usage\n     | t1.attr({textpath: \"M10,10L100,100\"});\n     | // or\n     | var pth = paper.path(\"M10,10L100,100\");\n     | t1.attr({textpath: pth});\n    \\*/ proto.text = function(x, y, text) {\n        var attr = {};\n        if (is(x, \"object\")) {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                text: text || \"\"\n            };\n        }\n        return this.el(\"text\", attr);\n    };\n    /*\\\n     * Paper.line\n     [ method ]\n     **\n     * Draws a line\n     **\n     - x1 (number) x coordinate position of the start\n     - y1 (number) y coordinate position of the start\n     - x2 (number) x coordinate position of the end\n     - y2 (number) y coordinate position of the end\n     = (object) the `line` element\n     **\n     > Usage\n     | var t1 = paper.line(50, 50, 100, 100);\n    \\*/ proto.line = function(x1, y1, x2, y2) {\n        var attr = {};\n        if (is(x1, \"object\")) {\n            attr = x1;\n        } else if (x1 != null) {\n            attr = {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        }\n        return this.el(\"line\", attr);\n    };\n    /*\\\n     * Paper.polyline\n     [ method ]\n     **\n     * Draws a polyline\n     **\n     - points (array) array of points\n     * or\n     - varargs (…) points\n     = (object) the `polyline` element\n     **\n     > Usage\n     | var p1 = paper.polyline([10, 10, 100, 100]);\n     | var p2 = paper.polyline(10, 10, 100, 100);\n    \\*/ proto.polyline = function(points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {\n                points: points\n            };\n        }\n        return this.el(\"polyline\", attr);\n    };\n    /*\\\n     * Paper.polygon\n     [ method ]\n     **\n     * Draws a polygon. See @Paper.polyline\n    \\*/ proto.polygon = function(points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {\n                points: points\n            };\n        }\n        return this.el(\"polygon\", attr);\n    };\n    // gradients\n    (function() {\n        var $ = Snap._.$;\n        // gradients' helpers\n        /*\\\n         * Element.stops\n         [ method ]\n         **\n         * Only for gradients!\n         * Returns array of gradient stops elements.\n         = (array) the stops array.\n        \\*/ function Gstops() {\n            return this.selectAll(\"stop\");\n        }\n        /*\\\n         * Element.addStop\n         [ method ]\n         **\n         * Only for gradients!\n         * Adds another stop to the gradient.\n         - color (string) stops color\n         - offset (number) stops offset 0..100\n         = (object) gradient element\n        \\*/ function GaddStop(color, offset) {\n            var stop = $(\"stop\"), attr = {\n                offset: +offset + \"%\"\n            };\n            color = Snap.color(color);\n            attr[\"stop-color\"] = color.hex;\n            if (color.opacity < 1) {\n                attr[\"stop-opacity\"] = color.opacity;\n            }\n            $(stop, attr);\n            var stops = this.stops(), inserted;\n            for(var i = 0; i < stops.length; i++){\n                var stopOffset = parseFloat(stops[i].attr(\"offset\"));\n                if (stopOffset > offset) {\n                    this.node.insertBefore(stop, stops[i].node);\n                    inserted = true;\n                    break;\n                }\n            }\n            if (!inserted) {\n                this.node.appendChild(stop);\n            }\n            return this;\n        }\n        function GgetBBox() {\n            if (this.type == \"linearGradient\") {\n                var x1 = $(this.node, \"x1\") || 0, x2 = $(this.node, \"x2\") || 1, y1 = $(this.node, \"y1\") || 0, y2 = $(this.node, \"y2\") || 0;\n                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n            } else {\n                var cx = this.node.cx || .5, cy = this.node.cy || .5, r = this.node.r || 0;\n                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n            }\n        }\n        /*\\\n         * Element.setStops\n         [ method ]\n         **\n         * Only for gradients!\n         * Updates stops of the gradient based on passed gradient descriptor. See @Ppaer.gradient\n         - str (string) gradient descriptor part after `()`.\n         = (object) gradient element\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         | g.setStops(\"#fff-#000-#f00-#fc0\");\n        \\*/ function GsetStops(str) {\n            var grad = str, stops = this.stops();\n            if (typeof str == \"string\") {\n                grad = eve(\"snap.util.grad.parse\", null, \"l(0,0,0,1)\" + str).firstDefined().stops;\n            }\n            if (!Snap.is(grad, \"array\")) {\n                return;\n            }\n            for(var i = 0; i < stops.length; i++){\n                if (grad[i]) {\n                    var color = Snap.color(grad[i].color), attr = {\n                        \"offset\": grad[i].offset + \"%\"\n                    };\n                    attr[\"stop-color\"] = color.hex;\n                    if (color.opacity < 1) {\n                        attr[\"stop-opacity\"] = color.opacity;\n                    }\n                    stops[i].attr(attr);\n                } else {\n                    stops[i].remove();\n                }\n            }\n            for(i = stops.length; i < grad.length; i++){\n                this.addStop(grad[i].color, grad[i].offset);\n            }\n            return this;\n        }\n        function gradient(defs, str) {\n            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(), el;\n            if (!grad) {\n                return null;\n            }\n            grad.params.unshift(defs);\n            if (grad.type.toLowerCase() == \"l\") {\n                el = gradientLinear.apply(0, grad.params);\n            } else {\n                el = gradientRadial.apply(0, grad.params);\n            }\n            if (grad.type != grad.type.toLowerCase()) {\n                $(el.node, {\n                    gradientUnits: \"userSpaceOnUse\"\n                });\n            }\n            var stops = grad.stops, len = stops.length;\n            for(var i = 0; i < len; i++){\n                var stop = stops[i];\n                el.addStop(stop.color, stop.offset);\n            }\n            return el;\n        }\n        function gradientLinear(defs, x1, y1, x2, y2) {\n            var el = Snap._.make(\"linearGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            el.setStops = GsetStops;\n            if (x1 != null) {\n                $(el.node, {\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2\n                });\n            }\n            return el;\n        }\n        function gradientRadial(defs, cx, cy, r, fx, fy) {\n            var el = Snap._.make(\"radialGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (cx != null) {\n                $(el.node, {\n                    cx: cx,\n                    cy: cy,\n                    r: r\n                });\n            }\n            if (fx != null && fy != null) {\n                $(el.node, {\n                    fx: fx,\n                    fy: fy\n                });\n            }\n            return el;\n        }\n        /*\\\n         * Paper.gradient\n         [ method ]\n         **\n         * Creates a gradient element\n         **\n         - gradient (string) gradient descriptor\n         > Gradient Descriptor\n         * The gradient descriptor is an expression formatted as\n         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n         * either linear or radial.  The uppercase `L` or `R` letters\n         * indicate absolute coordinates offset from the SVG surface.\n         * Lowercase `l` or `r` letters indicate coordinates\n         * calculated relative to the element to which the gradient is\n         * applied.  Coordinates specify a linear gradient vector as\n         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n         * `r` and optional `fx`, `fy` specifying a focal point away\n         * from the center of the circle. Specify `<colors>` as a list\n         * of dash-separated CSS color values.  Each color may be\n         * followed by a custom offset value, separated with a colon\n         * character.\n         > Examples\n         * Linear gradient, relative from top-left corner to bottom-right\n         * corner, from black through red to white:\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n         * through red at 25% to white:\n         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n         * Radial gradient, relative from the center of the element with radius\n         * half the width, from black to white:\n         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n         * To apply the gradient:\n         | paper.circle(50, 50, 40).attr({\n         |     fill: g\n         | });\n         = (object) the `gradient` element\n        \\*/ proto.gradient = function(str) {\n            return gradient(this.defs, str);\n        };\n        proto.gradientLinear = function(x1, y1, x2, y2) {\n            return gradientLinear(this.defs, x1, y1, x2, y2);\n        };\n        proto.gradientRadial = function(cx, cy, r, fx, fy) {\n            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n        };\n        /*\\\n         * Paper.toString\n         [ method ]\n         **\n         * Returns SVG code for the @Paper\n         = (string) SVG code for the @Paper\n        \\*/ proto.toString = function() {\n            var doc = this.node.ownerDocument, f = doc.createDocumentFragment(), d = doc.createElement(\"div\"), svg = this.node.cloneNode(true), res1;\n            f.appendChild(d);\n            d.appendChild(svg);\n            Snap._.$(svg, {\n                xmlns: \"http://www.w3.org/2000/svg\"\n            });\n            res1 = d.innerHTML;\n            f.removeChild(f.firstChild);\n            return res1;\n        };\n        /*\\\n         * Paper.toDataURL\n         [ method ]\n         **\n         * Returns SVG code for the @Paper as Data URI string.\n         = (string) Data URI string\n        \\*/ proto.toDataURL = function() {\n            if (window && window.btoa) {\n                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n            }\n        };\n        /*\\\n         * Paper.clear\n         [ method ]\n         **\n         * Removes all child nodes of the paper, except <defs>.\n        \\*/ proto.clear = function() {\n            var node = this.node.firstChild, next;\n            while(node){\n                next = node.nextSibling;\n                if (node.tagName != \"defs\") {\n                    node.parentNode.removeChild(node);\n                } else {\n                    proto.clear.call({\n                        node: node\n                    });\n                }\n                node = next;\n            }\n        };\n    })();\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob) {\n    var elproto = Element.prototype, is = Snap.is, clone = Snap._.clone, has = \"hasOwnProperty\", p2s = /,?([a-z]),?/gi, toFloat = parseFloat, math1 = Math, PI = math1.PI, mmin = math1.min, mmax = math1.max, pow = math1.pow, abs = math1.abs;\n    function paths(ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function() {\n            for(var key in p)if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }\n    function box(x, y, width, height) {\n        if (x == null) {\n            x = y = width = height = 0;\n        }\n        if (y == null) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            w: width,\n            height: height,\n            h: height,\n            x2: x + width,\n            y2: y + height,\n            cx: x + width / 2,\n            cy: y + height / 2,\n            r1: math1.min(width, height) / 2,\n            r2: math1.max(width, height) / 2,\n            r0: math1.sqrt(width * width + height * height) / 2,\n            path: rectPath(x, y, width, height),\n            vb: [\n                x,\n                y,\n                width,\n                height\n            ].join(\" \")\n        };\n    }\n    function toString() {\n        return this.join(\",\").replace(p2s, \"$1\");\n    }\n    function pathClone(pathArray) {\n        var res1 = clone(pathArray);\n        res1.toString = toString;\n        return res1;\n    }\n    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n        if (length == null) {\n            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n        } else {\n            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n        }\n    }\n    function getLengthFactory(istotal, subpath) {\n        function O(val) {\n            return +(+val).toFixed(3);\n        }\n        return Snap._.cacher(function(path, length, onlystart) {\n            if (path instanceof Element) {\n                path = path.attr(\"d\");\n            }\n            path = path2curve(path);\n            var x, y, p, l, sp = \"\", subpaths = {}, point, len = 0;\n            for(var i = 0, ii = path.length; i < ii; i++){\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = +p[1];\n                    y = +p[2];\n                } else {\n                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    if (len + l > length) {\n                        if (subpath && !subpaths.start) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            sp += [\n                                \"C\" + O(point.start.x),\n                                O(point.start.y),\n                                O(point.m.x),\n                                O(point.m.y),\n                                O(point.x),\n                                O(point.y)\n                            ];\n                            if (onlystart) {\n                                return sp;\n                            }\n                            subpaths.start = sp;\n                            sp = [\n                                \"M\" + O(point.x),\n                                O(point.y) + \"C\" + O(point.n.x),\n                                O(point.n.y),\n                                O(point.end.x),\n                                O(point.end.y),\n                                O(p[5]),\n                                O(p[6])\n                            ].join();\n                            len += l;\n                            x = +p[5];\n                            y = +p[6];\n                            continue;\n                        }\n                        if (!istotal && !subpath) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            return point;\n                        }\n                    }\n                    len += l;\n                    x = +p[5];\n                    y = +p[6];\n                }\n                sp += p.shift() + p;\n            }\n            subpaths.end = sp;\n            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n            return point;\n        }, null, Snap._.clone);\n    }\n    var getTotalLength = getLengthFactory(1), getPointAtLength = getLengthFactory(), getSubpathsAtLength = getLengthFactory(0, 1);\n    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t, t13 = pow(t1, 3), t12 = pow(t1, 2), t2 = t * t, t3 = t2 * t, x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x, y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y, mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x), my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y), nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x), ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y), ax = t1 * p1x + t * c1x, ay = t1 * p1y + t * c1y, cx = t1 * c2x + t * p2x, cy = t1 * c2y + t * p2y, alpha = 90 - math1.atan2(mx - nx, my - ny) * 180 / PI;\n        // (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {\n                x: mx,\n                y: my\n            },\n            n: {\n                x: nx,\n                y: ny\n            },\n            start: {\n                x: ax,\n                y: ay\n            },\n            end: {\n                x: cx,\n                y: cy\n            },\n            alpha: alpha\n        };\n    }\n    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!Snap.is(p1x, \"array\")) {\n            p1x = [\n                p1x,\n                p1y,\n                c1x,\n                c1y,\n                c2x,\n                c2y,\n                p2x,\n                p2y\n            ];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);\n    }\n    function isPointInsideBBox(bbox, x, y) {\n        return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n    }\n    function isBBoxIntersect(bbox1, bbox2) {\n        bbox1 = box(bbox1);\n        bbox2 = box(bbox2);\n        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    }\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4, t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2, n = 12, Tvalues = [\n            -.1252,\n            .1252,\n            -.3678,\n            .3678,\n            -.5873,\n            .5873,\n            -.7699,\n            .7699,\n            -.9041,\n            .9041,\n            -.9816,\n            .9816\n        ], Cvalues = [\n            0.2491,\n            0.2491,\n            0.2335,\n            0.2335,\n            0.2032,\n            0.2032,\n            0.1601,\n            0.1601,\n            0.1069,\n            0.1069,\n            0.0472,\n            0.0472\n        ], sum = 0;\n        for(var i = 0; i < n; i++){\n            var ct = z2 * Tvalues[i] + z2, xbase = base3(ct, x1, x2, x3, x4), ybase = base3(ct, y1, y2, y3, y4), comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math1.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1, step = t / 2, t2 = t - step, l, e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while(abs(l - ll) > e){\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator, py = ny / denominator, px2 = +px.toFixed(2), py2 = +py.toFixed(2);\n        if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {\n            return;\n        }\n        return {\n            x: px,\n            y: py\n        };\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = bezierBBox(bez1), bbox2 = bezierBBox(bez2);\n        if (!isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1), l2 = bezlen.apply(0, bez2), n1 = ~~(l1 / 8), n2 = ~~(l2 / 8), dots1 = [], dots2 = [], xy = {}, res1 = justCount ? 0 : [];\n        for(var i = 0; i < n1 + 1; i++){\n            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n            dots1.push({\n                x: p.x,\n                y: p.y,\n                t: i / n1\n            });\n        }\n        for(i = 0; i < n2 + 1; i++){\n            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n            dots2.push({\n                x: p.x,\n                y: p.y,\n                t: i / n2\n            });\n        }\n        for(i = 0; i < n1; i++){\n            for(var j = 0; j < n2; j++){\n                var di = dots1[i], di1 = dots1[i + 1], dj = dots2[j], dj1 = dots2[j + 1], ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\", cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\", is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n                        if (justCount) {\n                            res1++;\n                        } else {\n                            res1.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: t1,\n                                t2: t2\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res1;\n    }\n    function pathIntersection(path1, path2) {\n        return interPathHelper(path1, path2);\n    }\n    function pathIntersectionNumber(path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    }\n    function interPathHelper(path1, path2, justCount) {\n        path1 = path2curve(path1);\n        path2 = path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2, res1 = justCount ? 0 : [];\n        for(var i = 0, ii = path1.length; i < ii; i++){\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [\n                        x1,\n                        y1\n                    ].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [\n                        x1,\n                        y1,\n                        x1,\n                        y1,\n                        x1m,\n                        y1m,\n                        x1m,\n                        y1m\n                    ];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for(var j = 0, jj = path2.length; j < jj; j++){\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [\n                                x2,\n                                y2\n                            ].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [\n                                x2,\n                                y2,\n                                x2,\n                                y2,\n                                x2m,\n                                y2m,\n                                x2m,\n                                y2m\n                            ];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res1 += intr;\n                        } else {\n                            for(var k = 0, kk = intr.length; k < kk; k++){\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res1 = res1.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res1;\n    }\n    function isPointInsidePath(path, x, y) {\n        var bbox = pathBBox(path);\n        return isPointInsideBBox(bbox, x, y) && interPathHelper(path, [\n            [\n                \"M\",\n                x,\n                y\n            ],\n            [\n                \"H\",\n                bbox.x2 + 10\n            ]\n        ], 1) % 2 == 1;\n    }\n    function pathBBox(path) {\n        var pth = paths(path);\n        if (pth.bbox) {\n            return clone(pth.bbox);\n        }\n        if (!path) {\n            return box();\n        }\n        path = path2curve(path);\n        var x = 0, y = 0, X = [], Y = [], p;\n        for(var i = 0, ii = path.length; i < ii; i++){\n            p = path[i];\n            if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n            } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X.concat(dim.min.x, dim.max.x);\n                Y = Y.concat(dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n            }\n        }\n        var xmin = mmin.apply(0, X), ymin = mmin.apply(0, Y), xmax = mmax.apply(0, X), ymax = mmax.apply(0, Y), bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n        pth.bbox = clone(bb);\n        return bb;\n    }\n    function rectPath(x, y, w, h, r) {\n        if (r) {\n            return [\n                [\n                    \"M\",\n                    +x + +r,\n                    y\n                ],\n                [\n                    \"l\",\n                    w - r * 2,\n                    0\n                ],\n                [\n                    \"a\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    r,\n                    r\n                ],\n                [\n                    \"l\",\n                    0,\n                    h - r * 2\n                ],\n                [\n                    \"a\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    -r,\n                    r\n                ],\n                [\n                    \"l\",\n                    r * 2 - w,\n                    0\n                ],\n                [\n                    \"a\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    -r,\n                    -r\n                ],\n                [\n                    \"l\",\n                    0,\n                    r * 2 - h\n                ],\n                [\n                    \"a\",\n                    r,\n                    r,\n                    0,\n                    0,\n                    1,\n                    r,\n                    -r\n                ],\n                [\n                    \"z\"\n                ]\n            ];\n        }\n        var res1 = [\n            [\n                \"M\",\n                x,\n                y\n            ],\n            [\n                \"l\",\n                w,\n                0\n            ],\n            [\n                \"l\",\n                0,\n                h\n            ],\n            [\n                \"l\",\n                -w,\n                0\n            ],\n            [\n                \"z\"\n            ]\n        ];\n        res1.toString = toString;\n        return res1;\n    }\n    function ellipsePath(x, y, rx, ry, a) {\n        if (a == null && ry == null) {\n            ry = rx;\n        }\n        x = +x;\n        y = +y;\n        rx = +rx;\n        ry = +ry;\n        if (a != null) {\n            var rad = Math.PI / 180, x1 = x + rx * Math.cos(-ry * rad), x2 = x + rx * Math.cos(-a * rad), y1 = y + rx * Math.sin(-ry * rad), y2 = y + rx * Math.sin(-a * rad), res1 = [\n                [\n                    \"M\",\n                    x1,\n                    y1\n                ],\n                [\n                    \"A\",\n                    rx,\n                    rx,\n                    0,\n                    +(a - ry > 180),\n                    0,\n                    x2,\n                    y2\n                ]\n            ];\n        } else {\n            res1 = [\n                [\n                    \"M\",\n                    x,\n                    y\n                ],\n                [\n                    \"m\",\n                    0,\n                    -ry\n                ],\n                [\n                    \"a\",\n                    rx,\n                    ry,\n                    0,\n                    1,\n                    1,\n                    0,\n                    2 * ry\n                ],\n                [\n                    \"a\",\n                    rx,\n                    ry,\n                    0,\n                    1,\n                    1,\n                    0,\n                    -2 * ry\n                ],\n                [\n                    \"z\"\n                ]\n            ];\n        }\n        res1.toString = toString;\n        return res1;\n    }\n    var unit2px = Snap._unit2px, getPath = {\n        path: function(el) {\n            return el.attr(\"path\");\n        },\n        circle: function(el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx, attr.cy, attr.r);\n        },\n        ellipse: function(el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n        },\n        rect: function(el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n        },\n        image: function(el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n        },\n        line: function(el) {\n            return \"M\" + [\n                el.attr(\"x1\") || 0,\n                el.attr(\"y1\") || 0,\n                el.attr(\"x2\"),\n                el.attr(\"y2\")\n            ];\n        },\n        polyline: function(el) {\n            return \"M\" + el.attr(\"points\");\n        },\n        polygon: function(el) {\n            return \"M\" + el.attr(\"points\") + \"z\";\n        },\n        deflt: function(el) {\n            var bbox = el.node.getBBox();\n            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n        }\n    };\n    function pathToRelative(pathArray) {\n        var pth = paths(pathArray), lowerCase = String.prototype.toLowerCase;\n        if (pth.rel) {\n            return pathClone(pth.rel);\n        }\n        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        var res1 = [], x = 0, y = 0, mx = 0, my = 0, start = 0;\n        if (pathArray[0][0] == \"M\") {\n            x = pathArray[0][1];\n            y = pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res1.push([\n                \"M\",\n                x,\n                y\n            ]);\n        }\n        for(var i = start, ii = pathArray.length; i < ii; i++){\n            var r = res1[i] = [], pa = pathArray[i];\n            if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n                switch(r[0]){\n                    case \"a\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +(pa[6] - x).toFixed(3);\n                        r[7] = +(pa[7] - y).toFixed(3);\n                        break;\n                    case \"v\":\n                        r[1] = +(pa[1] - y).toFixed(3);\n                        break;\n                    case \"m\":\n                        mx = pa[1];\n                        my = pa[2];\n                    default:\n                        for(var j = 1, jj = pa.length; j < jj; j++){\n                            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);\n                        }\n                }\n            } else {\n                r = res1[i] = [];\n                if (pa[0] == \"m\") {\n                    mx = pa[1] + x;\n                    my = pa[2] + y;\n                }\n                for(var k = 0, kk = pa.length; k < kk; k++){\n                    res1[i][k] = pa[k];\n                }\n            }\n            var len = res1[i].length;\n            switch(res1[i][0]){\n                case \"z\":\n                    x = mx;\n                    y = my;\n                    break;\n                case \"h\":\n                    x += +res1[i][len - 1];\n                    break;\n                case \"v\":\n                    y += +res1[i][len - 1];\n                    break;\n                default:\n                    x += +res1[i][len - 2];\n                    y += +res1[i][len - 1];\n            }\n        }\n        res1.toString = toString;\n        pth.rel = pathClone(res1);\n        return res1;\n    }\n    function pathToAbsolute(pathArray) {\n        var pth = paths(pathArray);\n        if (pth.abs) {\n            return pathClone(pth.abs);\n        }\n        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        if (!pathArray || !pathArray.length) {\n            return [\n                [\n                    \"M\",\n                    0,\n                    0\n                ]\n            ];\n        }\n        var res1 = [], x = 0, y = 0, mx = 0, my = 0, start = 0, pa0;\n        if (pathArray[0][0] == \"M\") {\n            x = +pathArray[0][1];\n            y = +pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res1[0] = [\n                \"M\",\n                x,\n                y\n            ];\n        }\n        var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n        for(var r, pa, i = start, ii = pathArray.length; i < ii; i++){\n            res1.push(r = []);\n            pa = pathArray[i];\n            pa0 = pa[0];\n            if (pa0 != pa0.toUpperCase()) {\n                r[0] = pa0.toUpperCase();\n                switch(r[0]){\n                    case \"A\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +pa[6] + x;\n                        r[7] = +pa[7] + y;\n                        break;\n                    case \"V\":\n                        r[1] = +pa[1] + y;\n                        break;\n                    case \"H\":\n                        r[1] = +pa[1] + x;\n                        break;\n                    case \"R\":\n                        var dots = [\n                            x,\n                            y\n                        ].concat(pa.slice(1));\n                        for(var j = 2, jj = dots.length; j < jj; j++){\n                            dots[j] = +dots[j] + x;\n                            dots[++j] = +dots[j] + y;\n                        }\n                        res1.pop();\n                        res1 = res1.concat(catmullRom2bezier(dots, crz));\n                        break;\n                    case \"O\":\n                        res1.pop();\n                        dots = ellipsePath(x, y, pa[1], pa[2]);\n                        dots.push(dots[0]);\n                        res1 = res1.concat(dots);\n                        break;\n                    case \"U\":\n                        res1.pop();\n                        res1 = res1.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                        r = [\n                            \"U\"\n                        ].concat(res1[res1.length - 1].slice(-2));\n                        break;\n                    case \"M\":\n                        mx = +pa[1] + x;\n                        my = +pa[2] + y;\n                    default:\n                        for(j = 1, jj = pa.length; j < jj; j++){\n                            r[j] = +pa[j] + (j % 2 ? x : y);\n                        }\n                }\n            } else if (pa0 == \"R\") {\n                dots = [\n                    x,\n                    y\n                ].concat(pa.slice(1));\n                res1.pop();\n                res1 = res1.concat(catmullRom2bezier(dots, crz));\n                r = [\n                    \"R\"\n                ].concat(pa.slice(-2));\n            } else if (pa0 == \"O\") {\n                res1.pop();\n                dots = ellipsePath(x, y, pa[1], pa[2]);\n                dots.push(dots[0]);\n                res1 = res1.concat(dots);\n            } else if (pa0 == \"U\") {\n                res1.pop();\n                res1 = res1.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                r = [\n                    \"U\"\n                ].concat(res1[res1.length - 1].slice(-2));\n            } else {\n                for(var k = 0, kk = pa.length; k < kk; k++){\n                    r[k] = pa[k];\n                }\n            }\n            pa0 = pa0.toUpperCase();\n            if (pa0 != \"O\") {\n                switch(r[0]){\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n        }\n        res1.toString = toString;\n        pth.abs = pathClone(res1);\n        return res1;\n    }\n    function l2c(x1, y1, x2, y2) {\n        return [\n            x1,\n            y1,\n            x2,\n            y2,\n            x2,\n            y2\n        ];\n    }\n    function q2c(x1, y1, ax, ay, x2, y2) {\n        var _13 = 1 / 3, _23 = 2 / 3;\n        return [\n            _13 * x1 + _23 * ax,\n            _13 * y1 + _23 * ay,\n            _13 * x2 + _23 * ax,\n            _13 * y2 + _23 * ay,\n            x2,\n            y2\n        ];\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n        // for more information of where this math came from visit:\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        var _120 = PI * 120 / 180, rad = PI / 180 * (+angle || 0), res1 = [], xy, rotate = Snap._.cacher(function(x, y, rad) {\n            var X = x * math1.cos(rad) - y * math1.sin(rad), Y = x * math1.sin(rad) + y * math1.cos(rad);\n            return {\n                x: X,\n                y: Y\n            };\n        });\n        if (!rx || !ry) {\n            return [\n                x1,\n                y1,\n                x2,\n                y2,\n                x2,\n                y2\n            ];\n        }\n        if (!recursive) {\n            xy = rotate(x1, y1, -rad);\n            x1 = xy.x;\n            y1 = xy.y;\n            xy = rotate(x2, y2, -rad);\n            x2 = xy.x;\n            y2 = xy.y;\n            var cos = math1.cos(PI / 180 * angle), sin = math1.sin(PI / 180 * angle), x = (x1 - x2) / 2, y = (y1 - y2) / 2;\n            var h = x * x / (rx * rx) + y * y / (ry * ry);\n            if (h > 1) {\n                h = math1.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n            }\n            var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -1 : 1) * math1.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / 2, cy = k * -ry * x / rx + (y1 + y2) / 2, f1 = math1.asin(((y1 - cy) / ry).toFixed(9)), f2 = math1.asin(((y2 - cy) / ry).toFixed(9));\n            f1 = x1 < cx ? PI - f1 : f1;\n            f2 = x2 < cx ? PI - f2 : f2;\n            f1 < 0 && (f1 = PI * 2 + f1);\n            f2 < 0 && (f2 = PI * 2 + f2);\n            if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n            }\n            if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n            }\n        } else {\n            f1 = recursive[0];\n            f2 = recursive[1];\n            cx = recursive[2];\n            cy = recursive[3];\n        }\n        var df = f2 - f1;\n        if (abs(df) > _120) {\n            var f2old = f2, x2old = x2, y2old = y2;\n            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n            x2 = cx + rx * math1.cos(f2);\n            y2 = cy + ry * math1.sin(f2);\n            res1 = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n                f2,\n                f2old,\n                cx,\n                cy\n            ]);\n        }\n        df = f2 - f1;\n        var c1 = math1.cos(f1), s1 = math1.sin(f1), c2 = math1.cos(f2), s2 = math1.sin(f2), t = math1.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m1 = [\n            x1,\n            y1\n        ], m2 = [\n            x1 + hx * s1,\n            y1 - hy * c1\n        ], m3 = [\n            x2 + hx * s2,\n            y2 - hy * c2\n        ], m4 = [\n            x2,\n            y2\n        ];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (recursive) {\n            return [\n                m2,\n                m3,\n                m4\n            ].concat(res1);\n        } else {\n            res1 = [\n                m2,\n                m3,\n                m4\n            ].concat(res1).join().split(\",\");\n            var newres = [];\n            for(var i = 0, ii = res1.length; i < ii; i++){\n                newres[i] = i % 2 ? rotate(res1[i - 1], res1[i], rad).y : rotate(res1[i], res1[i + 1], rad).x;\n            }\n            return newres;\n        }\n    }\n    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t;\n        return {\n            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n        };\n    }\n    // Returns bounding box of cubic bezier curve.\n    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // Original version: NISHIO Hirokazu\n    // Modifications: https://github.com/timo22345\n    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var tvalues = [], bounds = [\n            [],\n            []\n        ], a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        for(var i = 0; i < 2; ++i){\n            if (i == 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = math1.sqrt(b2ac);\n            if (b2ac < 0) {\n                continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n        var x, y, j = tvalues.length, jlen = j, mt;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        bounds[0].length = bounds[1].length = jlen + 2;\n        return {\n            min: {\n                x: mmin.apply(0, bounds[0]),\n                y: mmin.apply(0, bounds[1])\n            },\n            max: {\n                x: mmax.apply(0, bounds[0]),\n                y: mmax.apply(0, bounds[1])\n            }\n        };\n    }\n    function path2curve(path, path2) {\n        var pth = !path2 && paths(path);\n        if (!path2 && pth.curve) {\n            return pathClone(pth.curve);\n        }\n        var p = pathToAbsolute(path), p2 = path2 && pathToAbsolute(path2), attrs = {\n            x: 0,\n            y: 0,\n            bx: 0,\n            by: 0,\n            X: 0,\n            Y: 0,\n            qx: null,\n            qy: null\n        }, attrs2 = {\n            x: 0,\n            y: 0,\n            bx: 0,\n            by: 0,\n            X: 0,\n            Y: 0,\n            qx: null,\n            qy: null\n        }, processPath = function(path, d, pcom) {\n            var nx, ny;\n            if (!path) {\n                return [\n                    \"C\",\n                    d.x,\n                    d.y,\n                    d.x,\n                    d.y,\n                    d.x,\n                    d.y\n                ];\n            }\n            !(path[0] in {\n                T: 1,\n                Q: 1\n            }) && (d.qx = d.qy = null);\n            switch(path[0]){\n                case \"M\":\n                    d.X = path[1];\n                    d.Y = path[2];\n                    break;\n                case \"A\":\n                    path = [\n                        \"C\"\n                    ].concat(a2c.apply(0, [\n                        d.x,\n                        d.y\n                    ].concat(path.slice(1))));\n                    break;\n                case \"S\":\n                    if (pcom == \"C\" || pcom == \"S\") {\n                        nx = d.x * 2 - d.bx; // And reflect the previous\n                        ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                    } else {\n                        nx = d.x;\n                        ny = d.y;\n                    }\n                    path = [\n                        \"C\",\n                        nx,\n                        ny\n                    ].concat(path.slice(1));\n                    break;\n                case \"T\":\n                    if (pcom == \"Q\" || pcom == \"T\") {\n                        d.qx = d.x * 2 - d.qx; // And make a reflection similar\n                        d.qy = d.y * 2 - d.qy; // to case \"S\".\n                    } else {\n                        d.qx = d.x;\n                        d.qy = d.y;\n                    }\n                    path = [\n                        \"C\"\n                    ].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                    break;\n                case \"Q\":\n                    d.qx = path[1];\n                    d.qy = path[2];\n                    path = [\n                        \"C\"\n                    ].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                    break;\n                case \"L\":\n                    path = [\n                        \"C\"\n                    ].concat(l2c(d.x, d.y, path[1], path[2]));\n                    break;\n                case \"H\":\n                    path = [\n                        \"C\"\n                    ].concat(l2c(d.x, d.y, path[1], d.y));\n                    break;\n                case \"V\":\n                    path = [\n                        \"C\"\n                    ].concat(l2c(d.x, d.y, d.x, path[1]));\n                    break;\n                case \"Z\":\n                    path = [\n                        \"C\"\n                    ].concat(l2c(d.x, d.y, d.X, d.Y));\n                    break;\n            }\n            return path;\n        }, fixArc = function(pp, i) {\n            if (pp[i].length > 7) {\n                pp[i].shift();\n                var pi = pp[i];\n                while(pi.length){\n                    pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                    p2 && (pcoms2[i] = \"A\"); // the same as above\n                    pp.splice(i++, 0, [\n                        \"C\"\n                    ].concat(pi.splice(0, 6)));\n                }\n                pp.splice(i, 1);\n                ii = mmax(p.length, p2 && p2.length || 0);\n            }\n        }, fixM = function(path1, path2, a1, a2, i) {\n            if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                path2.splice(i, 0, [\n                    \"M\",\n                    a2.x,\n                    a2.y\n                ]);\n                a1.bx = 0;\n                a1.by = 0;\n                a1.x = path1[i][1];\n                a1.y = path1[i][2];\n                ii = mmax(p.length, p2 && p2.length || 0);\n            }\n        }, pcoms1 = [], pcoms2 = [], pfirst = \"\", pcom = \"\"; // holder for previous path command of original path\n        for(var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++){\n            p[i] && (pfirst = p[i][0]); // save current path command\n            if (pfirst != \"C\") {\n                pcoms1[i] = pfirst; // Save current path command\n                i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n            }\n            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n            // which may produce multiple C:s\n            // so we have to make sure that C is also C in original path\n            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n            if (p2) {\n                p2[i] && (pfirst = p2[i][0]);\n                if (pfirst != \"C\") {\n                    pcoms2[i] = pfirst;\n                    i && (pcom = pcoms2[i - 1]);\n                }\n                p2[i] = processPath(p2[i], attrs2, pcom);\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                    pcoms2[i] = \"C\";\n                }\n                fixArc(p2, i);\n            }\n            fixM(p, p2, attrs, attrs2, i);\n            fixM(p2, p, attrs2, attrs, i);\n            var seg = p[i], seg2 = p2 && p2[i], seglen = seg.length, seg2len = p2 && seg2.length;\n            attrs.x = seg[seglen - 2];\n            attrs.y = seg[seglen - 1];\n            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n            attrs2.x = p2 && seg2[seg2len - 2];\n            attrs2.y = p2 && seg2[seg2len - 1];\n        }\n        if (!p2) {\n            pth.curve = pathClone(p);\n        }\n        return p2 ? [\n            p,\n            p2\n        ] : p;\n    }\n    function mapPath(path, matrix) {\n        if (!matrix) {\n            return path;\n        }\n        var x, y, i, j, ii, jj, pathi;\n        path = path2curve(path);\n        for(i = 0, ii = path.length; i < ii; i++){\n            pathi = path[i];\n            for(j = 1, jj = pathi.length; j < jj; j += 2){\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n            }\n        }\n        return path;\n    }\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for(var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2){\n            var p = [\n                {\n                    x: +crp[i - 2],\n                    y: +crp[i - 1]\n                },\n                {\n                    x: +crp[i],\n                    y: +crp[i + 1]\n                },\n                {\n                    x: +crp[i + 2],\n                    y: +crp[i + 3]\n                },\n                {\n                    x: +crp[i + 4],\n                    y: +crp[i + 5]\n                }\n            ];\n            if (z) {\n                if (!i) {\n                    p[0] = {\n                        x: +crp[iLen - 2],\n                        y: +crp[iLen - 1]\n                    };\n                } else if (iLen - 4 == i) {\n                    p[3] = {\n                        x: +crp[0],\n                        y: +crp[1]\n                    };\n                } else if (iLen - 2 == i) {\n                    p[2] = {\n                        x: +crp[0],\n                        y: +crp[1]\n                    };\n                    p[3] = {\n                        x: +crp[2],\n                        y: +crp[3]\n                    };\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {\n                        x: +crp[i],\n                        y: +crp[i + 1]\n                    };\n                }\n            }\n            d.push([\n                \"C\",\n                (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                (p[1].y + 6 * p[2].y - p[3].y) / 6,\n                p[2].x,\n                p[2].y\n            ]);\n        }\n        return d;\n    }\n    // export\n    Snap.path = paths;\n    /*\\\n     * Snap.path.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the given path in pixels\n     **\n     - path (string) SVG path string\n     **\n     = (number) length\n    \\*/ Snap.path.getTotalLength = getTotalLength;\n    /*\\\n     * Snap.path.getPointAtLength\n     [ method ]\n     **\n     * Returns the coordinates of the point located at the given length along the given path\n     **\n     - path (string) SVG path string\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/ Snap.path.getPointAtLength = getPointAtLength;\n    /*\\\n     * Snap.path.getSubpath\n     [ method ]\n     **\n     * Returns the subpath of a given path between given start and end lengths\n     **\n     - path (string) SVG path string\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/ Snap.path.getSubpath = function(path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*\\\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the path in pixels (only works for `path` elements)\n     = (number) length\n    \\*/ elproto.getTotalLength = function() {\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n    };\n    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n    /*\\\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n     **\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/ elproto.getPointAtLength = function(length) {\n        return getPointAtLength(this.attr(\"d\"), length);\n    };\n    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n    /*\\\n     * Element.getSubpath\n     [ method ]\n     **\n     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n     **\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/ elproto.getSubpath = function(from, to) {\n        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n    };\n    Snap._.box = box;\n    /*\\\n     * Snap.path.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds dot coordinates on the given cubic beziér curve at the given t\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point,\n     o     y: (number) y coordinate of the point,\n     o     m: {\n     o         x: (number) x coordinate of the left anchor,\n     o         y: (number) y coordinate of the left anchor\n     o     },\n     o     n: {\n     o         x: (number) x coordinate of the right anchor,\n     o         y: (number) y coordinate of the right anchor\n     o     },\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve,\n     o         y: (number) y coordinate of the start of the curve\n     o     },\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve,\n     o         y: (number) y coordinate of the end of the curve\n     o     },\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n    \\*/ Snap.path.findDotsAtSegment = findDotsAtSegment;\n    /*\\\n     * Snap.path.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given cubic beziér curve\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for beziér curve\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/ Snap.path.bezierBBox = bezierBBox;\n    /*\\\n     * Snap.path.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding box\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point is inside\n    \\*/ Snap.path.isPointInsideBBox = isPointInsideBBox;\n    Snap.closest = function(x, y, X, Y) {\n        var r = 100, b = box(x - r / 2, y - r / 2, r, r), inside = [], getter = X[0].hasOwnProperty(\"x\") ? function(i) {\n            return {\n                x: X[i].x,\n                y: X[i].y\n            };\n        } : function(i) {\n            return {\n                x: X[i],\n                y: Y[i]\n            };\n        }, found = 0;\n        while(r <= 1e6 && !found){\n            for(var i = 0, ii = X.length; i < ii; i++){\n                var xy = getter(i);\n                if (isPointInsideBBox(b, xy.x, xy.y)) {\n                    found++;\n                    inside.push(xy);\n                    break;\n                }\n            }\n            if (!found) {\n                r *= 2;\n                b = box(x - r / 2, y - r / 2, r, r);\n            }\n        }\n        if (r == 1e6) {\n            return;\n        }\n        var len = Infinity, res1;\n        for(i = 0, ii = inside.length; i < ii; i++){\n            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n            if (len > l) {\n                len = l;\n                inside[i].len = l;\n                res1 = inside[i];\n            }\n        }\n        return res1;\n    };\n    /*\\\n     * Snap.path.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if bounding boxes intersect\n    \\*/ Snap.path.isBBoxIntersect = isBBoxIntersect;\n    /*\\\n     * Snap.path.intersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point,\n     o         y: (number) y coordinate of the point,\n     o         t1: (number) t value for segment of path1,\n     o         t2: (number) t value for segment of path2,\n     o         segment1: (number) order number for segment of path1,\n     o         segment2: (number) order number for segment of path2,\n     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,\n     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\n     o     }\n     o ]\n    \\*/ Snap.path.intersection = pathIntersection;\n    Snap.path.intersectionNumber = pathIntersectionNumber;\n    /*\\\n     * Snap.path.isPointInside\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     *\n     * Note: fill mode doesn’t affect the result of this method.\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) `true` if point is inside the path\n    \\*/ Snap.path.isPointInside = isPointInsidePath;\n    /*\\\n     * Snap.path.getBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given path\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/ Snap.path.getBBox = pathBBox;\n    Snap.path.get = getPath;\n    /*\\\n     * Snap.path.toRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into relative values\n     - path (string) path string\n     = (array) path string\n    \\*/ Snap.path.toRelative = pathToRelative;\n    /*\\\n     * Snap.path.toAbsolute\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into absolute values\n     - path (string) path string\n     = (array) path string\n    \\*/ Snap.path.toAbsolute = pathToAbsolute;\n    /*\\\n     * Snap.path.toCubic\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic beziér curves\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments\n    \\*/ Snap.path.toCubic = path2curve;\n    /*\\\n     * Snap.path.map\n     [ method ]\n     **\n     * Transform the path string with the given matrix\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n    \\*/ Snap.path.map = mapPath;\n    Snap.path.toString = toString;\n    Snap.path.clone = pathClone;\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob) {\n    var mmax = Math.max, mmin = Math.min;\n    // Set\n    var Set = function(items) {\n        this.items = [];\n        this.bindings = {};\n        this.length = 0;\n        this.type = \"set\";\n        if (items) {\n            for(var i = 0, ii = items.length; i < ii; i++){\n                if (items[i]) {\n                    this[this.items.length] = this.items[this.items.length] = items[i];\n                    this.length++;\n                }\n            }\n        }\n    }, setproto = Set.prototype;\n    /*\\\n     * Set.push\n     [ method ]\n     **\n     * Adds each argument to the current set\n     = (object) original element\n    \\*/ setproto.push = function() {\n        var item, len;\n        for(var i = 0, ii = arguments.length; i < ii; i++){\n            item = arguments[i];\n            if (item) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.pop\n     [ method ]\n     **\n     * Removes last element and returns it\n     = (object) element\n    \\*/ setproto.pop = function() {\n        this.length && delete this[this.length--];\n        return this.items.pop();\n    };\n    /*\\\n     * Set.forEach\n     [ method ]\n     **\n     * Executes given function for each element in the set\n     *\n     * If the function returns `false`, the loop stops running.\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Set object\n    \\*/ setproto.forEach = function(callback, thisArg) {\n        for(var i = 0, ii = this.items.length; i < ii; i++){\n            if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.animate\n     [ method ]\n     **\n     * Animates each element in set in sync.\n     *\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     * or\n     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n     > Usage\n     | // animate all elements in set to radius 10\n     | set.animate({r: 10}, 500, mina.easein);\n     | // or\n     | // animate first element to radius 10, but second to radius 20 and in different time\n     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n     = (Element) the current element\n    \\*/ setproto.animate = function(attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Snap._.Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var args = arguments;\n        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n            var each = true;\n        }\n        var begin, handler = function() {\n            if (begin) {\n                this.b = begin;\n            } else {\n                begin = this.b;\n            }\n        }, cb = 0, set = this, callbacker = callback && function() {\n            if (++cb == set.length) {\n                callback.call(this);\n            }\n        };\n        return this.forEach(function(el, i) {\n            eve.once(\"snap.animcreated.\" + el.id, handler);\n            if (each) {\n                args[i] && el.animate.apply(el, args[i]);\n            } else {\n                el.animate(attrs, ms, easing, callbacker);\n            }\n        });\n    };\n    /*\\\n     * Set.remove\n     [ method ]\n     **\n     * Removes all children of the set.\n     *\n     = (object) Set object\n    \\*/ setproto.remove = function() {\n        while(this.length){\n            this.pop().remove();\n        }\n        return this;\n    };\n    /*\\\n     * Set.bind\n     [ method ]\n     **\n     * Specifies how to handle a specific attribute when applied\n     * to a set.\n     *\n     **\n     - attr (string) attribute name\n     - callback (function) function to run\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     - eattr (string) attribute on the element to bind the attribute to\n     = (object) Set object\n    \\*/ setproto.bind = function(attr, a, b) {\n        var data = {};\n        if (typeof a == \"function\") {\n            this.bindings[attr] = a;\n        } else {\n            var aname = b || attr;\n            this.bindings[attr] = function(v) {\n                data[aname] = v;\n                a.attr(data);\n            };\n        }\n        return this;\n    };\n    /*\\\n     * Set.attr\n     [ method ]\n     **\n     * Equivalent of @Element.attr.\n     = (object) Set object\n    \\*/ setproto.attr = function(value) {\n        var unbound = {};\n        for(var k in value){\n            if (this.bindings[k]) {\n                this.bindings[k](value[k]);\n            } else {\n                unbound[k] = value[k];\n            }\n        }\n        for(var i = 0, ii = this.items.length; i < ii; i++){\n            this.items[i].attr(unbound);\n        }\n        return this;\n    };\n    /*\\\n     * Set.clear\n     [ method ]\n     **\n     * Removes all elements from the set\n    \\*/ setproto.clear = function() {\n        while(this.length){\n            this.pop();\n        }\n    };\n    /*\\\n     * Set.splice\n     [ method ]\n     **\n     * Removes range of elements from the set\n     **\n     - index (number) position of the deletion\n     - count (number) number of element to remove\n     - insertion… (object) #optional elements to insert\n     = (object) set elements that were deleted\n    \\*/ setproto.splice = function(index, count, insertion) {\n        index = index < 0 ? mmax(this.length + index, 0) : index;\n        count = mmax(0, mmin(this.length - index, count));\n        var tail = [], todel = [], args = [], i;\n        for(i = 2; i < arguments.length; i++){\n            args.push(arguments[i]);\n        }\n        for(i = 0; i < count; i++){\n            todel.push(this[index + i]);\n        }\n        for(; i < this.length - index; i++){\n            tail.push(this[index + i]);\n        }\n        var arglen = args.length;\n        for(i = 0; i < arglen + tail.length; i++){\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n        }\n        i = this.items.length = this.length -= count - arglen;\n        while(this[i]){\n            delete this[i++];\n        }\n        return new Set(todel);\n    };\n    /*\\\n     * Set.exclude\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     - element (object) element to remove\n     = (boolean) `true` if object was found and removed from the set\n    \\*/ setproto.exclude = function(el) {\n        for(var i = 0, ii = this.length; i < ii; i++)if (this[i] == el) {\n            this.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n    /*\\\n     * Set.insertAfter\n     [ method ]\n     **\n     * Inserts set elements after given element.\n     **\n     - element (object) set will be inserted after this element\n     = (object) Set object\n    \\*/ setproto.insertAfter = function(el) {\n        var i = this.items.length;\n        while(i--){\n            this.items[i].insertAfter(el);\n        }\n        return this;\n    };\n    /*\\\n     * Set.getBBox\n     [ method ]\n     **\n     * Union of all bboxes of the set. See @Element.getBBox.\n     = (object) bounding box descriptor. See @Element.getBBox.\n    \\*/ setproto.getBBox = function() {\n        var x = [], y = [], x2 = [], y2 = [];\n        for(var i = this.items.length; i--;)if (!this.items[i].removed) {\n            var box = this.items[i].getBBox();\n            x.push(box.x);\n            y.push(box.y);\n            x2.push(box.x + box.width);\n            y2.push(box.y + box.height);\n        }\n        x = mmin.apply(0, x);\n        y = mmin.apply(0, y);\n        x2 = mmax.apply(0, x2);\n        y2 = mmax.apply(0, y2);\n        return {\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2,\n            width: x2 - x,\n            height: y2 - y,\n            cx: x + (x2 - x) / 2,\n            cy: y + (y2 - y) / 2\n        };\n    };\n    /*\\\n     * Set.insertAfter\n     [ method ]\n     **\n     * Creates a clone of the set.\n     **\n     = (object) New Set object\n    \\*/ setproto.clone = function(s) {\n        s = new Set;\n        for(var i = 0, ii = this.items.length; i < ii; i++){\n            s.push(this.items[i].clone());\n        }\n        return s;\n    };\n    setproto.toString = function() {\n        return \"Snap‘s set\";\n    };\n    setproto.type = \"set\";\n    // export\n    /*\\\n     * Snap.Set\n     [ property ]\n     **\n     * Set constructor.\n    \\*/ Snap.Set = Set;\n    /*\\\n     * Snap.set\n     [ method ]\n     **\n     * Creates a set and fills it with list of arguments.\n     **\n     = (object) New Set object\n     | var r = paper.rect(0, 0, 10, 10),\n     |     s1 = Snap.set(), // empty set\n     |     s2 = Snap.set(r, paper.circle(100, 100, 20)); // prefilled set\n    \\*/ Snap.set = function() {\n        var set = new Set;\n        if (arguments.length) {\n            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n        }\n        return set;\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob) {\n    var names = {}, reUnit = /[%a-z]+$/i, Str = String;\n    names.stroke = names.fill = \"colour\";\n    function getEmpty(item) {\n        var l = item[0];\n        switch(l.toLowerCase()){\n            case \"t\":\n                return [\n                    l,\n                    0,\n                    0\n                ];\n            case \"m\":\n                return [\n                    l,\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n            case \"r\":\n                if (item.length == 4) {\n                    return [\n                        l,\n                        0,\n                        item[2],\n                        item[3]\n                    ];\n                } else {\n                    return [\n                        l,\n                        0\n                    ];\n                }\n            case \"s\":\n                if (item.length == 5) {\n                    return [\n                        l,\n                        1,\n                        1,\n                        item[3],\n                        item[4]\n                    ];\n                } else if (item.length == 3) {\n                    return [\n                        l,\n                        1,\n                        1\n                    ];\n                } else {\n                    return [\n                        l,\n                        1\n                    ];\n                }\n        }\n    }\n    function equaliseTransform(t1, t2, getBBox) {\n        t1 = t1 || new Snap.Matrix;\n        t2 = t2 || new Snap.Matrix;\n        t1 = Snap.parseTransformString(t1.toTransformString()) || [];\n        t2 = Snap.parseTransformString(t2.toTransformString()) || [];\n        var maxlength = Math.max(t1.length, t2.length), from = [], to = [], i = 0, j, jj, tt1, tt2;\n        for(; i < maxlength; i++){\n            tt1 = t1[i] || getEmpty(t2[i]);\n            tt2 = t2[i] || getEmpty(tt1);\n            if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {\n                t1 = Snap._.transform2matrix(t1, getBBox());\n                t2 = Snap._.transform2matrix(t2, getBBox());\n                from = [\n                    [\n                        \"m\",\n                        t1.a,\n                        t1.b,\n                        t1.c,\n                        t1.d,\n                        t1.e,\n                        t1.f\n                    ]\n                ];\n                to = [\n                    [\n                        \"m\",\n                        t2.a,\n                        t2.b,\n                        t2.c,\n                        t2.d,\n                        t2.e,\n                        t2.f\n                    ]\n                ];\n                break;\n            }\n            from[i] = [];\n            to[i] = [];\n            for(j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++){\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n            }\n        }\n        return {\n            from: path2array(from),\n            to: path2array(to),\n            f: getPath(from)\n        };\n    }\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function(val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    function getViewBox(val) {\n        return val.join(\" \");\n    }\n    function getColour(clr) {\n        return Snap.rgb(clr[0], clr[1], clr[2], clr[3]);\n    }\n    function getPath(path) {\n        var k = 0, i, ii, j, jj, out, a, b = [];\n        for(i = 0, ii = path.length; i < ii; i++){\n            out = \"[\";\n            a = [\n                '\"' + path[i][0] + '\"'\n            ];\n            for(j = 1, jj = path[i].length; j < jj; j++){\n                a[j] = \"val[\" + k++ + \"]\";\n            }\n            out += a + \"]\";\n            b[i] = out;\n        }\n        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n    }\n    function path2array(path) {\n        var out = [];\n        for(var i = 0, ii = path.length; i < ii; i++){\n            for(var j = 1, jj = path[i].length; j < jj; j++){\n                out.push(path[i][j]);\n            }\n        }\n        return out;\n    }\n    function isNumeric(obj) {\n        return isFinite(obj);\n    }\n    function arrayEqual(arr1, arr2) {\n        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n            return false;\n        }\n        return arr1.toString() == arr2.toString();\n    }\n    Element.prototype.equal = function(name, b) {\n        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n    };\n    eve.on(\"snap.util.equal\", function(name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"), el = this;\n        if (names[name] == \"colour\") {\n            A = Snap.color(a);\n            B = Snap.color(b);\n            return {\n                from: [\n                    A.r,\n                    A.g,\n                    A.b,\n                    A.opacity\n                ],\n                to: [\n                    B.r,\n                    B.g,\n                    B.b,\n                    B.opacity\n                ],\n                f: getColour\n            };\n        }\n        if (name == \"viewBox\") {\n            A = this.attr(name).vb.split(\" \").map(Number);\n            B = b.split(\" \").map(Number);\n            return {\n                from: A,\n                to: B,\n                f: getViewBox\n            };\n        }\n        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n            if (typeof b == \"string\") {\n                b = Str(b).replace(/\\.{3}|\\u2026/g, a);\n            }\n            a = this.matrix;\n            if (!Snap._.rgTransform.test(b)) {\n                b = Snap._.transform2matrix(Snap._.svgTransform2string(b), this.getBBox());\n            } else {\n                b = Snap._.transform2matrix(b, this.getBBox());\n            }\n            return equaliseTransform(a, b, function() {\n                return el.getBBox(1);\n            });\n        }\n        if (name == \"d\" || name == \"path\") {\n            A = Snap.path.toCubic(a, b);\n            return {\n                from: path2array(A[0]),\n                to: path2array(A[1]),\n                f: getPath(A[0])\n            };\n        }\n        if (name == \"points\") {\n            A = Str(a).split(Snap._.separator);\n            B = Str(b).split(Snap._.separator);\n            return {\n                from: A,\n                to: B,\n                f: function(val) {\n                    return val;\n                }\n            };\n        }\n        if (isNumeric(a) && isNumeric(b)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getNumber\n            };\n        }\n        var aUnit = a.match(reUnit), bUnit = Str(b).match(reUnit);\n        if (aUnit && arrayEqual(aUnit, bUnit)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getUnit(aUnit)\n            };\n        } else {\n            return {\n                from: this.asPX(name),\n                to: this.asPX(name, b),\n                f: getNumber\n            };\n        }\n    });\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob) {\n    var elproto = Element.prototype, has = \"hasOwnProperty\", supportsTouch = \"createTouch\" in glob.doc, events = [\n        \"click\",\n        \"dblclick\",\n        \"mousedown\",\n        \"mousemove\",\n        \"mouseout\",\n        \"mouseover\",\n        \"mouseup\",\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\",\n        \"touchcancel\"\n    ], touchMap = {\n        mousedown: \"touchstart\",\n        mousemove: \"touchmove\",\n        mouseup: \"touchend\"\n    }, getScroll = function(xy, el) {\n        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\", doc = el && el.node ? el.node.ownerDocument : glob.doc;\n        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n    }, preventDefault = function() {\n        this.returnValue = false;\n    }, preventTouch = function() {\n        return this.originalEvent.preventDefault();\n    }, stopPropagation = function() {\n        this.cancelBubble = true;\n    }, stopTouch = function() {\n        return this.originalEvent.stopPropagation();\n    }, addEvent = function(obj, type, fn, element) {\n        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type, f = function(e) {\n            var scrollY = getScroll(\"y\", element), scrollX = getScroll(\"x\", element);\n            if (supportsTouch && touchMap[has](type)) {\n                for(var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++){\n                    if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n                        var olde = e;\n                        e = e.targetTouches[i];\n                        e.originalEvent = olde;\n                        e.preventDefault = preventTouch;\n                        e.stopPropagation = stopTouch;\n                        break;\n                    }\n                }\n            }\n            var x = e.clientX + scrollX, y = e.clientY + scrollY;\n            return fn.call(element, e, x, y);\n        };\n        if (type !== realName) {\n            obj.addEventListener(type, f, false);\n        }\n        obj.addEventListener(realName, f, false);\n        return function() {\n            if (type !== realName) {\n                obj.removeEventListener(type, f, false);\n            }\n            obj.removeEventListener(realName, f, false);\n            return true;\n        };\n    }, drag = [], dragMove = function(e) {\n        var x = e.clientX, y = e.clientY, scrollY = getScroll(\"y\"), scrollX = getScroll(\"x\"), dragi, j = drag.length;\n        while(j--){\n            dragi = drag[j];\n            if (supportsTouch) {\n                var i = e.touches && e.touches.length, touch;\n                while(i--){\n                    touch = e.touches[i];\n                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n                        break;\n                    }\n                }\n            } else {\n                e.preventDefault();\n            }\n            var node = dragi.el.node, o, next = node.nextSibling, parent = node.parentNode, display = node.style.display;\n            // glob.win.opera && parent.removeChild(node);\n            // node.style.display = \"none\";\n            // o = dragi.el.paper.getElementByPoint(x, y);\n            // node.style.display = display;\n            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n            x += scrollX;\n            y += scrollY;\n            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n        }\n    }, dragUp = function(e) {\n        Snap.unmousemove(dragMove).unmouseup(dragUp);\n        var i = drag.length, dragi;\n        while(i--){\n            dragi = drag[i];\n            dragi.el._drag = {};\n            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            eve.off(\"snap.drag.*.\" + dragi.el.id);\n        }\n        drag = [];\n    };\n    /*\\\n     * Element.click\n     [ method ]\n     **\n     * Adds a click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.unclick\n     [ method ]\n     **\n     * Removes a click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds a double click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes a double click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds a mousedown event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes a mousedown event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds a mousemove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes a mousemove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds a mouseout event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes a mouseout event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds a mouseover event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes a mouseover event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds a mouseup event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes a mouseup event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds a touchstart event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes a touchstart event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds a touchmove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes a touchmove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.touchend\n     [ method ]\n     **\n     * Adds a touchend event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes a touchend event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds a touchcancel event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ /*\\\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes a touchcancel event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/ for(var i = events.length; i--;){\n        (function(eventName) {\n            Snap[eventName] = elproto[eventName] = function(fn, scope) {\n                if (Snap.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({\n                        name: eventName,\n                        f: fn,\n                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n                    });\n                } else {\n                    for(var i = 0, ii = this.events.length; i < ii; i++)if (this.events[i].name == eventName) {\n                        try {\n                            this.events[i].f.call(this);\n                        } catch (e) {}\n                    }\n                }\n                return this;\n            };\n            Snap[\"un\" + eventName] = elproto[\"un\" + eventName] = function(fn) {\n                var events = this.events || [], l = events.length;\n                while(l--)if (events[l].name == eventName && (events[l].f == fn || !fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                    return this;\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n    /*\\\n     * Element.hover\n     [ method ]\n     **\n     * Adds hover event handlers to the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n    \\*/ elproto.hover = function(f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*\\\n     * Element.unhover\n     [ method ]\n     **\n     * Removes hover event handlers from the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n    \\*/ elproto.unhover = function(f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n    /*\\\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for an element's drag gesture\n     **\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, \n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element \n     * `drag.over.<id>` fires as well.\n     *\n     * Start event and start handler are called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler are called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler are called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n    \\*/ elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        var el = this;\n        if (!arguments.length) {\n            var origTransform;\n            return el.drag(function(dx, dy) {\n                this.attr({\n                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [\n                        dx,\n                        dy\n                    ]\n                });\n            }, function() {\n                origTransform = this.transform().local;\n            });\n        }\n        function start(e, x, y) {\n            (e.originalEvent || e).preventDefault();\n            el._drag.x = x;\n            el._drag.y = y;\n            el._drag.id = e.identifier;\n            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n            drag.push({\n                el: el,\n                move_scope: move_scope,\n                start_scope: start_scope,\n                end_scope: end_scope\n            });\n            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n        }\n        function init(e, x, y) {\n            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n        }\n        eve.on(\"snap.draginit.\" + el.id, start);\n        el._drag = {};\n        draggable.push({\n            el: el,\n            start: start,\n            init: init\n        });\n        el.mousedown(init);\n        return el;\n    };\n    /*\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n     - f (function) handler for event, first argument would be the element you are dragging over\n    \\*/ // elproto.onDragOver = function (f) {\n    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n    // };\n    /*\\\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from the given element\n    \\*/ elproto.undrag = function() {\n        var i = draggable.length;\n        while(i--)if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].init);\n            draggable.splice(i, 1);\n            eve.unbind(\"snap.drag.*.\" + this.id);\n            eve.unbind(\"snap.draginit.\" + this.id);\n        }\n        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n        return this;\n    };\n});\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob) {\n    var elproto = Element.prototype, pproto = Paper.prototype, rgurl = /^\\s*url\\((.+)\\)/, Str = String, $ = Snap._.$;\n    Snap.filter = {};\n    /*\\\n     * Paper.filter\n     [ method ]\n     **\n     * Creates a `<filter>` element\n     **\n     - filstr (string) SVG fragment of filter provided as a string\n     = (object) @Element\n     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n     > Usage\n     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/ pproto.filter = function(filstr) {\n        var paper = this;\n        if (paper.type != \"svg\") {\n            paper = paper.paper;\n        }\n        var f = Snap.parse(Str(filstr)), id = Snap._.id(), width = paper.node.offsetWidth, height = paper.node.offsetHeight, filter = $(\"filter\");\n        $(filter, {\n            id: id,\n            filterUnits: \"userSpaceOnUse\"\n        });\n        filter.appendChild(f.node);\n        paper.defs.appendChild(filter);\n        return new Element(filter);\n    };\n    eve.on(\"snap.util.getattr.filter\", function() {\n        eve.stop();\n        var p = $(this.node, \"filter\");\n        if (p) {\n            var match = Str(p).match(rgurl);\n            return match && Snap.select(match[1]);\n        }\n    });\n    eve.on(\"snap.util.attr.filter\", function(value) {\n        if (value instanceof Element && value.type == \"filter\") {\n            eve.stop();\n            var id = value.node.id;\n            if (!id) {\n                $(value.node, {\n                    id: value.id\n                });\n                id = value.id;\n            }\n            $(this.node, {\n                filter: Snap.url(id)\n            });\n        }\n        if (!value || value == \"none\") {\n            eve.stop();\n            this.node.removeAttribute(\"filter\");\n        }\n    });\n    /*\\\n     * Snap.filter.blur\n     [ method ]\n     **\n     * Returns an SVG markup string for the blur filter\n     **\n     - x (number) amount of horizontal blur, in pixels\n     - y (number) #optional amount of vertical blur, in pixels\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.blur(5, 10)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/ Snap.filter.blur = function(x, y) {\n        if (x == null) {\n            x = 2;\n        }\n        var def = y == null ? x : [\n            x,\n            y\n        ];\n        return Snap.format('<feGaussianBlur stdDeviation=\"{def}\"/>', {\n            def: def\n        });\n    };\n    Snap.filter.blur.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.shadow\n     [ method ]\n     **\n     * Returns an SVG markup string for the shadow filter\n     **\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - blur (number) #optional amount of blur\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * which makes blur default to `4`. Or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - opacity (number) #optional `0..1` opacity of the shadow\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.shadow(0, 2, .3)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/ Snap.filter.shadow = function(dx, dy, blur, color, opacity) {\n        if (opacity == null) {\n            if (color == null) {\n                opacity = blur;\n                blur = 4;\n                color = \"#000\";\n            } else {\n                opacity = color;\n                color = blur;\n                blur = 4;\n            }\n        }\n        if (blur == null) {\n            blur = 4;\n        }\n        if (opacity == null) {\n            opacity = 1;\n        }\n        if (dx == null) {\n            dx = 0;\n            dy = 2;\n        }\n        if (dy == null) {\n            dy = dx;\n        }\n        color = Snap.color(color);\n        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n            color: color,\n            dx: dx,\n            dy: dy,\n            blur: blur,\n            opacity: opacity\n        });\n    };\n    Snap.filter.shadow.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.grayscale\n     [ method ]\n     **\n     * Returns an SVG markup string for the grayscale filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/ Snap.filter.grayscale = function(amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    };\n    Snap.filter.grayscale.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.sepia\n     [ method ]\n     **\n     * Returns an SVG markup string for the sepia filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/ Snap.filter.sepia = function(amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    };\n    Snap.filter.sepia.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.saturate\n     [ method ]\n     **\n     * Returns an SVG markup string for the saturate filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/ Snap.filter.saturate = function(amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n            amount: 1 - amount\n        });\n    };\n    Snap.filter.saturate.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.hueRotate\n     [ method ]\n     **\n     * Returns an SVG markup string for the hue-rotate filter\n     **\n     - angle (number) angle of rotation\n     = (string) filter representation\n    \\*/ Snap.filter.hueRotate = function(angle) {\n        angle = angle || 0;\n        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n            angle: angle\n        });\n    };\n    Snap.filter.hueRotate.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.invert\n     [ method ]\n     **\n     * Returns an SVG markup string for the invert filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/ Snap.filter.invert = function(amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        //        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: 1 - amount\n        });\n    };\n    Snap.filter.invert.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.brightness\n     [ method ]\n     **\n     * Returns an SVG markup string for the brightness filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/ Snap.filter.brightness = function(amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n            amount: amount\n        });\n    };\n    Snap.filter.brightness.toString = function() {\n        return this();\n    };\n    /*\\\n     * Snap.filter.contrast\n     [ method ]\n     **\n     * Returns an SVG markup string for the contrast filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/ Snap.filter.contrast = function(amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    };\n    Snap.filter.contrast.toString = function() {\n        return this();\n    };\n});\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var box = Snap._.box, is = Snap.is, firstLetter = /^[^a-z]*([tbmlrc])/i, toString = function() {\n        return \"T\" + this.dx + \",\" + this.dy;\n    };\n    /*\\\n     * Element.getAlign\n     [ method ]\n     **\n     * Returns shift needed to align the element relatively to given element.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n     > Usage\n     | el.transform(el.getAlign(el2, \"top\"));\n     * or\n     | var dy = el.getAlign(el2, \"top\").dy;\n    \\*/ Element.prototype.getAlign = function(el, way) {\n        if (way == null && is(el, \"string\")) {\n            way = el;\n            el = null;\n        }\n        el = el || this.paper;\n        var bx = el.getBBox ? el.getBBox() : box(el), bb = this.getBBox(), out = {};\n        way = way && way.match(firstLetter);\n        way = way ? way[1].toLowerCase() : \"c\";\n        switch(way){\n            case \"t\":\n                out.dx = 0;\n                out.dy = bx.y - bb.y;\n                break;\n            case \"b\":\n                out.dx = 0;\n                out.dy = bx.y2 - bb.y2;\n                break;\n            case \"m\":\n                out.dx = 0;\n                out.dy = bx.cy - bb.cy;\n                break;\n            case \"l\":\n                out.dx = bx.x - bb.x;\n                out.dy = 0;\n                break;\n            case \"r\":\n                out.dx = bx.x2 - bb.x2;\n                out.dy = 0;\n                break;\n            default:\n                out.dx = bx.cx - bb.cx;\n                out.dy = 0;\n                break;\n        }\n        out.toString = toString;\n        return out;\n    };\n    /*\\\n     * Element.align\n     [ method ]\n     **\n     * Aligns the element relatively to given one via transformation.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object) this element\n     > Usage\n     | el.align(el2, \"top\");\n     * or\n     | el.align(\"middle\");\n    \\*/ Element.prototype.align = function(el, way) {\n        return this.transform(\"...\" + this.getAlign(el, way));\n    };\n});\n// Copyright (c) 2016 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype, is = Snap.is, Str = String, has = \"hasOwnProperty\";\n    function slice(from, to, f) {\n        return function(arr) {\n            var res1 = arr.slice(from, to);\n            if (res1.length == 1) {\n                res1 = res1[0];\n            }\n            return f ? f(res1) : res1;\n        };\n    }\n    var Animation = function(attr, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        this.attr = attr;\n        this.dur = ms;\n        easing && (this.easing = easing);\n        callback && (this.callback = callback);\n    };\n    Snap._.Animation = Animation;\n    /*\\\n     * Snap.animation\n     [ method ]\n     **\n     * Creates an animation object\n     **\n     - attr (object) attributes of final destination\n     - duration (number) duration of the animation, in milliseconds\n     - easing (function) #optional one of easing functions of @mina or custom one\n     - callback (function) #optional callback function that fires when animation ends\n     = (object) animation object\n    \\*/ Snap.animation = function(attr, ms, easing, callback) {\n        return new Animation(attr, ms, easing, callback);\n    };\n    /*\\\n     * Element.inAnim\n     [ method ]\n     **\n     * Returns a set of animations that may be able to manipulate the current element\n     **\n     = (object) in format:\n     o {\n     o     anim (object) animation object,\n     o     mina (object) @mina object,\n     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n    \\*/ elproto.inAnim = function() {\n        var el = this, res1 = [];\n        for(var id in el.anims)if (el.anims[has](id)) {\n            (function(a) {\n                res1.push({\n                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n                    mina: a,\n                    curStatus: a.status(),\n                    status: function(val) {\n                        return a.status(val);\n                    },\n                    stop: function() {\n                        a.stop();\n                    }\n                });\n            })(el.anims[id]);\n        }\n        return res1;\n    };\n    /*\\\n     * Snap.animate\n     [ method ]\n     **\n     * Runs generic animation of one number into another with a caring function\n     **\n     - from (number|array) number or array of numbers\n     - to (number|array) number or array of numbers\n     - setter (function) caring function that accepts one number argument\n     - duration (number) duration, in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function to execute when animation ends\n     = (object) animation object in @mina format\n     o {\n     o     id (string) animation id, consider it read-only,\n     o     duration (function) gets or sets the duration of the animation,\n     o     easing (function) easing,\n     o     speed (function) gets or sets the speed of the animation,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n     | var rect = Snap().rect(0, 0, 10, 10);\n     | Snap.animate(0, 10, function (val) {\n     |     rect.attr({\n     |         x: val\n     |     });\n     | }, 1000);\n     | // in given context is equivalent to\n     | rect.animate({x: 10}, 1000);\n    \\*/ Snap.animate = function(from, to, setter, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        var now = mina.time(), anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n        return anim;\n    };\n    /*\\\n     * Element.stop\n     [ method ]\n     **\n     * Stops all the animations for the current element\n     **\n     = (Element) the current element\n    \\*/ elproto.stop = function() {\n        var anims = this.inAnim();\n        for(var i = 0, ii = anims.length; i < ii; i++){\n            anims[i].stop();\n        }\n        return this;\n    };\n    /*\\\n     * Element.animate\n     [ method ]\n     **\n     * Animates the given attributes of the element\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     = (Element) the current element\n    \\*/ elproto.animate = function(attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = attrs.dur;\n            attrs = attrs.attr;\n        }\n        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq, el = this;\n        for(var key in attrs)if (attrs[has](key)) {\n            if (el.equal) {\n                eq = el.equal(key, Str(attrs[key]));\n                from = eq.from;\n                to = eq.to;\n                f = eq.f;\n            } else {\n                from = +el.attr(key);\n                to = +attrs[key];\n            }\n            var len = is(from, \"array\") ? from.length : 1;\n            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n            fkeys = fkeys.concat(from);\n            tkeys = tkeys.concat(to);\n        }\n        var now = mina.time(), anim = mina(fkeys, tkeys, now, now + ms, mina.time, function(val) {\n            var attr = {};\n            for(var key in keys)if (keys[has](key)) {\n                attr[key] = keys[key](val);\n            }\n            el.attr(attr);\n        }, easing);\n        el.anims[anim.id] = anim;\n        anim._attrs = attrs;\n        anim._callback = callback;\n        eve(\"snap.animcreated.\" + el.id, anim);\n        eve.once(\"mina.finish.\" + anim.id, function() {\n            eve.off(\"mina.*.\" + anim.id);\n            delete el.anims[anim.id];\n            callback && callback.call(el);\n        });\n        eve.once(\"mina.stop.\" + anim.id, function() {\n            eve.off(\"mina.*.\" + anim.id);\n            delete el.anims[anim.id];\n        });\n        return el;\n    };\n});\n// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function(Snap, Element, Paper, glob) {\n    // Colours are from https://www.materialui.co\n    var red = \"#ffebee#ffcdd2#ef9a9a#e57373#ef5350#f44336#e53935#d32f2f#c62828#b71c1c#ff8a80#ff5252#ff1744#d50000\", pink = \"#FCE4EC#F8BBD0#F48FB1#F06292#EC407A#E91E63#D81B60#C2185B#AD1457#880E4F#FF80AB#FF4081#F50057#C51162\", purple = \"#F3E5F5#E1BEE7#CE93D8#BA68C8#AB47BC#9C27B0#8E24AA#7B1FA2#6A1B9A#4A148C#EA80FC#E040FB#D500F9#AA00FF\", deeppurple = \"#EDE7F6#D1C4E9#B39DDB#9575CD#7E57C2#673AB7#5E35B1#512DA8#4527A0#311B92#B388FF#7C4DFF#651FFF#6200EA\", indigo = \"#E8EAF6#C5CAE9#9FA8DA#7986CB#5C6BC0#3F51B5#3949AB#303F9F#283593#1A237E#8C9EFF#536DFE#3D5AFE#304FFE\", blue = \"#E3F2FD#BBDEFB#90CAF9#64B5F6#64B5F6#2196F3#1E88E5#1976D2#1565C0#0D47A1#82B1FF#448AFF#2979FF#2962FF\", lightblue = \"#E1F5FE#B3E5FC#81D4FA#4FC3F7#29B6F6#03A9F4#039BE5#0288D1#0277BD#01579B#80D8FF#40C4FF#00B0FF#0091EA\", cyan = \"#E0F7FA#B2EBF2#80DEEA#4DD0E1#26C6DA#00BCD4#00ACC1#0097A7#00838F#006064#84FFFF#18FFFF#00E5FF#00B8D4\", teal = \"#E0F2F1#B2DFDB#80CBC4#4DB6AC#26A69A#009688#00897B#00796B#00695C#004D40#A7FFEB#64FFDA#1DE9B6#00BFA5\", green = \"#E8F5E9#C8E6C9#A5D6A7#81C784#66BB6A#4CAF50#43A047#388E3C#2E7D32#1B5E20#B9F6CA#69F0AE#00E676#00C853\", lightgreen = \"#F1F8E9#DCEDC8#C5E1A5#AED581#9CCC65#8BC34A#7CB342#689F38#558B2F#33691E#CCFF90#B2FF59#76FF03#64DD17\", lime = \"#F9FBE7#F0F4C3#E6EE9C#DCE775#D4E157#CDDC39#C0CA33#AFB42B#9E9D24#827717#F4FF81#EEFF41#C6FF00#AEEA00\", yellow = \"#FFFDE7#FFF9C4#FFF59D#FFF176#FFEE58#FFEB3B#FDD835#FBC02D#F9A825#F57F17#FFFF8D#FFFF00#FFEA00#FFD600\", amber = \"#FFF8E1#FFECB3#FFE082#FFD54F#FFCA28#FFC107#FFB300#FFA000#FF8F00#FF6F00#FFE57F#FFD740#FFC400#FFAB00\", orange = \"#FFF3E0#FFE0B2#FFCC80#FFB74D#FFA726#FF9800#FB8C00#F57C00#EF6C00#E65100#FFD180#FFAB40#FF9100#FF6D00\", deeporange = \"#FBE9E7#FFCCBC#FFAB91#FF8A65#FF7043#FF5722#F4511E#E64A19#D84315#BF360C#FF9E80#FF6E40#FF3D00#DD2C00\", brown = \"#EFEBE9#D7CCC8#BCAAA4#A1887F#8D6E63#795548#6D4C41#5D4037#4E342E#3E2723\", grey = \"#FAFAFA#F5F5F5#EEEEEE#E0E0E0#BDBDBD#9E9E9E#757575#616161#424242#212121\", bluegrey = \"#ECEFF1#CFD8DC#B0BEC5#90A4AE#78909C#607D8B#546E7A#455A64#37474F#263238\";\n    /*\\\n     * Snap.mui\n     [ property ]\n     **\n     * Contain Material UI colours.\n     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.mui.deeppurple, stroke: Snap.mui.amber[600]});\n     # For colour reference: <a href=\"https://www.materialui.co\">https://www.materialui.co</a>.\n    \\*/ Snap.mui = {};\n    /*\\\n     * Snap.flat\n     [ property ]\n     **\n     * Contain Flat UI colours.\n     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.flat.carrot, stroke: Snap.flat.wetasphalt});\n     # For colour reference: <a href=\"https://www.materialui.co\">https://www.materialui.co</a>.\n    \\*/ Snap.flat = {};\n    function saveColor(colors) {\n        colors = colors.split(/(?=#)/);\n        var color = new String(colors[5]);\n        color[50] = colors[0];\n        color[100] = colors[1];\n        color[200] = colors[2];\n        color[300] = colors[3];\n        color[400] = colors[4];\n        color[500] = colors[5];\n        color[600] = colors[6];\n        color[700] = colors[7];\n        color[800] = colors[8];\n        color[900] = colors[9];\n        if (colors[10]) {\n            color.A100 = colors[10];\n            color.A200 = colors[11];\n            color.A400 = colors[12];\n            color.A700 = colors[13];\n        }\n        return color;\n    }\n    Snap.mui.red = saveColor(red);\n    Snap.mui.pink = saveColor(pink);\n    Snap.mui.purple = saveColor(purple);\n    Snap.mui.deeppurple = saveColor(deeppurple);\n    Snap.mui.indigo = saveColor(indigo);\n    Snap.mui.blue = saveColor(blue);\n    Snap.mui.lightblue = saveColor(lightblue);\n    Snap.mui.cyan = saveColor(cyan);\n    Snap.mui.teal = saveColor(teal);\n    Snap.mui.green = saveColor(green);\n    Snap.mui.lightgreen = saveColor(lightgreen);\n    Snap.mui.lime = saveColor(lime);\n    Snap.mui.yellow = saveColor(yellow);\n    Snap.mui.amber = saveColor(amber);\n    Snap.mui.orange = saveColor(orange);\n    Snap.mui.deeporange = saveColor(deeporange);\n    Snap.mui.brown = saveColor(brown);\n    Snap.mui.grey = saveColor(grey);\n    Snap.mui.bluegrey = saveColor(bluegrey);\n    Snap.flat.turquoise = \"#1abc9c\";\n    Snap.flat.greensea = \"#16a085\";\n    Snap.flat.sunflower = \"#f1c40f\";\n    Snap.flat.orange = \"#f39c12\";\n    Snap.flat.emerland = \"#2ecc71\";\n    Snap.flat.nephritis = \"#27ae60\";\n    Snap.flat.carrot = \"#e67e22\";\n    Snap.flat.pumpkin = \"#d35400\";\n    Snap.flat.peterriver = \"#3498db\";\n    Snap.flat.belizehole = \"#2980b9\";\n    Snap.flat.alizarin = \"#e74c3c\";\n    Snap.flat.pomegranate = \"#c0392b\";\n    Snap.flat.amethyst = \"#9b59b6\";\n    Snap.flat.wisteria = \"#8e44ad\";\n    Snap.flat.clouds = \"#ecf0f1\";\n    Snap.flat.silver = \"#bdc3c7\";\n    Snap.flat.wetasphalt = \"#34495e\";\n    Snap.flat.midnightblue = \"#2c3e50\";\n    Snap.flat.concrete = \"#95a5a6\";\n    Snap.flat.asbestos = \"#7f8c8d\";\n    /*\\\n     * Snap.importMUIColors\n     [ method ]\n     **\n     * Imports Material UI colours into global object.\n     | Snap.importMUIColors();\n     | Snap().rect(0, 0, 10, 10).attr({fill: deeppurple, stroke: amber[600]});\n     # For colour reference: <a href=\"https://www.materialui.co\">https://www.materialui.co</a>.\n    \\*/ Snap.importMUIColors = function() {\n        for(var color in Snap.mui){\n            if (Snap.mui.hasOwnProperty(color)) {\n                window[color] = Snap.mui[color];\n            }\n        }\n    };\n});\nmodule.exports = Snap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc25hcHN2Zy1janMvZGlzdC9zbmFwLnN2Zy1janMuanMiLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLEdBQUcsR0FBR0MsbUJBQU9BLENBQUM7QUFFckIsc0VBQXNFO0FBQ3RFLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0YsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLElBQUlDLE9BQU8sU0FBV0YsSUFBRztJQUNyQixJQUFJRyxhQUFhLENBQUMsR0FDbEJDLG1CQUFtQkwsT0FBT00scUJBQXFCLElBQzVCTixPQUFPTywyQkFBMkIsSUFDbENQLE9BQU9RLHdCQUF3QixJQUMvQlIsT0FBT1Msc0JBQXNCLElBQzdCVCxPQUFPVSx1QkFBdUIsSUFDOUIsU0FBVUMsUUFBUTtRQUNkQyxXQUFXRCxVQUFVLElBQUksSUFBSUUsT0FBT0MsT0FBTztRQUMzQyxPQUFPO0lBQ1gsR0FDbkJDLFdBQ0FDLFVBQVVDLE1BQU1ELE9BQU8sSUFBSSxTQUFVRSxDQUFDO1FBQ2xDLE9BQU9BLGFBQWFELFNBQ2hCRSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSixNQUFNO0lBQzdDLEdBQ0FLLFFBQVEsR0FDUkMsV0FBVyxNQUFNLENBQUMsQ0FBQyxJQUFJWCxJQUFHLEVBQUdRLFFBQVEsQ0FBQyxLQUN0Q0ksS0FBSztRQUNELE9BQU9ELFdBQVcsQ0FBQ0QsT0FBTSxFQUFHRixRQUFRLENBQUM7SUFDekMsR0FDQUssT0FBTyxTQUFVUixDQUFDLEVBQUVTLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO1FBQ3ZCLElBQUliLFFBQVFFLElBQUk7WUFDWlksTUFBTSxFQUFFO1lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLEtBQUtkLEVBQUVlLE1BQU0sRUFB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LEtBQUs2M0IsR0FBRyxDQUFDdHNCLE1BQU07WUFDbkM7UUFDSjtJQUNKO0FBQ0o7QUFFQWt1QixPQUFPQyxPQUFPLEdBQUcxNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJzaXRldjMvLi9ub2RlX21vZHVsZXMvc25hcHN2Zy1janMvZGlzdC9zbmFwLnN2Zy1janMuanM/ZWRkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ3aW5kb3cuZXZlID0gcmVxdWlyZSgnZXZlJylcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIG1pbmEgPSAoZnVuY3Rpb24gKGV2ZSkge1xuICAgIHZhciBhbmltYXRpb25zID0ge30sXG4gICAgcmVxdWVzdEFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE2LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICByZXF1ZXN0SUQsXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9LFxuICAgIGlkZ2VuID0gMCxcbiAgICBpZHByZWZpeCA9IFwiTVwiICsgKCtuZXcgRGF0ZSkudG9TdHJpbmcoMzYpLFxuICAgIElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgZGlmZiA9IGZ1bmN0aW9uIChhLCBiLCBBLCBCKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGEpKSB7XG4gICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGRpZmYoYVtpXSwgYiwgQVtpXSwgQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWYgPSAoQSAtIGEpIC8gKEIgLSBiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBkaWYgKiAoYmIgLSBiKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRpbWVyID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH0sXG4gICAgc3RhID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEucztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHMgPSBhLnMgLSB2YWw7XG4gICAgICAgIGEuYiArPSBhLmR1ciAqIGRzO1xuICAgICAgICBhLkIgKz0gYS5kdXIgKiBkcztcbiAgICAgICAgYS5zID0gdmFsO1xuICAgIH0sXG4gICAgc3BlZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zcGQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5zcGQgPSB2YWw7XG4gICAgfSxcbiAgICBkdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmR1cjtcbiAgICAgICAgfVxuICAgICAgICBhLnMgPSBhLnMgKiB2YWwgLyBhLmR1cjtcbiAgICAgICAgYS5kdXIgPSB2YWw7XG4gICAgfSxcbiAgICBzdG9waXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgZGVsZXRlIGFuaW1hdGlvbnNbYS5pZF07XG4gICAgICAgIGEudXBkYXRlKCk7XG4gICAgICAgIGV2ZShcIm1pbmEuc3RvcC5cIiArIGEuaWQsIGEpO1xuICAgIH0sXG4gICAgcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKGEucGRpZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2EuaWRdO1xuICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICBhLnBkaWYgPSBhLmdldCgpIC0gYS5iO1xuICAgIH0sXG4gICAgcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICghYS5wZGlmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYS5iID0gYS5nZXQoKSAtIGEucGRpZjtcbiAgICAgICAgZGVsZXRlIGEucGRpZjtcbiAgICAgICAgYW5pbWF0aW9uc1thLmlkXSA9IGE7XG4gICAgICAgIGZyYW1lKCk7XG4gICAgfSxcbiAgICB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIHJlcztcbiAgICAgICAgaWYgKGlzQXJyYXkoYS5zdGFydCkpIHtcbiAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gYS5zdGFydC5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2pdID0gK2Euc3RhcnRbal0gK1xuICAgICAgICAgICAgICAgICAgICAoYS5lbmRbal0gLSBhLnN0YXJ0W2pdKSAqIGEuZWFzaW5nKGEucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSArYS5zdGFydCArIChhLmVuZCAtIGEuc3RhcnQpICogYS5lYXNpbmcoYS5zKTtcbiAgICAgICAgfVxuICAgICAgICBhLnNldChyZXMpO1xuICAgIH0sXG4gICAgZnJhbWUgPSBmdW5jdGlvbiAodGltZVN0YW1wKSB7XG4gICAgICAgIC8vIE1hbnVhbCBpbnZva2F0aW9uP1xuICAgICAgICBpZiAoIXRpbWVTdGFtcCkge1xuICAgICAgICAgICAgLy8gRnJhbWUgbG9vcCBzdG9wcGVkP1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0SUQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmcmFtZSBsb29wLi4uXG4gICAgICAgICAgICAgICAgcmVxdWVzdElEID0gcmVxdWVzdEFuaW1GcmFtZShmcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYW5pbWF0aW9ucykgaWYgKGFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gYW5pbWF0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICBiID0gYS5nZXQoKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGEucyA9IChiIC0gYS5iKSAvIChhLmR1ciAvIGEuc3BkKTtcbiAgICAgICAgICAgIGlmIChhLnMgPj0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGEucyA9IDE7XG4gICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwibWluYS5maW5pc2guXCIgKyBhLmlkLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RJRCA9IGxlbiA/IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUpIDogZmFsc2U7XG4gICAgfSxcbiAgICAvKlxcXG4gICAgICogbWluYVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2VuZXJpYyBhbmltYXRpb24gb2YgbnVtYmVyc1xuICAgICAqKlxuICAgICAtIGEgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBBIChudW1iZXIpIGVuZCBfc2xhdmVfIG51bWJlclxuICAgICAtIGIgKG51bWJlcikgc3RhcnQgX21hc3Rlcl8gbnVtYmVyIChzdGFydCB0aW1lIGluIGdlbmVyYWwgY2FzZSlcbiAgICAgLSBCIChudW1iZXIpIGVuZCBfbWFzdGVyXyBudW1iZXIgKGVuZCB0aW1lIGluIGdlbmVyYWwgY2FzZSlcbiAgICAgLSBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSlcbiAgICAgLSBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0IGlzIEBtaW5hLmxpbmVhclxuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBkZXNjcmlwdG9yXG4gICAgIG8ge1xuICAgICBvICAgICAgICAgaWQgKHN0cmluZykgYW5pbWF0aW9uIGlkLFxuICAgICBvICAgICAgICAgc3RhcnQgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlbmQgKG51bWJlcikgZW5kIF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgYiAobnVtYmVyKSBzdGFydCBfbWFzdGVyXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBzIChudW1iZXIpIGFuaW1hdGlvbiBzdGF0dXMgKDAuLjEpLFxuICAgICBvICAgICAgICAgZHVyIChudW1iZXIpIGFuaW1hdGlvbiBkdXJhdGlvbixcbiAgICAgbyAgICAgICAgIHNwZCAobnVtYmVyKSBhbmltYXRpb24gc3BlZWQsXG4gICAgIG8gICAgICAgICBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSksXG4gICAgIG8gICAgICAgICBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlYXNpbmcgKGZ1bmN0aW9uKSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHQgaXMgQG1pbmEubGluZWFyLFxuICAgICBvICAgICAgICAgc3RhdHVzIChmdW5jdGlvbikgc3RhdHVzIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzcGVlZCAoZnVuY3Rpb24pIHNwZWVkIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGR1cmF0aW9uIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzdG9wIChmdW5jdGlvbikgYW5pbWF0aW9uIHN0b3BwZXJcbiAgICAgbyAgICAgICAgIHBhdXNlIChmdW5jdGlvbikgcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgICAgbyAgICAgICAgIHJlc3VtZSAoZnVuY3Rpb24pIHJlc3VtZXMgdGhlIGFuaW1hdGlvblxuICAgICBvICAgICAgICAgdXBkYXRlIChmdW5jdGlvbikgY2FsbGVzIHNldHRlciB3aXRoIHRoZSByaWdodCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBtaW5hID0gZnVuY3Rpb24gKGEsIEEsIGIsIEIsIGdldCwgc2V0LCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB7XG4gICAgICAgICAgICBpZDogSUQoKSxcbiAgICAgICAgICAgIHN0YXJ0OiBhLFxuICAgICAgICAgICAgZW5kOiBBLFxuICAgICAgICAgICAgYjogYixcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICBkdXI6IEIgLSBiLFxuICAgICAgICAgICAgc3BkOiAxLFxuICAgICAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nIHx8IG1pbmEubGluZWFyLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGEsXG4gICAgICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBzdG9wOiBzdG9waXQsXG4gICAgICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgICAgICByZXN1bWU6IHJlc3VtZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGlvbnNbYW5pbS5pZF0gPSBhbmltO1xuICAgICAgICB2YXIgbGVuID0gMCwgaTtcbiAgICAgICAgZm9yIChpIGluIGFuaW1hdGlvbnMpIGlmIChhbmltYXRpb25zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9PSAxICYmIGZyYW1lKCk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEudGltZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLiBFcXVpdmFsZW50IHRvOlxuICAgICB8IGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuICAgICB8IH1cbiAgICBcXCovXG4gICAgbWluYS50aW1lID0gdGltZXI7XG4gICAgLypcXFxuICAgICAqIG1pbmEuZ2V0QnlJZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBhbmltYXRpb24gYnkgaXRzIGlkXG4gICAgIC0gaWQgKHN0cmluZykgYW5pbWF0aW9uJ3MgaWRcbiAgICAgPSAob2JqZWN0KSBTZWUgQG1pbmFcbiAgICBcXCovXG4gICAgbWluYS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2lkXSB8fCBudWxsO1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogbWluYS5saW5lYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERlZmF1bHQgbGluZWFyIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEubGluZWFyID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lYXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlb3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZW91dCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhuLCAxLjcpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWFzZWluXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlaW4gZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lYXNlaW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobiwgLjQ4KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVhc2Vpbm91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZWlub3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZWlub3V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHEgPSAuNDggLSBuIC8gMS4wNCxcbiAgICAgICAgICAgIFEgPSBNYXRoLnNxcnQoLjE3MzQgKyBxICogcSksXG4gICAgICAgICAgICB4ID0gUSAtIHEsXG4gICAgICAgICAgICBYID0gTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKSAqICh4IDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgICB5ID0gLVEgLSBxLFxuICAgICAgICAgICAgWSA9IE1hdGgucG93KE1hdGguYWJzKHkpLCAxIC8gMykgKiAoeSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgICAgdCA9IFggKyBZICsgLjU7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogMyAqIHQgKiB0ICsgdCAqIHQgKiB0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYmFja2luXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCYWNraW4gZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5iYWNraW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBuICogbiAqICgocyArIDEpICogbiAtIHMpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYmFja291dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmFja291dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJhY2tvdXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBuID0gbiAtIDE7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIG4gKiBuICogKChzICsgMSkgKiBuICsgcykgKyAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWxhc3RpY1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWxhc3RpYyBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVsYXN0aWMgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAhIW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBuKSAqIE1hdGguc2luKChuIC0gLjA3NSkgKlxuICAgICAgICAgICAgKDIgKiBNYXRoLlBJKSAvIC4zKSArIDE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5ib3VuY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJvdW5jZSBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJvdW5jZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBzID0gNy41NjI1LFxuICAgICAgICAgICAgcCA9IDIuNzUsXG4gICAgICAgICAgICBsO1xuICAgICAgICBpZiAobiA8IDEgLyBwKSB7XG4gICAgICAgICAgICBsID0gcyAqIG4gKiBuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4gPCAyIC8gcCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMS41IC8gcDtcbiAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjc1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8IDIuNSAvIHApIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAyLjI1IC8gcDtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45Mzc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gMi42MjUgLyBwO1xuICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjk4NDM3NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfTtcbiAgICB3aW5kb3cubWluYSA9IG1pbmE7XG4gICAgcmV0dXJuIG1pbmE7XG59KSh0eXBlb2YgZXZlID09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbiAoKSB7fSA6IGV2ZSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyAtIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbnZhciBTbmFwID0gKGZ1bmN0aW9uKHJvb3QpIHtcblNuYXAudmVyc2lvbiA9IFwiMC41LjFcIjtcbi8qXFxcbiAqIFNuYXBcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBkcmF3aW5nIHN1cmZhY2Ugb3Igd3JhcHMgZXhpc3RpbmcgU1ZHIGVsZW1lbnQuXG4gKipcbiAtIHdpZHRoIChudW1iZXJ8c3RyaW5nKSB3aWR0aCBvZiBzdXJmYWNlXG4gLSBoZWlnaHQgKG51bWJlcnxzdHJpbmcpIGhlaWdodCBvZiBzdXJmYWNlXG4gKiBvclxuIC0gRE9NIChTVkdFbGVtZW50KSBlbGVtZW50IHRvIGJlIHdyYXBwZWQgaW50byBTbmFwIHN0cnVjdHVyZVxuICogb3JcbiAtIGFycmF5IChhcnJheSkgYXJyYXkgb2YgZWxlbWVudHMgKHdpbGwgcmV0dXJuIHNldCBvZiBlbGVtZW50cylcbiAqIG9yXG4gLSBxdWVyeSAoc3RyaW5nKSBDU1MgcXVlcnkgc2VsZWN0b3JcbiA9IChvYmplY3QpIEBFbGVtZW50XG5cXCovXG5mdW5jdGlvbiBTbmFwKHcsIGgpIHtcbiAgICBpZiAodykge1xuICAgICAgICBpZiAody5ub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHcsIFwiYXJyYXlcIikgJiYgU25hcC5zZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLnNldC5hcHBseShTbmFwLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdyA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IoU3RyaW5nKHcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcCh3KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB3ID0gdyA9PSBudWxsID8gXCIxMDAlXCIgOiB3O1xuICAgIGggPSBoID09IG51bGwgPyBcIjEwMCVcIiA6IGg7XG4gICAgcmV0dXJuIG5ldyBQYXBlcih3LCBoKTtcbn1cblNuYXAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiU25hcCB2XCIgKyB0aGlzLnZlcnNpb247XG59O1xuU25hcC5fID0ge307XG52YXIgZ2xvYiA9IHtcbiAgICB3aW46IHJvb3Qud2luZG93LFxuICAgIGRvYzogcm9vdC53aW5kb3cuZG9jdW1lbnRcbn07XG5TbmFwLl8uZ2xvYiA9IGdsb2I7XG52YXIgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIFN0ciA9IFN0cmluZyxcbiAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICB0b0ludCA9IHBhcnNlSW50LFxuICAgIG1hdGggPSBNYXRoLFxuICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICBtbWluID0gbWF0aC5taW4sXG4gICAgYWJzID0gbWF0aC5hYnMsXG4gICAgcG93ID0gbWF0aC5wb3csXG4gICAgUEkgPSBtYXRoLlBJLFxuICAgIHJvdW5kID0gbWF0aC5yb3VuZCxcbiAgICBFID0gXCJcIixcbiAgICBTID0gXCIgXCIsXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIElTVVJMID0gL151cmxcXChbJ1wiXT8oW15cXCldKz8pWydcIl0/XFwpJC9pLFxuICAgIGNvbG91clJlZ0V4cCA9IC9eXFxzKigoI1thLWZcXGRdezZ9KXwoI1thLWZcXGRdezN9KXxyZ2JhP1xcKFxccyooW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/KD86XFxzKixcXHMqW1xcZFxcLl0rJT8pPylcXHMqXFwpfGhzYmE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/JT8pXFxzKlxcKXxoc2xhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyU/KVxccypcXCkpXFxzKiQvaSxcbiAgICBiZXppZXJyZyA9IC9eKD86Y3ViaWMtKT9iZXppZXJcXCgoW14sXSspLChbXixdKyksKFteLF0rKSwoW15cXCldKylcXCkvLFxuICAgIHNlcGFyYXRvciA9IFNuYXAuXy5zZXBhcmF0b3IgPSAvWyxcXHNdKy8sXG4gICAgd2hpdGVzcGFjZSA9IC9bXFxzXS9nLFxuICAgIGNvbW1hU3BhY2VzID0gL1tcXHNdKixbXFxzXSovLFxuICAgIGhzcmcgPSB7aHM6IDEsIHJnOiAxfSxcbiAgICBwYXRoQ29tbWFuZCA9IC8oW2Etel0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHRDb21tYW5kID0gLyhbcnN0bV0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pW1xcc10qLD9bXFxzXSovaWcsXG4gICAgaWRnZW4gPSAwLFxuICAgIGlkcHJlZml4ID0gXCJTXCIgKyAoK25ldyBEYXRlKS50b1N0cmluZygzNiksXG4gICAgSUQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIChlbCAmJiBlbC50eXBlID8gZWwudHlwZSA6IEUpICsgaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgeGxpbmsgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWxucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBodWIgPSB7fSxcbiAgICAvKlxcXG4gICAgICogU25hcC51cmxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFdyYXBzIHBhdGggaW50byBgXCJ1cmwoJzxwYXRoPicpXCJgLlxuICAgICAtIHZhbHVlIChzdHJpbmcpIHBhdGhcbiAgICAgPSAoc3RyaW5nKSB3cmFwcGVkIHBhdGhcbiAgICBcXCovXG4gICAgVVJMID0gU25hcC51cmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBcInVybCgnI1wiICsgdXJsICsgXCInKVwiO1xuICAgIH07XG5cbmZ1bmN0aW9uICQoZWwsIGF0dHIpIHtcbiAgICBpZiAoYXR0cikge1xuICAgICAgICBpZiAoZWwgPT0gXCIjdGV4dFwiKSB7XG4gICAgICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZVRleHROb2RlKGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09IFwiI2NvbW1lbnRcIikge1xuICAgICAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVDb21tZW50KGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbCA9ICQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCA2KSA9PSBcInhsaW5rOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGVOUyh4bGluaywgYXR0ci5zdWJzdHJpbmcoNikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZU5TKHhtbG5zLCBhdHRyLnN1YnN0cmluZyg0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHIpIGlmIChhdHRyW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBTdHIoYXR0cltrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDYpID09IFwieGxpbms6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBrZXkuc3Vic3RyaW5nKDYpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCBrZXkuc3Vic3RyaW5nKDQpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInRleHRcIiBpbiBhdHRyKSB7XG4gICAgICAgICAgICBlbC5ub2RlVmFsdWUgPSBhdHRyLnRleHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxucywgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5TbmFwLl8uJCA9ICQ7XG5TbmFwLl8uaWQgPSBJRDtcbmZ1bmN0aW9uIGdldEF0dHJzKGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3V0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZXNwYWNlVVJJID09IHhsaW5rKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJ4bGluazpcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgKz0gYXR0cnNbaV0ubmFtZTtcbiAgICAgICAgb3V0W25hbWVdID0gYXR0cnNbaV0udGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpcyhvLCB0eXBlKSB7XG4gICAgdHlwZSA9IFN0ci5wcm90b3R5cGUudG9Mb3dlckNhc2UuY2FsbCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShvKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiICYmXG4gICAgICAgIChvIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICB0eXBlID09IFwibnVsbFwiICYmIG8gPT09IG51bGwgfHxcbiAgICAgICAgICAgIHR5cGUgPT0gdHlwZW9mIG8gJiYgbyAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZSA9PSBcIm9iamVjdFwiICYmIG8gPT09IE9iamVjdChvKSB8fFxuICAgICAgICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xufVxuLypcXFxuICogU25hcC5mb3JtYXRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJlcGxhY2VzIGNvbnN0cnVjdGlvbiBvZiB0eXBlIGB7PG5hbWU+fWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnRcbiAqKlxuIC0gdG9rZW4gKHN0cmluZykgc3RyaW5nIHRvIGZvcm1hdFxuIC0ganNvbiAob2JqZWN0KSBvYmplY3Qgd2hpY2ggcHJvcGVydGllcyBhcmUgdXNlZCBhcyBhIHJlcGxhY2VtZW50XG4gPSAoc3RyaW5nKSBmb3JtYXR0ZWQgc3RyaW5nXG4gPiBVc2FnZVxuIHwgLy8gdGhpcyBkcmF3cyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gfCBwYXBlci5wYXRoKFNuYXAuZm9ybWF0KFwiTXt4fSx7eX1oe2RpbS53aWR0aH12e2RpbS5oZWlnaHR9aHtkaW1bJ25lZ2F0aXZlIHdpZHRoJ119elwiLCB7XG4gfCAgICAgeDogMTAsXG4gfCAgICAgeTogMjAsXG4gfCAgICAgZGltOiB7XG4gfCAgICAgICAgIHdpZHRoOiA0MCxcbiB8ICAgICAgICAgaGVpZ2h0OiA1MCxcbiB8ICAgICAgICAgXCJuZWdhdGl2ZSB3aWR0aFwiOiAtNDBcbiB8ICAgICB9XG4gfCB9KSk7XG5cXCovXG5TbmFwLmZvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFteXFx9XSspXFx9L2csXG4gICAgICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZywgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoYWxsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9iajtcbiAgICAgICAgICAgIGtleS5yZXBsYWNlKG9iak5vdGF0aW9uUmVnZXgsIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcyA9PSBcImZ1bmN0aW9uXCIgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMgPSAocmVzID09IG51bGwgfHwgcmVzID09IG9iaiA/IGFsbCA6IHJlcykgKyBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgb2JqKSB7XG4gICAgICAgIHJldHVybiBTdHIoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uIChhbGwsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09IFwiZnVuY3Rpb25cIiB8fCBPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChvYmpbaGFzXShrZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuU25hcC5fLmNsb25lID0gY2xvbmU7XG5mdW5jdGlvbiByZXB1c2goYXJyYXksIGl0ZW0pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWNoZXIoZiwgc2NvcGUsIHBvc3Rwcm9jZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBuZXdmKCkge1xuICAgICAgICB2YXIgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmcuam9pbihcIlxcdTI0MDBcIiksXG4gICAgICAgICAgICBjYWNoZSA9IG5ld2YuY2FjaGUgPSBuZXdmLmNhY2hlIHx8IHt9LFxuICAgICAgICAgICAgY291bnQgPSBuZXdmLmNvdW50ID0gbmV3Zi5jb3VudCB8fCBbXTtcbiAgICAgICAgaWYgKGNhY2hlW2hhc10oYXJncykpIHtcbiAgICAgICAgICAgIHJlcHVzaChjb3VudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcG9zdHByb2Nlc3NvciA/IHBvc3Rwcm9jZXNzb3IoY2FjaGVbYXJnc10pIDogY2FjaGVbYXJnc107XG4gICAgICAgIH1cbiAgICAgICAgY291bnQubGVuZ3RoID49IDFlMyAmJiBkZWxldGUgY2FjaGVbY291bnQuc2hpZnQoKV07XG4gICAgICAgIGNvdW50LnB1c2goYXJncyk7XG4gICAgICAgIGNhY2hlW2FyZ3NdID0gZi5hcHBseShzY29wZSwgYXJnKTtcbiAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Zjtcbn1cblNuYXAuXy5jYWNoZXIgPSBjYWNoZXI7XG5mdW5jdGlvbiBhbmdsZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgaWYgKHgzID09IG51bGwpIHtcbiAgICAgICAgdmFyIHggPSB4MSAtIHgyLFxuICAgICAgICAgICAgeSA9IHkxIC0geTI7XG4gICAgICAgIGlmICgheCAmJiAheSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgxODAgKyBtYXRoLmF0YW4yKC15LCAteCkgKiAxODAgLyBQSSArIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlKHgxLCB5MSwgeDMsIHkzKSAtIGFuZ2xlKHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByYWQoZGVnKSB7XG4gICAgcmV0dXJuIGRlZyAlIDM2MCAqIFBJIC8gMTgwO1xufVxuZnVuY3Rpb24gZGVnKHJhZCkge1xuICAgIHJldHVybiByYWQgKiAxODAgLyBQSSAlIDM2MDtcbn1cbmZ1bmN0aW9uIHhfeSgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgUyArIHRoaXMueTtcbn1cbmZ1bmN0aW9uIHhfeV93X2goKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnkgKyBTICsgdGhpcy53aWR0aCArIFwiIFxceGQ3IFwiICsgdGhpcy5oZWlnaHQ7XG59XG5cbi8qXFxcbiAqIFNuYXAucmFkXG4gWyBtZXRob2QgXVxuICoqXG4gKiBUcmFuc2Zvcm0gYW5nbGUgdG8gcmFkaWFuc1xuIC0gZGVnIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcblxcKi9cblNuYXAucmFkID0gcmFkO1xuLypcXFxuICogU25hcC5kZWdcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFRyYW5zZm9ybSBhbmdsZSB0byBkZWdyZWVzXG4gLSByYWQgKG51bWJlcikgYW5nbGUgaW4gcmFkaWFuc1xuID0gKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5kZWcgPSBkZWc7XG4vKlxcXG4gKiBTbmFwLnNpblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5zaW4oKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gYW5nbGUgKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuID0gKG51bWJlcikgc2luXG5cXCovXG5TbmFwLnNpbiA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIHJldHVybiBtYXRoLnNpbihTbmFwLnJhZChhbmdsZSkpO1xufTtcbi8qXFxcbiAqIFNuYXAudGFuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLnRhbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSB0YW5cblxcKi9cblNuYXAudGFuID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgcmV0dXJuIG1hdGgudGFuKFNuYXAucmFkKGFuZ2xlKSk7XG59O1xuLypcXFxuICogU25hcC5jb3NcbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguY29zKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIGFuZ2xlIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGNvc1xuXFwqL1xuU25hcC5jb3MgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICByZXR1cm4gbWF0aC5jb3MoU25hcC5yYWQoYW5nbGUpKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFzaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguYXNpbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBudW0gKG51bWJlcikgdmFsdWVcbiA9IChudW1iZXIpIGFzaW4gaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hc2luID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBTbmFwLmRlZyhtYXRoLmFzaW4obnVtKSk7XG59O1xuLypcXFxuICogU25hcC5hY29zXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmFjb3MoKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gbnVtIChudW1iZXIpIHZhbHVlXG4gPSAobnVtYmVyKSBhY29zIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYWNvcyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hY29zKG51bSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuYXRhblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5hdGFuKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbiBpbiBkZWdyZWVzXG5cXCovXG5TbmFwLmF0YW4gPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIFNuYXAuZGVnKG1hdGguYXRhbihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmF0YW4yXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmF0YW4yKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbjIgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hdGFuMiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hdGFuMihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFuZ2xlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gdHdvIG9yIHRocmVlIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB4MyAobnVtYmVyKSAjb3B0aW9uYWwgeCBjb29yZCBvZiB0aGlyZCBwb2ludFxuIC0geTMgKG51bWJlcikgI29wdGlvbmFsIHkgY29vcmQgb2YgdGhpcmQgcG9pbnRcbiA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYW5nbGUgPSBhbmdsZTtcbi8qXFxcbiAqIFNuYXAubGVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFNuYXAubGVuMih4MSwgeTEsIHgyLCB5MikpO1xufTtcbi8qXFxcbiAqIFNuYXAubGVuMlxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4yID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKTtcbn07XG4vKlxcXG4gKiBTbmFwLmNsb3Nlc3RQb2ludFxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBjbG9zZXN0IHBvaW50IHRvIGEgZ2l2ZW4gb25lIG9uIGEgZ2l2ZW4gcGF0aC5cbiAtIHBhdGggKEVsZW1lbnQpIHBhdGggZWxlbWVudFxuIC0geCAobnVtYmVyKSB4IGNvb3JkIG9mIGEgcG9pbnRcbiAtIHkgKG51bWJlcikgeSBjb29yZCBvZiBhIHBvaW50XG4gPSAob2JqZWN0KSBpbiBmb3JtYXRcbiB7XG4gICAgeCAobnVtYmVyKSB4IGNvb3JkIG9mIHRoZSBwb2ludCBvbiB0aGUgcGF0aFxuICAgIHkgKG51bWJlcikgeSBjb29yZCBvZiB0aGUgcG9pbnQgb24gdGhlIHBhdGhcbiAgICBsZW5ndGggKG51bWJlcikgbGVuZ3RoIG9mIHRoZSBwYXRoIHRvIHRoZSBwb2ludFxuICAgIGRpc3RhbmNlIChudW1iZXIpIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBwYXRoXG4gfVxuXFwqL1xuLy8gQ29waWVkIGZyb20gaHR0cDovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzgwMjc2MzdcblNuYXAuY2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gKHBhdGgsIHgsIHkpIHtcbiAgICBmdW5jdGlvbiBkaXN0YW5jZTIocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB5O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIHZhciBwYXRoTm9kZSA9IHBhdGgubm9kZSxcbiAgICAgICAgcGF0aExlbmd0aCA9IHBhdGhOb2RlLmdldFRvdGFsTGVuZ3RoKCksXG4gICAgICAgIHByZWNpc2lvbiA9IHBhdGhMZW5ndGggLyBwYXRoTm9kZS5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zICogLjEyNSxcbiAgICAgICAgYmVzdCxcbiAgICAgICAgYmVzdExlbmd0aCxcbiAgICAgICAgYmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAvLyBsaW5lYXIgc2NhbiBmb3IgY29hcnNlIGFwcHJveGltYXRpb25cbiAgICBmb3IgKHZhciBzY2FuLCBzY2FuTGVuZ3RoID0gMCwgc2NhbkRpc3RhbmNlOyBzY2FuTGVuZ3RoIDw9IHBhdGhMZW5ndGg7IHNjYW5MZW5ndGggKz0gcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmICgoc2NhbkRpc3RhbmNlID0gZGlzdGFuY2UyKHNjYW4gPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKHNjYW5MZW5ndGgpKSkgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGJlc3QgPSBzY2FuO1xuICAgICAgICAgICAgYmVzdExlbmd0aCA9IHNjYW5MZW5ndGg7XG4gICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBzY2FuRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiaW5hcnkgc2VhcmNoIGZvciBwcmVjaXNlIGVzdGltYXRlXG4gICAgcHJlY2lzaW9uICo9IC41O1xuICAgIHdoaWxlIChwcmVjaXNpb24gPiAuNSkge1xuICAgICAgICB2YXIgYmVmb3JlLFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICBiZWZvcmVMZW5ndGgsXG4gICAgICAgICAgICBhZnRlckxlbmd0aCxcbiAgICAgICAgICAgIGJlZm9yZURpc3RhbmNlLFxuICAgICAgICAgICAgYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgaWYgKChiZWZvcmVMZW5ndGggPSBiZXN0TGVuZ3RoIC0gcHJlY2lzaW9uKSA+PSAwICYmIChiZWZvcmVEaXN0YW5jZSA9IGRpc3RhbmNlMihiZWZvcmUgPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKGJlZm9yZUxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGJlZm9yZTtcbiAgICAgICAgICAgIGJlc3RMZW5ndGggPSBiZWZvcmVMZW5ndGg7XG4gICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBiZWZvcmVEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmICgoYWZ0ZXJMZW5ndGggPSBiZXN0TGVuZ3RoICsgcHJlY2lzaW9uKSA8PSBwYXRoTGVuZ3RoICYmIChhZnRlckRpc3RhbmNlID0gZGlzdGFuY2UyKGFmdGVyID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChhZnRlckxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGFmdGVyO1xuICAgICAgICAgICAgYmVzdExlbmd0aCA9IGFmdGVyTGVuZ3RoO1xuICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiAqPSAuNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlc3QgPSB7XG4gICAgICAgIHg6IGJlc3QueCxcbiAgICAgICAgeTogYmVzdC55LFxuICAgICAgICBsZW5ndGg6IGJlc3RMZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoYmVzdERpc3RhbmNlKVxuICAgIH07XG4gICAgcmV0dXJuIGJlc3Q7XG59XG4vKlxcXG4gKiBTbmFwLmlzXG4gWyBtZXRob2QgXVxuICoqXG4gKiBIYW5keSByZXBsYWNlbWVudCBmb3IgdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gLSBvICjigKYpIGFueSBvYmplY3Qgb3IgcHJpbWl0aXZlXG4gLSB0eXBlIChzdHJpbmcpIG5hbWUgb2YgdGhlIHR5cGUsIGUuZy4sIGBzdHJpbmdgLCBgZnVuY3Rpb25gLCBgbnVtYmVyYCwgZXRjLlxuID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBnaXZlbiB2YWx1ZSBpcyBvZiBnaXZlbiB0eXBlXG5cXCovXG5TbmFwLmlzID0gaXM7XG4vKlxcXG4gKiBTbmFwLnNuYXBUb1xuIFsgbWV0aG9kIF1cbiAqKlxuICogU25hcHMgZ2l2ZW4gdmFsdWUgdG8gZ2l2ZW4gZ3JpZFxuIC0gdmFsdWVzIChhcnJheXxudW1iZXIpIGdpdmVuIGFycmF5IG9mIHZhbHVlcyBvciBzdGVwIG9mIHRoZSBncmlkXG4gLSB2YWx1ZSAobnVtYmVyKSB2YWx1ZSB0byBhZGp1c3RcbiAtIHRvbGVyYW5jZSAobnVtYmVyKSAjb3B0aW9uYWwgbWF4aW11bSBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0IHZhbHVlIHRoYXQgd291bGQgdHJpZ2dlciB0aGUgc25hcC4gRGVmYXVsdCBpcyBgMTBgLlxuID0gKG51bWJlcikgYWRqdXN0ZWQgdmFsdWVcblxcKi9cblNuYXAuc25hcFRvID0gZnVuY3Rpb24gKHZhbHVlcywgdmFsdWUsIHRvbGVyYW5jZSkge1xuICAgIHRvbGVyYW5jZSA9IGlzKHRvbGVyYW5jZSwgXCJmaW5pdGVcIikgPyB0b2xlcmFuY2UgOiAxMDtcbiAgICBpZiAoaXModmFsdWVzLCBcImFycmF5XCIpKSB7XG4gICAgICAgIHZhciBpID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgaWYgKGFicyh2YWx1ZXNbaV0gLSB2YWx1ZSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzID0gK3ZhbHVlcztcbiAgICAgICAgdmFyIHJlbSA9IHZhbHVlICUgdmFsdWVzO1xuICAgICAgICBpZiAocmVtIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSByZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbSA+IHZhbHVlcyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtICsgdmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vLyBDb2xvdXJcbi8qXFxcbiAqIFNuYXAuZ2V0UkdCXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgY29sb3Igc3RyaW5nIGFzIFJHQiBvYmplY3RcbiAtIGNvbG9yIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICMgPHVsPlxuICMgICAgIDxsaT5Db2xvciBuYW1lICg8Y29kZT5yZWQ8L2NvZGU+LCA8Y29kZT5ncmVlbjwvY29kZT4sIDxjb2RlPmNvcm5mbG93ZXJibHVlPC9jb2RlPiwgZXRjKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKIg4oCUIHNob3J0ZW5lZCBIVE1MIGNvbG9yOiAoPGNvZGU+IzAwMDwvY29kZT4sIDxjb2RlPiNmYzA8L2NvZGU+LCBldGMuKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKLigKLigKLigKIg4oCUIGZ1bGwgbGVuZ3RoIEhUTUwgY29sb3I6ICg8Y29kZT4jMDAwMDAwPC9jb2RlPiwgPGNvZGU+I2JkMjMwMDwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzIHZhbHVlczogKDxjb2RlPnJnYigyMDAsJm5ic3A7MTAwLCZuYnNwOzApPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTogKDxjb2RlPnJnYigxMDAlLCZuYnNwOzE3NSUsJm5ic3A7MCUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBicmlnaHRuZXNzIHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDsxKTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+aHNiYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU8L2xpPlxuICMgICAgIDxsaT5oc2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzbCjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBsdW1pbm9zaXR5IHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDswLjUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5oc2xhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNsKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gIyAgICAgPGxpPmhzbGEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjIDwvdWw+XG4gKiBOb3RlIHRoYXQgYCVgIGNhbiBiZSB1c2VkIGFueSB0aW1lOiBgcmdiKDIwJSwgMjU1LCA1MCUpYC5cbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiBvICAgICBlcnJvciAoYm9vbGVhbikgdHJ1ZSBpZiBzdHJpbmcgY2FuJ3QgYmUgcGFyc2VkXG4gbyB9XG5cXCovXG5TbmFwLmdldFJHQiA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3VyKSB7XG4gICAgaWYgKCFjb2xvdXIgfHwgISEoKGNvbG91ciA9IFN0cihjb2xvdXIpKS5pbmRleE9mKFwiLVwiKSArIDEpKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIGlmIChjb2xvdXIgPT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgIH1cbiAgICAhKGhzcmdbaGFzXShjb2xvdXIudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMCwgMikpIHx8IGNvbG91ci5jaGFyQXQoKSA9PSBcIiNcIikgJiYgKGNvbG91ciA9IHRvSGV4KGNvbG91cikpO1xuICAgIGlmICghY29sb3VyKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIHZhciByZXMsXG4gICAgICAgIHJlZCxcbiAgICAgICAgZ3JlZW4sXG4gICAgICAgIGJsdWUsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHQsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgcmdiID0gY29sb3VyLm1hdGNoKGNvbG91clJlZ0V4cCk7XG4gICAgaWYgKHJnYikge1xuICAgICAgICBpZiAocmdiWzJdKSB7XG4gICAgICAgICAgICBibHVlID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZyg1KSwgMTYpO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDEsIDMpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYlszXSkge1xuICAgICAgICAgICAgYmx1ZSA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgzKSkgKyB0LCAxNik7XG4gICAgICAgICAgICBncmVlbiA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgyKSkgKyB0LCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMSkpICsgdCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNF0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls0XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgKj0gMi41NSk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcInJnYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNV0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls1XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgLz0gMTAwKTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gLz0gMTAwKTtcbiAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlIC89IDEwMCk7XG4gICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuaHNiMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzZdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNl0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gdG9GbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkIC89IDEwMCk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuIC89IDEwMCk7XG4gICAgICAgICAgICBibHVlID0gdG9GbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAvPSAxMDApO1xuICAgICAgICAgICAgKHZhbHVlc1swXS5zbGljZSgtMykgPT0gXCJkZWdcIiB8fCB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiXFx4YjBcIikgJiYgKHJlZCAvPSAzNjApO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2xhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLmhzbDJyZ2IocmVkLCBncmVlbiwgYmx1ZSwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkID0gbW1pbihtYXRoLnJvdW5kKHJlZCksIDI1NSk7XG4gICAgICAgIGdyZWVuID0gbW1pbihtYXRoLnJvdW5kKGdyZWVuKSwgMjU1KTtcbiAgICAgICAgYmx1ZSA9IG1taW4obWF0aC5yb3VuZChibHVlKSwgMjU1KTtcbiAgICAgICAgb3BhY2l0eSA9IG1taW4obW1heChvcGFjaXR5LCAwKSwgMSk7XG4gICAgICAgIHJnYiA9IHtyOiByZWQsIGc6IGdyZWVuLCBiOiBibHVlLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgICAgICByZ2IuaGV4ID0gXCIjXCIgKyAoMTY3NzcyMTYgfCBibHVlIHwgZ3JlZW4gPDwgOCB8IHJlZCA8PCAxNikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICByZ2Iub3BhY2l0eSA9IGlzKG9wYWNpdHksIFwiZmluaXRlXCIpID8gb3BhY2l0eSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG59LCBTbmFwKTtcbi8qXFxcbiAqIFNuYXAuaHNiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0IgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gYiAobnVtYmVyKSB2YWx1ZSBvciBicmlnaHRuZXNzXG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLmhzYiA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgYikge1xuICAgIHJldHVybiBTbmFwLmhzYjJyZ2IoaCwgcywgYikuaGV4O1xufSk7XG4vKlxcXG4gKiBTbmFwLmhzbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNMIHZhbHVlcyB0byBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuXFwqL1xuU25hcC5oc2wgPSBjYWNoZXIoZnVuY3Rpb24gKGgsIHMsIGwpIHtcbiAgICByZXR1cm4gU25hcC5oc2wycmdiKGgsIHMsIGwpLmhleDtcbn0pO1xuLypcXFxuICogU25hcC5yZ2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG4gLSByIChudW1iZXIpIHJlZFxuIC0gZyAobnVtYmVyKSBncmVlblxuIC0gYiAobnVtYmVyKSBibHVlXG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLnJnYiA9IGNhY2hlcihmdW5jdGlvbiAociwgZywgYiwgbykge1xuICAgIGlmIChpcyhvLCBcImZpbml0ZVwiKSkge1xuICAgICAgICB2YXIgcm91bmQgPSBtYXRoLnJvdW5kO1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgW3JvdW5kKHIpLCByb3VuZChnKSwgcm91bmQoYiksICtvLnRvRml4ZWQoMildICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBcIiNcIiArICgxNjc3NzIxNiB8IGIgfCBnIDw8IDggfCByIDw8IDE2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59KTtcbnZhciB0b0hleCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBpID0gZ2xvYi5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGdsb2IuZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLFxuICAgICAgICByZWQgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvci50b0xvd2VyQ2FzZSgpID09IFwicmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IHJlZDtcbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB2YXIgb3V0ID0gZ2xvYi5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShpLCBFKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIik7XG4gICAgICAgIHJldHVybiBvdXQgPT0gcmVkID8gbnVsbCA6IG91dDtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9IZXgoY29sb3IpO1xufSxcbmhzYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzYihcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5iXSArIFwiKVwiO1xufSxcbmhzbHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzbChcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5sXSArIFwiKVwiO1xufSxcbnJnYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT0gMSB8fCB0aGlzLm9wYWNpdHkgPT0gbnVsbCA/XG4gICAgICAgICAgICB0aGlzLmhleCA6XG4gICAgICAgICAgICBcInJnYmEoXCIgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5vcGFjaXR5XSArIFwiKVwiO1xufSxcbnByZXBhcmVSR0IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGlmIChnID09IG51bGwgJiYgaXMociwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gciAmJiBcImdcIiBpbiByICYmIFwiYlwiIGluIHIpIHtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICB9XG4gICAgaWYgKGcgPT0gbnVsbCAmJiBpcyhyLCBzdHJpbmcpKSB7XG4gICAgICAgIHZhciBjbHIgPSBTbmFwLmdldFJHQihyKTtcbiAgICAgICAgciA9IGNsci5yO1xuICAgICAgICBnID0gY2xyLmc7XG4gICAgICAgIGIgPSBjbHIuYjtcbiAgICB9XG4gICAgaWYgKHIgPiAxIHx8IGcgPiAxIHx8IGIgPiAxKSB7XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn0sXG5wYWNrYWdlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICByID0gbWF0aC5yb3VuZChyICogMjU1KTtcbiAgICBnID0gbWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBiID0gbWF0aC5yb3VuZChiICogMjU1KTtcbiAgICB2YXIgcmdiID0ge1xuICAgICAgICByOiByLFxuICAgICAgICBnOiBnLFxuICAgICAgICBiOiBiLFxuICAgICAgICBvcGFjaXR5OiBpcyhvLCBcImZpbml0ZVwiKSA/IG8gOiAxLFxuICAgICAgICBoZXg6IFNuYXAucmdiKHIsIGcsIGIpLFxuICAgICAgICB0b1N0cmluZzogcmdidG9TdHJpbmdcbiAgICB9O1xuICAgIGlzKG8sIFwiZmluaXRlXCIpICYmIChyZ2Iub3BhY2l0eSA9IG8pO1xuICAgIHJldHVybiByZ2I7XG59O1xuLypcXFxuICogU25hcC5jb2xvclxuIFsgbWV0aG9kIF1cbiAqKlxuICogUGFyc2VzIHRoZSBjb2xvciBzdHJpbmcgYW5kIHJldHVybnMgYW4gb2JqZWN0IGZlYXR1cmluZyB0aGUgY29sb3IncyBjb21wb25lbnQgdmFsdWVzXG4gLSBjbHIgKHN0cmluZykgY29sb3Igc3RyaW5nIGluIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZvcm1hdHMgKHNlZSBAU25hcC5nZXRSR0IpXG4gPSAob2JqZWN0KSBDb21iaW5lZCBSR0IvSFNCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiLFxuIG8gICAgIGVycm9yIChib29sZWFuKSBgdHJ1ZWAgaWYgc3RyaW5nIGNhbid0IGJlIHBhcnNlZCxcbiBvICAgICBoIChudW1iZXIpIGh1ZSxcbiBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gbyAgICAgdiAobnVtYmVyKSB2YWx1ZSAoYnJpZ2h0bmVzcyksXG4gbyAgICAgbCAobnVtYmVyKSBsaWdodG5lc3NcbiBvIH1cblxcKi9cblNuYXAuY29sb3IgPSBmdW5jdGlvbiAoY2xyKSB7XG4gICAgdmFyIHJnYjtcbiAgICBpZiAoaXMoY2xyLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBjbHIgJiYgXCJzXCIgaW4gY2xyICYmIFwiYlwiIGluIGNscikge1xuICAgICAgICByZ2IgPSBTbmFwLmhzYjJyZ2IoY2xyKTtcbiAgICAgICAgY2xyLnIgPSByZ2IucjtcbiAgICAgICAgY2xyLmcgPSByZ2IuZztcbiAgICAgICAgY2xyLmIgPSByZ2IuYjtcbiAgICAgICAgY2xyLm9wYWNpdHkgPSAxO1xuICAgICAgICBjbHIuaGV4ID0gcmdiLmhleDtcbiAgICB9IGVsc2UgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImxcIiBpbiBjbHIpIHtcbiAgICAgICAgcmdiID0gU25hcC5oc2wycmdiKGNscik7XG4gICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgIGNsci5vcGFjaXR5ID0gMTtcbiAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzKGNsciwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNsciA9IFNuYXAuZ2V0UkdCKGNscik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gY2xyICYmIFwiZ1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIgJiYgIShcImVycm9yXCIgaW4gY2xyKSkge1xuICAgICAgICAgICAgcmdiID0gU25hcC5yZ2IyaHNsKGNscik7XG4gICAgICAgICAgICBjbHIuaCA9IHJnYi5oO1xuICAgICAgICAgICAgY2xyLnMgPSByZ2IucztcbiAgICAgICAgICAgIGNsci5sID0gcmdiLmw7XG4gICAgICAgICAgICByZ2IgPSBTbmFwLnJnYjJoc2IoY2xyKTtcbiAgICAgICAgICAgIGNsci52ID0gcmdiLmI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHIgPSB7aGV4OiBcIm5vbmVcIn07XG4gICAgICAgICAgICBjbHIuciA9IGNsci5nID0gY2xyLmIgPSBjbHIuaCA9IGNsci5zID0gY2xyLnYgPSBjbHIubCA9IC0xO1xuICAgICAgICAgICAgY2xyLmVycm9yID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbHIudG9TdHJpbmcgPSByZ2J0b1N0cmluZztcbiAgICByZXR1cm4gY2xyO1xufTtcbi8qXFxcbiAqIFNuYXAuaHNiMnJnYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNCIHZhbHVlcyB0byBhbiBSR0Igb2JqZWN0XG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSB2IChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAolxuIG8gfVxuXFwqL1xuU25hcC5oc2IycmdiID0gZnVuY3Rpb24gKGgsIHMsIHYsIG8pIHtcbiAgICBpZiAoaXMoaCwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gaCAmJiBcInNcIiBpbiBoICYmIFwiYlwiIGluIGgpIHtcbiAgICAgICAgdiA9IGguYjtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgbyA9IGgubztcbiAgICAgICAgaCA9IGguaDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gdiAqIHM7XG4gICAgWCA9IEMgKiAoMSAtIGFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5oc2wycmdiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGFuIFJHQiBvYmplY3RcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiXG4gbyB9XG5cXCovXG5TbmFwLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCwgbykge1xuICAgIGlmIChpcyhoLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJsXCIgaW4gaCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIHMgLz0gMTAwO1xuICAgICAgICBsIC89IDEwMDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gMiAqIHMgKiAobCA8IC41ID8gbCA6IDEgLSBsKTtcbiAgICBYID0gQyAqICgxIC0gYWJzKGggJSAyIC0gMSkpO1xuICAgIFIgPSBHID0gQiA9IGwgLSBDIC8gMjtcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTQiBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGIgKG51bWJlcikgYnJpZ2h0bmVzc1xuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNiID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBWLCBDO1xuICAgIFYgPSBtbWF4KHIsIGcsIGIpO1xuICAgIEMgPSBWIC0gbW1pbihyLCBnLCBiKTtcbiAgICBIID0gQyA9PSAwID8gbnVsbCA6XG4gICAgICAgIFYgPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgViA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0O1xuICAgIEggPSAoSCArIDM2MCkgJSA2ICogNjAgLyAzNjA7XG4gICAgUyA9IEMgPT0gMCA/IDAgOiBDIC8gVjtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGI6IFYsIHRvU3RyaW5nOiBoc2J0b1N0cmluZ307XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTTCBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTTCBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNsID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBMLCBNLCBtLCBDO1xuICAgIE0gPSBtbWF4KHIsIGcsIGIpO1xuICAgIG0gPSBtbWluKHIsIGcsIGIpO1xuICAgIEMgPSBNIC0gbTtcbiAgICBIID0gQyA9PSAwID8gbnVsbCA6XG4gICAgICAgIE0gPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgTSA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0O1xuICAgIEggPSAoSCArIDM2MCkgJSA2ICogNjAgLyAzNjA7XG4gICAgTCA9IChNICsgbSkgLyAyO1xuICAgIFMgPSBDID09IDAgPyAwIDpcbiAgICAgICAgIEwgPCAuNSA/IEMgLyAoMiAqIEwpIDpcbiAgICAgICAgICAgICAgICAgIEMgLyAoMiAtIDIgKiBMKTtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGw6IEwsIHRvU3RyaW5nOiBoc2x0b1N0cmluZ307XG59O1xuXG4vLyBUcmFuc2Zvcm1hdGlvbnNcbi8qXFxcbiAqIFNuYXAucGFyc2VQYXRoU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgcGF0aCBzZWdtZW50c1xuIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50cyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuXFwqL1xuU25hcC5wYXJzZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgIGlmICghcGF0aFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHB0aCA9IFNuYXAucGF0aChwYXRoU3RyaW5nKTtcbiAgICBpZiAocHRoLmFycikge1xuICAgICAgICByZXR1cm4gU25hcC5wYXRoLmNsb25lKHB0aC5hcnIpO1xuICAgIH1cblxuICAgIHZhciBwYXJhbUNvdW50cyA9IHthOiA3LCBjOiA2LCBvOiAyLCBoOiAxLCBsOiAyLCBtOiAyLCByOiA0LCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB1OiAzLCB6OiAwfSxcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgIGlmIChpcyhwYXRoU3RyaW5nLCBcImFycmF5XCIpICYmIGlzKHBhdGhTdHJpbmdbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICBkYXRhID0gU25hcC5wYXRoLmNsb25lKHBhdGhTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIFN0cihwYXRoU3RyaW5nKS5yZXBsYWNlKHBhdGhDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJtXCIgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwibFwiO1xuICAgICAgICAgICAgICAgIGIgPSBiID09IFwibVwiID8gXCJsXCIgOiBcIkxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09IFwib1wiICYmIHBhcmFtcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYiwgcGFyYW1zWzBdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInJcIikge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICAgICAgfSBlbHNlIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCBwYXJhbUNvdW50c1tuYW1lXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudG9TdHJpbmcgPSBTbmFwLnBhdGgudG9TdHJpbmc7XG4gICAgcHRoLmFyciA9IFNuYXAucGF0aC5jbG9uZShkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG4vKlxcXG4gKiBTbmFwLnBhcnNlVHJhbnNmb3JtU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gdHJhbnNmb3JtIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuIC0gVFN0cmluZyAoc3RyaW5nfGFycmF5KSB0cmFuc2Zvcm0gc3RyaW5nIG9yIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9ucyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcblxcKi9cbnZhciBwYXJzZVRyYW5zZm9ybVN0cmluZyA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiAoVFN0cmluZykge1xuICAgIGlmICghVFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHBhcmFtQ291bnRzID0ge3I6IDMsIHM6IDQsIHQ6IDIsIG06IDZ9LFxuICAgICAgICBkYXRhID0gW107XG4gICAgaWYgKGlzKFRTdHJpbmcsIFwiYXJyYXlcIikgJiYgaXMoVFN0cmluZ1swXSwgXCJhcnJheVwiKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgIGRhdGEgPSBTbmFwLnBhdGguY2xvbmUoVFN0cmluZyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgU3RyKFRTdHJpbmcpLnJlcGxhY2UodENvbW1hbmQsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudG9TdHJpbmcgPSBTbmFwLnBhdGgudG9TdHJpbmc7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuZnVuY3Rpb24gc3ZnVHJhbnNmb3JtMnN0cmluZyh0c3RyKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHRzdHIgPSB0c3RyLnJlcGxhY2UoLyg/Ol58XFxzKShcXHcrKVxcKChbXildKylcXCkvZywgZnVuY3Rpb24gKGFsbCwgbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJyb3RhdGVcIiAmJiBwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbXNbMF0sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2tld1hcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCAwLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwic2tld1lcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDAsIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtuYW1lLmNoYXJBdCgwKV0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cblNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nID0gc3ZnVHJhbnNmb3JtMnN0cmluZztcblNuYXAuXy5yZ1RyYW5zZm9ybSA9IC9eW2Etel1bXFxzXSotP1xcLj9cXGQvaTtcbmZ1bmN0aW9uIHRyYW5zZm9ybTJtYXRyaXgodHN0ciwgYmJveCkge1xuICAgIHZhciB0ZGF0YSA9IHBhcnNlVHJhbnNmb3JtU3RyaW5nKHRzdHIpLFxuICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4O1xuICAgIGlmICh0ZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRkYXRhW2ldLFxuICAgICAgICAgICAgICAgIHRsZW4gPSB0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjb21tYW5kID0gU3RyKHRbMF0pLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgYWJzb2x1dGUgPSB0WzBdICE9IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgaW52ZXIgPSBhYnNvbHV0ZSA/IG0uaW52ZXJ0KCkgOiAwLFxuICAgICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgICAgIGJiO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gXCJ0XCIgJiYgdGxlbiA9PSAyKXtcbiAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcInRcIiAmJiB0bGVuID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBpbnZlci54KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGludmVyLnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJiID0gYmIgfHwgYmJveDtcbiAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgYmIueCArIGJiLndpZHRoIC8gMiwgYmIueSArIGJiLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwic1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRsZW4gPT0gMiB8fCB0bGVuID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBiYm94O1xuICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbdGxlbiAtIDFdLCBiYi54ICsgYmIud2lkdGggLyAyLCBiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMV0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwibVwiICYmIHRsZW4gPT0gNykge1xuICAgICAgICAgICAgICAgIG0uYWRkKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0sIHRbNl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xufVxuU25hcC5fLnRyYW5zZm9ybTJtYXRyaXggPSB0cmFuc2Zvcm0ybWF0cml4O1xuU25hcC5fdW5pdDJweCA9IHVuaXQycHg7XG52YXIgY29udGFpbnMgPSBnbG9iLmRvYy5jb250YWlucyB8fCBnbG9iLmRvYy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gYSA9PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PSAxICYmIChcbiAgICAgICAgICAgICAgICBhZG93bi5jb250YWlucyA/XG4gICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKGJ1cCkgOlxuICAgICAgICAgICAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2XG4gICAgICAgICAgICApKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgd2hpbGUgKGIpIHtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChiID09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuZnVuY3Rpb24gZ2V0U29tZURlZnMoZWwpIHtcbiAgICB2YXIgcCA9IGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8XG4gICAgICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUgJiYgd3JhcChlbC5ub2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICBTbmFwLnNlbGVjdChcInN2Z1wiKSB8fFxuICAgICAgICAgICAgU25hcCgwLCAwKSxcbiAgICAgICAgcGRlZnMgPSBwLnNlbGVjdChcImRlZnNcIiksXG4gICAgICAgIGRlZnMgID0gcGRlZnMgPT0gbnVsbCA/IGZhbHNlIDogcGRlZnMubm9kZTtcbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgZGVmcyA9IG1ha2UoXCJkZWZzXCIsIHAubm9kZSkubm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZnM7XG59XG5mdW5jdGlvbiBnZXRTb21lU1ZHKGVsKSB7XG4gICAgcmV0dXJuIGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8IFNuYXAuc2VsZWN0KFwic3ZnXCIpO1xufVxuU25hcC5fLmdldFNvbWVEZWZzID0gZ2V0U29tZURlZnM7XG5TbmFwLl8uZ2V0U29tZVNWRyA9IGdldFNvbWVTVkc7XG5mdW5jdGlvbiB1bml0MnB4KGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBzdmcgPSBnZXRTb21lU1ZHKGVsKS5ub2RlLFxuICAgICAgICBvdXQgPSB7fSxcbiAgICAgICAgbWdyID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoXCIuc3ZnLS0tbWdyXCIpO1xuICAgIGlmICghbWdyKSB7XG4gICAgICAgIG1nciA9ICQoXCJyZWN0XCIpO1xuICAgICAgICAkKG1nciwge3g6IC05ZTksIHk6IC05ZTksIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMCwgXCJjbGFzc1wiOiBcInN2Zy0tLW1nclwiLCBmaWxsOiBcIm5vbmVcIn0pO1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQobWdyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vyh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHt3aWR0aDogdmFsfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbWdyLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHtoZWlnaHQ6IHZhbH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1nci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQobmFtLCBmKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dFtuYW1dID0gZihlbC5hdHRyKG5hbSkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtID09IG5hbWUpIHtcbiAgICAgICAgICAgIG91dCA9IGYodmFsdWUgPT0gbnVsbCA/IGVsLmF0dHIobmFtKSB8fCAwIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgc2V0KFwicnhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyeVwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICBzZXQoXCJ3aWR0aFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImhlaWdodFwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHNldChcInhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJcIiwgZ2V0Vyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJ4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwicnlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgc2V0KFwieDFcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ4MlwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInkxXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwieTJcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFya2VyXCI6XG4gICAgICAgICAgICBzZXQoXCJyZWZYXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VyV2lkdGhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyZWZZXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VySGVpZ2h0XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJhZGlhbEdyYWRpZW50XCI6XG4gICAgICAgICAgICBzZXQoXCJmeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImZ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRzcGFuXCI6XG4gICAgICAgICAgICBzZXQoXCJkeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImR5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldChuYW1lLCBnZXRXKTtcbiAgICB9XG4gICAgc3ZnLnJlbW92ZUNoaWxkKG1ncik7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qXFxcbiAqIFNuYXAuc2VsZWN0XG4gWyBtZXRob2QgXVxuICoqXG4gKiBXcmFwcyBhIERPTSBlbGVtZW50IHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgQEVsZW1lbnRcbiAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvciBvZiB0aGUgZWxlbWVudFxuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcblxcKi9cblNuYXAuc2VsZWN0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBTdHIocXVlcnkpLnJlcGxhY2UoLyhbXlxcXFxdKTovZywgXCIkMVxcXFw6XCIpO1xuICAgIHJldHVybiB3cmFwKGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbn07XG4vKlxcXG4gKiBTbmFwLnNlbGVjdEFsbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogV3JhcHMgRE9NIGVsZW1lbnRzIHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgc2V0IG9yIGFycmF5IG9mIEBFbGVtZW50XG4gLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnRcbiA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG5cXCovXG5TbmFwLnNlbGVjdEFsbCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBub2RlbGlzdCA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICBzZXQgPSAoU25hcC5zZXQgfHwgQXJyYXkpKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59O1xuXG5mdW5jdGlvbiBhZGQyZ3JvdXAobGlzdCkge1xuICAgIGlmICghaXMobGlzdCwgXCJhcnJheVwiKSkge1xuICAgICAgICBsaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZTtcbiAgICB3aGlsZSAodGhpc1tpXSkgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIGxpc3RbaV0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGVsLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2orK10gPSB3cmFwKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vLyBIdWIgZ2FyYmFnZSBjb2xsZWN0b3IgZXZlcnkgMTBzXG5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGh1YikgaWYgKGh1YltoYXNdKGtleSkpIHtcbiAgICAgICAgdmFyIGVsID0gaHViW2tleV0sXG4gICAgICAgICAgICBub2RlID0gZWwubm9kZTtcbiAgICAgICAgaWYgKGVsLnR5cGUgIT0gXCJzdmdcIiAmJiAhbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgZWwudHlwZSA9PSBcInN2Z1wiICYmICghbm9kZS5wYXJlbnROb2RlIHx8IFwib3duZXJTVkdFbGVtZW50XCIgaW4gbm9kZS5wYXJlbnROb2RlICYmICFub2RlLm93bmVyU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBodWJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn0sIDFlNCk7XG5mdW5jdGlvbiBFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnNuYXAgaW4gaHViKSB7XG4gICAgICAgIHJldHVybiBodWJbZWwuc25hcF07XG4gICAgfVxuICAgIHZhciBzdmc7XG4gICAgdHJ5IHtcbiAgICAgICAgc3ZnID0gZWwub3duZXJTVkdFbGVtZW50O1xuICAgIH0gY2F0Y2goZSkge31cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5ub2RlXG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIEdpdmVzIHlvdSBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIG9iamVjdCwgc28geW91IGNhbiBhc3NpZ24gZXZlbnQgaGFuZGxlcnMgb3IganVzdCBtZXNzIGFyb3VuZC5cbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGRyYXcgYSBjaXJjbGUgYXQgY29vcmRpbmF0ZSAxMCwxMCB3aXRoIHJhZGl1cyBvZiAxMFxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApO1xuICAgICB8IGMubm9kZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICBjLmF0dHIoXCJmaWxsXCIsIFwicmVkXCIpO1xuICAgICB8IH07XG4gICAgXFwqL1xuICAgIHRoaXMubm9kZSA9IGVsO1xuICAgIGlmIChzdmcpIHtcbiAgICAgICAgdGhpcy5wYXBlciA9IG5ldyBQYXBlcihzdmcpO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50eXBlXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIFNWRyB0YWcgbmFtZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICBcXCovXG4gICAgdGhpcy50eXBlID0gZWwudGFnTmFtZSB8fCBlbC5ub2RlTmFtZTtcbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gSUQodGhpcyk7XG4gICAgdGhpcy5hbmltcyA9IHt9O1xuICAgIHRoaXMuXyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgIH07XG4gICAgZWwuc25hcCA9IGlkO1xuICAgIGh1YltpZF0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJnXCIpIHtcbiAgICAgICAgdGhpcy5hZGQgPSBhZGQyZ3JvdXA7XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgaW4ge2c6IDEsIG1hc2s6IDEsIHBhdHRlcm46IDEsIHN5bWJvbDogMX0pIHtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIFBhcGVyLnByb3RvdHlwZSkgaWYgKFBhcGVyLnByb3RvdHlwZVtoYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IFBhcGVyLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxufVxuICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXR0clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2V0cyBvciBzZXRzIGdpdmVuIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXG4gICAgICoqXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHNldFxuICAgICAqIG9yXG4gICAgIC0gcGFyYW0gKHN0cmluZykgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChzdHJpbmcpIHZhbHVlIG9mIGF0dHJpYnV0ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IFwiI2ZjMFwiLFxuICAgICB8ICAgICBzdHJva2U6IFwiIzAwMFwiLFxuICAgICB8ICAgICBzdHJva2VXaWR0aDogMiwgLy8gQ2FtZWxDYXNlLi4uXG4gICAgIHwgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAuNSwgLy8gb3IgZGFzaC1zZXBhcmF0ZWQgbmFtZXNcbiAgICAgfCAgICAgd2lkdGg6IFwiKj0yXCIgLy8gcHJlZml4ZWQgdmFsdWVzXG4gICAgIHwgfSk7XG4gICAgIHwgY29uc29sZS5sb2coZWwuYXR0cihcImZpbGxcIikpOyAvLyAjZmMwXG4gICAgICogUHJlZml4ZWQgdmFsdWVzIGluIGZvcm1hdCBgXCIrPTEwXCJgIHN1cHBvcnRlZC4gQWxsIGZvdXIgb3BlcmF0aW9uc1xuICAgICAqIChgK2AsIGAtYCwgYCpgIGFuZCBgL2ApIGNvdWxkIGJlIHVzZWQuIE9wdGlvbmFsbHkgeW91IGNhbiB1c2UgdW5pdHMgZm9yIGArYFxuICAgICAqIGFuZCBgLWA6IGBcIis9MmVtXCJgLlxuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBlbC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5vZGUubm9kZVZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXR0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2F0dHJbaV0ubm9kZU5hbWVdID0gYXR0cltpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhwYXJhbXMsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGpzb25bcGFyYW1zXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGpzb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5cIiArIHBhcmFtcywgZWwpLmZpcnN0RGVmaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGF0dCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgZXZlKFwic25hcC51dGlsLmF0dHIuXCIgKyBhdHQsIGVsLCBwYXJhbXNbYXR0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4vKlxcXG4gKiBTbmFwLnBhcnNlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgU1ZHIGZyYWdtZW50IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgQEZyYWdtZW50XG4gKipcbiAtIHN2ZyAoc3RyaW5nKSBTVkcgc3RyaW5nXG4gPSAoRnJhZ21lbnQpIHRoZSBARnJhZ21lbnRcblxcKi9cblNuYXAucGFyc2UgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGZ1bGwgPSB0cnVlLFxuICAgICAgICBkaXYgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN2ZyA9IFN0cihzdmcpO1xuICAgIGlmICghc3ZnLm1hdGNoKC9eXFxzKjxcXHMqc3ZnKD86XFxzfD4pLykpIHtcbiAgICAgICAgc3ZnID0gXCI8c3ZnPlwiICsgc3ZnICsgXCI8L3N2Zz5cIjtcbiAgICAgICAgZnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXYuaW5uZXJIVE1MID0gc3ZnO1xuICAgIHN2ZyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICBpZiAoc3ZnKSB7XG4gICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICBmID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChmKTtcbn07XG5mdW5jdGlvbiBGcmFnbWVudChmcmFnKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZztcbn1cbi8qXFxcbiAqIFNuYXAuZnJhZ21lbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBET00gZnJhZ21lbnQgZnJvbSBhIGdpdmVuIGxpc3Qgb2YgZWxlbWVudHMgb3Igc3RyaW5nc1xuICoqXG4gLSB2YXJhcmdzICjigKYpIFNWRyBzdHJpbmdcbiA9IChGcmFnbWVudCkgdGhlIEBGcmFnbWVudFxuXFwqL1xuU25hcC5mcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0ubm9kZSAmJiBpdGVtLm5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoaXRlbS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChTbmFwLnBhcnNlKGl0ZW0pLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoZik7XG59O1xuXG5mdW5jdGlvbiBtYWtlKG5hbWUsIHBhcmVudCkge1xuICAgIHZhciByZXMgPSAkKG5hbWUpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZXMpO1xuICAgIHZhciBlbCA9IHdyYXAocmVzKTtcbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBQYXBlcih3LCBoKSB7XG4gICAgdmFyIHJlcyxcbiAgICAgICAgZGVzYyxcbiAgICAgICAgZGVmcyxcbiAgICAgICAgcHJvdG8gPSBQYXBlci5wcm90b3R5cGU7XG4gICAgaWYgKHcgJiYgdy50YWdOYW1lICYmIHcudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgaWYgKHcuc25hcCBpbiBodWIpIHtcbiAgICAgICAgICAgIHJldHVybiBodWJbdy5zbmFwXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gdy5vd25lckRvY3VtZW50O1xuICAgICAgICByZXMgPSBuZXcgRWxlbWVudCh3KTtcbiAgICAgICAgZGVzYyA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkZXNjXCIpWzBdO1xuICAgICAgICBkZWZzID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlZnNcIilbMF07XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgZGVzYyA9ICQoXCJkZXNjXCIpO1xuICAgICAgICAgICAgZGVzYy5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggU25hcFwiKSk7XG4gICAgICAgICAgICByZXMubm9kZS5hcHBlbmRDaGlsZChkZXNjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgICAgIGRlZnMgPSAkKFwiZGVmc1wiKTtcbiAgICAgICAgICAgIHJlcy5ub2RlLmFwcGVuZENoaWxkKGRlZnMpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5kZWZzID0gZGVmcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3RvKSBpZiAocHJvdG9baGFzXShrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnBhcGVyID0gcmVzLnJvb3QgPSByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gbWFrZShcInN2Z1wiLCBnbG9iLmRvYy5ib2R5KTtcbiAgICAgICAgJChyZXMubm9kZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgdmVyc2lvbjogMS4xLFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICB4bWxuczogeG1sbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwKGRvbSkge1xuICAgIGlmICghZG9tKSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGRvbSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20udGFnTmFtZSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXBlcihkb20pO1xuICAgIH1cbiAgICBpZiAoZG9tLnRhZ05hbWUgJiYgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm9iamVjdFwiICYmIGRvbS50eXBlID09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFwZXIoZG9tLmNvbnRlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudChkb20pO1xufVxuXG5TbmFwLl8ubWFrZSA9IG1ha2U7XG5TbmFwLl8ud3JhcCA9IHdyYXA7XG4vKlxcXG4gKiBQYXBlci5lbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IG9uIHBhcGVyIHdpdGggYSBnaXZlbiBuYW1lIGFuZCBubyBhdHRyaWJ1dGVzXG4gKipcbiAtIG5hbWUgKHN0cmluZykgdGFnIG5hbWVcbiAtIGF0dHIgKG9iamVjdCkgYXR0cmlidXRlc1xuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiA+IFVzYWdlXG4gfCB2YXIgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKTsgLy8gaXMgdGhlIHNhbWUgYXMuLi5cbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIikuYXR0cih7XG4gfCAgICAgY3g6IDEwLFxuIHwgICAgIGN5OiAxMCxcbiB8ICAgICByOiAxMFxuIHwgfSk7XG4gfCAvLyBhbmQgdGhlIHNhbWUgYXNcbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIiwge1xuIHwgICAgIGN4OiAxMCxcbiB8ICAgICBjeTogMTAsXG4gfCAgICAgcjogMTBcbiB8IH0pO1xuXFwqL1xuUGFwZXIucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gKG5hbWUsIGF0dHIpIHtcbiAgICB2YXIgZWwgPSBtYWtlKG5hbWUsIHRoaXMubm9kZSk7XG4gICAgYXR0ciAmJiBlbC5hdHRyKGF0dHIpO1xuICAgIHJldHVybiBlbDtcbn07XG4vKlxcXG4gKiBFbGVtZW50LmNoaWxkcmVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gPSAoYXJyYXkpIGFycmF5IG9mIEVsZW1lbnRzXG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGNoID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBTbmFwKGNoW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5mdW5jdGlvbiBqc29uRmlsbGVyKHJvb3QsIG8pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb290Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcm9vdFtpXS50eXBlLFxuICAgICAgICAgICAgICAgIGF0dHI6IHJvb3RbaV0uYXR0cigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW4gPSByb290W2ldLmNoaWxkcmVuKCk7XG4gICAgICAgIG8ucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAganNvbkZpbGxlcihjaGlsZHJlbiwgaXRlbS5jaGlsZE5vZGVzID0gW10pO1xuICAgICAgICB9XG4gICAgfVxufVxuLypcXFxuICogRWxlbWVudC50b0pTT05cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLlxuID0gKG9iamVjdCkgaW4gZm9ybWF0XG4gbyB7XG4gbyAgICAgdHlwZSAoc3RyaW5nKSB0aGlzLnR5cGUsXG4gbyAgICAgYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzIG1hcCxcbiBvICAgICBjaGlsZE5vZGVzIChhcnJheSkgb3B0aW9uYWwgYXJyYXkgb2YgY2hpbGRyZW4gaW4gdGhlIHNhbWUgZm9ybWF0XG4gbyB9XG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGpzb25GaWxsZXIoW3RoaXNdLCBvdXQpO1xuICAgIHJldHVybiBvdXRbMF07XG59O1xuLy8gZGVmYXVsdFxuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKTtcbiAgICBhdHQgPSBhdHQuc3Vic3RyaW5nKGF0dC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICB2YXIgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgaWYgKGNzc0F0dHJbaGFzXShjc3MpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShjc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMubm9kZSwgYXR0KTtcbiAgICB9XG59KTtcbnZhciBjc3NBdHRyID0ge1xuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiOiAwLFxuICAgIFwiY2xpcFwiOiAwLFxuICAgIFwiY2xpcC1wYXRoXCI6IDAsXG4gICAgXCJjbGlwLXJ1bGVcIjogMCxcbiAgICBcImNvbG9yXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogMCxcbiAgICBcImNvbG9yLXByb2ZpbGVcIjogMCxcbiAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwiY3Vyc29yXCI6IDAsXG4gICAgXCJkaXJlY3Rpb25cIjogMCxcbiAgICBcImRpc3BsYXlcIjogMCxcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiAwLFxuICAgIFwiZmlsbFwiOiAwLFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAsXG4gICAgXCJmaWxsLXJ1bGVcIjogMCxcbiAgICBcImZpbHRlclwiOiAwLFxuICAgIFwiZmxvb2QtY29sb3JcIjogMCxcbiAgICBcImZsb29kLW9wYWNpdHlcIjogMCxcbiAgICBcImZvbnRcIjogMCxcbiAgICBcImZvbnQtZmFtaWx5XCI6IDAsXG4gICAgXCJmb250LXNpemVcIjogMCxcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogMCxcbiAgICBcImZvbnQtc3RyZXRjaFwiOiAwLFxuICAgIFwiZm9udC1zdHlsZVwiOiAwLFxuICAgIFwiZm9udC12YXJpYW50XCI6IDAsXG4gICAgXCJmb250LXdlaWdodFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogMCxcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwia2VybmluZ1wiOiAwLFxuICAgIFwibGV0dGVyLXNwYWNpbmdcIjogMCxcbiAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IDAsXG4gICAgXCJtYXJrZXJcIjogMCxcbiAgICBcIm1hcmtlci1lbmRcIjogMCxcbiAgICBcIm1hcmtlci1taWRcIjogMCxcbiAgICBcIm1hcmtlci1zdGFydFwiOiAwLFxuICAgIFwibWFza1wiOiAwLFxuICAgIFwib3BhY2l0eVwiOiAwLFxuICAgIFwib3ZlcmZsb3dcIjogMCxcbiAgICBcInBvaW50ZXItZXZlbnRzXCI6IDAsXG4gICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogMCxcbiAgICBcInN0b3AtY29sb3JcIjogMCxcbiAgICBcInN0b3Atb3BhY2l0eVwiOiAwLFxuICAgIFwic3Ryb2tlXCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiAwLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogMCxcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiAwLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMCxcbiAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDAsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogMCxcbiAgICBcInRleHQtYW5jaG9yXCI6IDAsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogMCxcbiAgICBcInRleHQtcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJ1bmljb2RlLWJpZGlcIjogMCxcbiAgICBcInZpc2liaWxpdHlcIjogMCxcbiAgICBcIndvcmQtc3BhY2luZ1wiOiAwLFxuICAgIFwid3JpdGluZy1tb2RlXCI6IDBcbn07XG5cbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKSxcbiAgICAgICAgYXR0ciA9IHt9O1xuICAgIGF0dCA9IGF0dC5zdWJzdHJpbmcoYXR0Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGF0dHJbYXR0XSA9IHZhbHVlO1xuICAgIHZhciBzdHlsZSA9IGF0dC5yZXBsYWNlKC8tKFxcdykvZ2ksIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICBpZiAoY3NzQXR0cltoYXNdKGNzcykpIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3N0eWxlXSA9IHZhbHVlID09IG51bGwgPyBFIDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzLm5vZGUsIGF0dHIpO1xuICAgIH1cbn0pO1xuKGZ1bmN0aW9uIChwcm90bykge30oUGFwZXIucHJvdG90eXBlKSk7XG5cbi8vIHNpbXBsZSBhamF4XG4vKlxcXG4gKiBTbmFwLmFqYXhcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBBamF4XG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIHBvc3REYXRhIChvYmplY3R8c3RyaW5nKSBkYXRhIGZvciBwb3N0IHJlcXVlc3RcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuICogb3JcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuID0gKFhNTEh0dHBSZXF1ZXN0KSB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LCBqdXN0IGluIGNhc2VcblxcKi9cblNuYXAuYWpheCA9IGZ1bmN0aW9uICh1cmwsIHBvc3REYXRhLCBjYWxsYmFjaywgc2NvcGUpe1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QsXG4gICAgICAgIGlkID0gSUQoKTtcbiAgICBpZiAocmVxKSB7XG4gICAgICAgIGlmIChpcyhwb3N0RGF0YSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgc2NvcGUgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcG9zdERhdGE7XG4gICAgICAgICAgICBwb3N0RGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMocG9zdERhdGEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgcGQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwb3N0RGF0YSkgaWYgKHBvc3REYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocG9zdERhdGFba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdERhdGEgPSBwZC5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub3Blbihwb3N0RGF0YSA/IFwiUE9TVFwiIDogXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKHBvc3REYXRhKSB7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjBcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjIwMFwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBldmUub25jZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuMzA0XCIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xuICAgICAgICAgICAgZXZlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi5cIiArIHJlcS5zdGF0dXMsIHNjb3BlLCByZXEpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZChwb3N0RGF0YSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxufTtcbi8qXFxcbiAqIFNuYXAubG9hZFxuIFsgbWV0aG9kIF1cbiAqKlxuICogTG9hZHMgZXh0ZXJuYWwgU1ZHIGZpbGUgYXMgYSBARnJhZ21lbnQgKHNlZSBAU25hcC5hamF4IGZvciBtb3JlIGFkdmFuY2VkIEFKQVgpXG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuXFwqL1xuU25hcC5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgU25hcC5hamF4KHVybCwgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgZiA9IFNuYXAucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNjb3BlID8gY2FsbGJhY2suY2FsbChzY29wZSwgZikgOiBjYWxsYmFjayhmKTtcbiAgICB9KTtcbn07XG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLCBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLFxuICAgICAgICB0b3AgID0gYm94LnRvcCAgKyAoZy53aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3AgKSAtIGNsaWVudFRvcCxcbiAgICAgICAgbGVmdCA9IGJveC5sZWZ0ICsgKGcud2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gY2xpZW50TGVmdDtcbiAgICByZXR1cm4ge1xuICAgICAgICB5OiB0b3AsXG4gICAgICAgIHg6IGxlZnRcbiAgICB9O1xufTtcbi8qXFxcbiAqIFNuYXAuZ2V0RWxlbWVudEJ5UG9pbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgeW91IHRvcG1vc3QgZWxlbWVudCB1bmRlciBnaXZlbiBwb2ludC5cbiAqKlxuID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdFxuIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3dcbiAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gPiBVc2FnZVxuIHwgU25hcC5nZXRFbGVtZW50QnlQb2ludChtb3VzZVgsIG1vdXNlWSkuYXR0cih7c3Ryb2tlOiBcIiNmMDBcIn0pO1xuXFwqL1xuU25hcC5nZXRFbGVtZW50QnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHBhcGVyID0gdGhpcyxcbiAgICAgICAgc3ZnID0gcGFwZXIuY2FudmFzLFxuICAgICAgICB0YXJnZXQgPSBnbG9iLmRvYy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChnbG9iLndpbi5vcGVyYSAmJiB0YXJnZXQudGFnTmFtZSA9PSBcInN2Z1wiKSB7XG4gICAgICAgIHZhciBzbyA9IGdldE9mZnNldCh0YXJnZXQpLFxuICAgICAgICAgICAgc3IgPSB0YXJnZXQuY3JlYXRlU1ZHUmVjdCgpO1xuICAgICAgICBzci54ID0geCAtIHNvLng7XG4gICAgICAgIHNyLnkgPSB5IC0gc28ueTtcbiAgICAgICAgc3Iud2lkdGggPSBzci5oZWlnaHQgPSAxO1xuICAgICAgICB2YXIgaGl0cyA9IHRhcmdldC5nZXRJbnRlcnNlY3Rpb25MaXN0KHNyLCBudWxsKTtcbiAgICAgICAgaWYgKGhpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBoaXRzW2hpdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHRhcmdldCk7XG59O1xuLypcXFxuICogU25hcC5wbHVnaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIExldCB5b3Ugd3JpdGUgcGx1Z2lucy4gWW91IHBhc3MgaW4gYSBmdW5jdGlvbiB3aXRoIGZpdmUgYXJndW1lbnRzLCBsaWtlIHRoaXM6XG4gfCBTbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2JhbCwgRnJhZ21lbnQpIHtcbiB8ICAgICBTbmFwLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgICAgIEVsZW1lbnQucHJvdG90eXBlLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgICAgIFBhcGVyLnByb3RvdHlwZS5uZXdtZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcbiB8IH0pO1xuICogSW5zaWRlIHRoZSBmdW5jdGlvbiB5b3UgaGF2ZSBhY2Nlc3MgdG8gYWxsIG1haW4gb2JqZWN0cyAoYW5kIHRoZWlyXG4gKiBwcm90b3R5cGVzKS4gVGhpcyBhbGxvdyB5b3UgdG8gZXh0ZW5kIGFueXRoaW5nIHlvdSB3YW50LlxuICoqXG4gLSBmIChmdW5jdGlvbikgeW91ciBwbHVnaW4gYm9keVxuXFwqL1xuU25hcC5wbHVnaW4gPSBmdW5jdGlvbiAoZikge1xuICAgIGYoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KTtcbn07XG5nbG9iLndpbi5TbmFwID0gU25hcDtcbnJldHVybiBTbmFwO1xufSh3aW5kb3cgfHwgdGhpcykpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHVuaXQycHggPSBTbmFwLl91bml0MnB4LFxuICAgICAgICAkID0gU25hcC5fLiQsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgZ2V0U29tZURlZnMgPSBTbmFwLl8uZ2V0U29tZURlZnMsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBkZXNjcmlwdG9yIGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveCBkZXNjcmlwdG9yOlxuICAgICBvIHtcbiAgICAgbyAgICAgY3g6IChudW1iZXIpIHggb2YgdGhlIGNlbnRlcixcbiAgICAgbyAgICAgY3k6IChudW1iZXIpIHggb2YgdGhlIGNlbnRlcixcbiAgICAgbyAgICAgaDogKG51bWJlcikgaGVpZ2h0LFxuICAgICBvICAgICBoZWlnaHQ6IChudW1iZXIpIGhlaWdodCxcbiAgICAgbyAgICAgcGF0aDogKHN0cmluZykgcGF0aCBjb21tYW5kIGZvciB0aGUgYm94LFxuICAgICBvICAgICByMDogKG51bWJlcikgcmFkaXVzIG9mIGEgY2lyY2xlIHRoYXQgZnVsbHkgZW5jbG9zZXMgdGhlIGJveCxcbiAgICAgbyAgICAgcjE6IChudW1iZXIpIHJhZGl1cyBvZiB0aGUgc21hbGxlc3QgY2lyY2xlIHRoYXQgY2FuIGJlIGVuY2xvc2VkLFxuICAgICBvICAgICByMjogKG51bWJlcikgcmFkaXVzIG9mIHRoZSBsYXJnZXN0IGNpcmNsZSB0aGF0IGNhbiBiZSBlbmNsb3NlZCxcbiAgICAgbyAgICAgdmI6IChzdHJpbmcpIGJveCBhcyBhIHZpZXdib3ggY29tbWFuZCxcbiAgICAgbyAgICAgdzogKG51bWJlcikgd2lkdGgsXG4gICAgIG8gICAgIHdpZHRoOiAobnVtYmVyKSB3aWR0aCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggb2YgdGhlIHJpZ2h0IHNpZGUsXG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggb2YgdGhlIGxlZnQgc2lkZSxcbiAgICAgbyAgICAgeTI6IChudW1iZXIpIHkgb2YgdGhlIGJvdHRvbSBlZGdlLFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IG9mIHRoZSB0b3AgZWRnZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKGlzV2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3godGhpcy5ub2RlLmdldENsaWVudFJlY3RzKCkuaXRlbSgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFTbmFwLk1hdHJpeCB8fCAhU25hcC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgbSA9IG5ldyBTbmFwLk1hdHJpeDtcbiAgICAgICAgaWYgKGVsLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVsLnR5cGUgPT0gXCJ1c2VcIikge1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtID0gbS5hZGQoZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXgudHJhbnNsYXRlKGVsLmF0dHIoXCJ4XCIpIHx8IDAsIGVsLmF0dHIoXCJ5XCIpIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIGVsID0gZWwub3JpZ2luYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gZWwuYXR0cihcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5vcmlnaW5hbCA9IGVsLm5vZGUub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChocmVmLnN1YnN0cmluZyhocmVmLmluZGV4T2YoXCIjXCIpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfID0gZWwuXyxcbiAgICAgICAgICAgIHBhdGhmaW5kZXIgPSBTbmFwLnBhdGguZ2V0W2VsLnR5cGVdIHx8IFNuYXAucGF0aC5nZXQuZGVmbHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgXy5iYm94d3QgPSBwYXRoZmluZGVyID8gU25hcC5wYXRoLmdldEJCb3goZWwucmVhbFBhdGggPSBwYXRoZmluZGVyKGVsKSkgOiBTbmFwLl8uYm94KGVsLm5vZGUuZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChfLmJib3h3dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlYWxQYXRoID0gcGF0aGZpbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgZWwubWF0cml4ID0gZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXg7XG4gICAgICAgICAgICAgICAgXy5iYm94ID0gU25hcC5wYXRoLmdldEJCb3goU25hcC5wYXRoLm1hcChlbC5yZWFsUGF0aCwgbS5hZGQoZWwubWF0cml4KSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KF8uYmJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc27igJl0IGdpdmUgeW91IGJib3ggb2YgaGlkZGVuIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9wU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBleHRyYWN0VHJhbnNmb3JtKGVsLCB0c3RyKSB7XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkb1JldHVybiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgZWwudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJncmFkaWVudFRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInBhdHRlcm5UcmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0c3RyID0gU25hcC5fLnN2Z1RyYW5zZm9ybTJzdHJpbmcodHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIVNuYXAuXy5yZ1RyYW5zZm9ybS50ZXN0KHRzdHIpKSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IFNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nKHRzdHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU3RyKHRzdHIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGVsLl8udHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzKHRzdHIsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU25hcC5wYXRoID8gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodHN0cikgOiBTdHIodHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fLnRyYW5zZm9ybSA9IHRzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0c3RyLCBlbC5nZXRCQm94KDEpKTtcbiAgICAgICAgaWYgKGRvUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLm1hdHJpeCA9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudHJhbnNmb3JtXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSB0c3RyIChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmcgaW4gU25hcCBvciBTVkcgZm9ybWF0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChvYmplY3QpIHRyYW5zZm9ybWF0aW9uIGRlc2NyaXB0b3I6XG4gICAgIG8ge1xuICAgICBvICAgICBzdHJpbmcgKHN0cmluZykgdHJhbnNmb3JtIHN0cmluZyxcbiAgICAgbyAgICAgZ2xvYmFsTWF0cml4IChNYXRyaXgpIG1hdHJpeCBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgdG8gZWxlbWVudCBvciBpdHMgcGFyZW50cyxcbiAgICAgbyAgICAgbG9jYWxNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIG9ubHkgdG8gdGhlIGVsZW1lbnQsXG4gICAgIG8gICAgIGRpZmZNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIGRpZmZlcmVuY2UgYmV0d2VlbiBnbG9iYWwgYW5kIGxvY2FsIHRyYW5zZm9ybWF0aW9ucyxcbiAgICAgbyAgICAgZ2xvYmFsIChzdHJpbmcpIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBhcyBzdHJpbmcsXG4gICAgIG8gICAgIGxvY2FsIChzdHJpbmcpIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGFzIHN0cmluZyxcbiAgICAgbyAgICAgdG9TdHJpbmcgKGZ1bmN0aW9uKSByZXR1cm5zIGBzdHJpbmdgIHByb3BlcnR5XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0c3RyKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAodHN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFwYSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gbmV3IFNuYXAuTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSksXG4gICAgICAgICAgICAgICAgbG9jYWwgPSBleHRyYWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgICAgICAgIG1zID0gW2xvY2FsXSxcbiAgICAgICAgICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbG9jYWxTdHJpbmcgPSBsb2NhbC50b1RyYW5zZm9ybVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IFN0cihsb2NhbCkgPT0gU3RyKHRoaXMubWF0cml4KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyKF8udHJhbnNmb3JtKSA6IGxvY2FsU3RyaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHBhcGEudHlwZSAhPSBcInN2Z1wiICYmIChwYXBhID0gcGFwYS5wYXJlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICBtcy5wdXNoKGV4dHJhY3RUcmFuc2Zvcm0ocGFwYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IG1zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZChtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbE1hdHJpeDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgIHRvdGFsTWF0cml4OiBtLFxuICAgICAgICAgICAgICAgIGxvY2FsTWF0cml4OiBsb2NhbCxcbiAgICAgICAgICAgICAgICBkaWZmTWF0cml4OiBnbG9iYWwuY2xvbmUoKS5hZGQobG9jYWwuaW52ZXJ0KCkpLFxuICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLnRvVHJhbnNmb3JtU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdG90YWw6IG0udG9UcmFuc2Zvcm1TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWxTdHJpbmcsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHByb3BTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzdHIgaW5zdGFuY2VvZiBTbmFwLk1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0c3RyO1xuICAgICAgICAgICAgdGhpcy5fLnRyYW5zZm9ybSA9IHRzdHIudG9UcmFuc2Zvcm1TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2Zvcm0odGhpcywgdHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtncmFkaWVudFRyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLm1hdHJpeH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMubm9kZSwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucGFyZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50J3MgcGFyZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXBwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBlbGVtZW50IHRvIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnR8U2V0KSBlbGVtZW50IHRvIGFwcGVuZFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWRkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuYXBwZW5kXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXBwZW5kID0gZWxwcm90by5hZGQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBlbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hZGQoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFwcGVuZFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBhcHBlbmQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICBlbC5hcHBlbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBwcmVwZW5kXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3Q7XG4gICAgICAgICAgICAgICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdC5hZnRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5wcmVwZW5kKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgdGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGQgJiYgdGhpcy5hZGQoKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kVG9cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFByZXBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBwcmVwZW5kIHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjaGlsZCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucHJlcGVuZFRvID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIGVsLnByZXBlbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYmVmb3JlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSBjdXJyZW50IG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IHRvIGluc2VydFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5iZWZvcmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgIGVsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGl0Lm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgaXQubm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgdG8gaW5zZXJ0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbnNlcnRCZWZvcmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgZWwubm9kZSk7XG4gICAgICAgIHRoaXMucGFwZXIgPSBlbC5wYXBlcjtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFyZW50KCkgJiYgZWwucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5zZXJ0QWZ0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIGVsLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCBlbC5ub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgdGhpcy5wYXBlciA9IGVsLnBhcGVyO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXJlbnQoKSAmJiBlbC5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICAgPSAoRWxlbWVudCkgdGhlIGRldGFjaGVkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXBlcjtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zZWxlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdhdGhlcnMgdGhlIG5lc3RlZCBARWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2V0IG9mIENTUyBzZWxlY3RvcnNcbiAgICAgKipcbiAgICAgLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3JcbiAgICAgPSAoRWxlbWVudCkgcmVzdWx0IG9mIHF1ZXJ5IHNlbGVjdGlvblxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihxdWVyeSkpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHYXRoZXJzIG5lc3RlZCBARWxlbWVudCBvYmplY3RzIG1hdGNoaW5nIHRoZSBnaXZlbiBzZXQgb2YgQ1NTIHNlbGVjdG9yc1xuICAgICAqKlxuICAgICAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvclxuICAgICA9IChTZXR8YXJyYXkpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5zZWxlY3RBbGwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIG5vZGVsaXN0ID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICAgICAgc2V0ID0gKFNuYXAuc2V0IHx8IEFycmF5KSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFzUFhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50IGFzIGEgYHB4YCB2YWx1ZSAobm90ICUsIGVtLCBldGMuKVxuICAgICAqKlxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSAjb3B0aW9uYWwgYXR0cmlidXRlIHZhbHVlXG4gICAgID0gKEVsZW1lbnQpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5hc1BYID0gZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cihhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gK3VuaXQycHgodGhpcywgYXR0ciwgdmFsdWUpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQudXNlKCk6IEkgc3VnZ2VzdCBhZGRpbmcgYSBub3RlIGFib3V0IGhvdyB0byBhY2Nlc3MgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhlIHJldHVybmVkIDx1c2U+IGluc3RhbnRpYXRlcy4gSXQncyBhIHBhcnQgb2YgU1ZHIHdpdGggd2hpY2ggb3JkaW5hcnkgd2ViIGRldmVsb3BlcnMgbWF5IGJlIGxlYXN0IGZhbWlsaWFyLlxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8dXNlPmAgZWxlbWVudCBsaW5rZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgYDx1c2U+YCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXNlLFxuICAgICAgICAgICAgaWQgPSB0aGlzLm5vZGUuaWQ7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICB0aGlzLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgIHVzZSA9IG1ha2UodGhpcy50eXBlLCB0aGlzLm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2UgPSBtYWtlKFwidXNlXCIsIHRoaXMubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAkKHVzZS5ub2RlLCB7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogXCIjXCIgKyBpZFxuICAgICAgICB9KTtcbiAgICAgICAgdXNlLm9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHVzZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpeGlkcyhlbCkge1xuICAgICAgICB2YXIgZWxzID0gZWwuc2VsZWN0QWxsKFwiKlwiKSxcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgdXJsID0gL15cXHMqdXJsXFwoKFwifCd8KSguKilcXDFcXClcXHMqJC8sXG4gICAgICAgICAgICBpZHMgPSBbXSxcbiAgICAgICAgICAgIHVzZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gdXJsdGVzdChpdCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICQoaXQubm9kZSwgbmFtZSk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsLm1hdGNoKHVybCk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsWzJdO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuY2hhckF0KCkgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdXNlc1t2YWxdID0gKHVzZXNbdmFsXSB8fCBbXSkuY29uY2F0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBhdHRyW25hbWVdID0gU25hcC51cmwoaWQpO1xuICAgICAgICAgICAgICAgICAgICAkKGl0Lm5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpbmt0ZXN0KGl0KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gJChpdC5ub2RlLCBcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB1c2VzW3ZhbF0gPSAodXNlc1t2YWxdIHx8IFtdKS5jb25jYXQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LmF0dHIoXCJ4bGluazpocmVmXCIsIFwiI1wiICsgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVscy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpdCA9IGVsc1tpXTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwiZmlsbFwiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJmaWx0ZXJcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcIm1hc2tcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcImNsaXAtcGF0aFwiKTtcbiAgICAgICAgICAgIGxpbmt0ZXN0KGl0KTtcbiAgICAgICAgICAgIHZhciBvbGRpZCA9ICQoaXQubm9kZSwgXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChvbGRpZCkge1xuICAgICAgICAgICAgICAgICQoaXQubm9kZSwge2lkOiBpdC5pZH0pO1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2xkOiBvbGRpZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZzID0gdXNlc1tpZHNbaV0ub2xkXTtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGZzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZnNbal0oaWRzW2ldLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xvbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZWxlbWVudCBhbmQgaW5zZXJ0cyBpdCBhZnRlciB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgY2xvbmVcbiAgICBcXCovXG4gICAgZWxwcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgaWYgKCQoY2xvbmUubm9kZSwgXCJpZFwiKSkge1xuICAgICAgICAgICAgJChjbG9uZS5ub2RlLCB7aWQ6IGNsb25lLmlkfSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4aWRzKGNsb25lKTtcbiAgICAgICAgY2xvbmUuaW5zZXJ0QWZ0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvRGVmc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTW92ZXMgZWxlbWVudCB0byB0aGUgc2hhcmVkIGA8ZGVmcz5gIGFyZWFcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50b0RlZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZzID0gZ2V0U29tZURlZnModGhpcyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b1BhdHRlcm5cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPHBhdHRlcm4+YCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICAqIFRvIGNyZWF0ZSBhIHBhdHRlcm4geW91IGhhdmUgdG8gc3BlY2lmeSB0aGUgcGF0dGVybiByZWN0OlxuICAgICAtIHggKHN0cmluZ3xudW1iZXIpXG4gICAgIC0geSAoc3RyaW5nfG51bWJlcilcbiAgICAgLSB3aWR0aCAoc3RyaW5nfG51bWJlcilcbiAgICAgLSBoZWlnaHQgKHN0cmluZ3xudW1iZXIpXG4gICAgID0gKEVsZW1lbnQpIHRoZSBgPHBhdHRlcm4+YCBlbGVtZW50XG4gICAgICogWW91IGNhbiB1c2UgcGF0dGVybiBsYXRlciBvbiBhcyBhbiBhcmd1bWVudCBmb3IgYGZpbGxgIGF0dHJpYnV0ZTpcbiAgICAgfCB2YXIgcCA9IHBhcGVyLnBhdGgoXCJNMTAtNS0xMCwxNU0xNSwwLDAsMTVNMC01LTIwLDE1XCIpLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgIHwgICAgICAgICBzdHJva2U6IFwiI2JhZGE1NVwiLFxuICAgICB8ICAgICAgICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgfCAgICAgfSkucGF0dGVybigwLCAwLCAxMCwgMTApLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDIwMCwgMjAwLCAxMDApO1xuICAgICB8IGMuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IHBcbiAgICAgfCB9KTtcbiAgICBcXCovXG4gICAgZWxwcm90by5wYXR0ZXJuID0gZWxwcm90by50b1BhdHRlcm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IG1ha2UoXCJwYXR0ZXJuXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiBcInhcIiBpbiB4KSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgd2lkdGggPSB4LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0geC5oZWlnaHQ7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG4gICAgICAgICQocC5ub2RlLCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgICAgIHZpZXdCb3g6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKFwiIFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4vLyBTSUVSUkEgRWxlbWVudC5tYXJrZXIoKTogY2xhcmlmeSB3aGF0IGEgcmVmZXJlbmNlIHBvaW50IGlzLiBFLmcuLCBoZWxwcyB5b3Ugb2Zmc2V0IHRoZSBvYmplY3QgZnJvbSBpdHMgZWRnZSBzdWNoIGFzIHdoZW4gY2VudGVyaW5nIGl0IG92ZXIgYSBwYXRoLlxuLy8gU0lFUlJBIEVsZW1lbnQubWFya2VyKCk6IEkgc3VnZ2VzdCB0aGUgbWV0aG9kIHNob3VsZCBhY2NlcHQgZGVmYXVsdCByZWZlcmVuY2UgcG9pbnQgdmFsdWVzLiAgUGVyaGFwcyBjZW50ZXJlZCB3aXRoIChyZWZYID0gd2lkdGgvMikgYW5kIChyZWZZID0gaGVpZ2h0LzIpPyBBbHNvLCBjb3VsZG4ndCBpdCBhc3N1bWUgdGhlIGVsZW1lbnQncyBjdXJyZW50IF93aWR0aF8gYW5kIF9oZWlnaHRfPyBBbmQgcGxlYXNlIHNwZWNpZnkgd2hhdCBfeF8gYW5kIF95XyBtZWFuOiBvZmZzZXRzPyBJZiBzbywgZnJvbSB3aGVyZT8gIENvdWxkbid0IHRoZXkgYWxzbyBiZSBhc3NpZ25lZCBkZWZhdWx0IHZhbHVlcz9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tYXJrZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPG1hcmtlcj5gIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgICogVG8gY3JlYXRlIGEgbWFya2VyIHlvdSBoYXZlIHRvIHNwZWNpZnkgdGhlIGJvdW5kaW5nIHJlY3QgYW5kIHJlZmVyZW5jZSBwb2ludDpcbiAgICAgLSB4IChudW1iZXIpXG4gICAgIC0geSAobnVtYmVyKVxuICAgICAtIHdpZHRoIChudW1iZXIpXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpXG4gICAgIC0gcmVmWCAobnVtYmVyKVxuICAgICAtIHJlZlkgKG51bWJlcilcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8bWFya2VyPmAgZWxlbWVudFxuICAgICAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgbWFya2VyIGxhdGVyIGFzIGFuIGFyZ3VtZW50IGZvciBgbWFya2VyLXN0YXJ0YCwgYG1hcmtlci1lbmRgLCBgbWFya2VyLW1pZGAsIGFuZCBgbWFya2VyYCBhdHRyaWJ1dGVzLiBUaGUgYG1hcmtlcmAgYXR0cmlidXRlIHBsYWNlcyB0aGUgbWFya2VyIGF0IGV2ZXJ5IHBvaW50IGFsb25nIHRoZSBwYXRoLCBhbmQgYG1hcmtlci1taWRgIHBsYWNlcyB0aGVtIGF0IGV2ZXJ5IHBvaW50IGV4Y2VwdCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAgICBcXCovXG4gICAgLy8gVE9ETyBhZGQgdXNhZ2UgZm9yIG1hcmtlcnNcbiAgICBlbHByb3RvLm1hcmtlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZWZYLCByZWZZKSB7XG4gICAgICAgIHZhciBwID0gbWFrZShcIm1hcmtlclwiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4geCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgcmVmWCA9IHgucmVmWCB8fCB4LmN4O1xuICAgICAgICAgICAgcmVmWSA9IHgucmVmWSB8fCB4LmN5O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICAkKHAubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgbWFya2VyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgbWFya2VySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBvcmllbnQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgcmVmWDogcmVmWCB8fCAwLFxuICAgICAgICAgICAgcmVmWTogcmVmWSB8fCAwLFxuICAgICAgICAgICAgaWQ6IHAuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHAubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIHZhciBlbGRhdGEgPSB7fTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIG9yIHJldHJpZXZlcyBnaXZlbiB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggZ2l2ZW4ga2V5LiAoRG9u4oCZdCBjb25mdXNlXG4gICAgICogd2l0aCBgZGF0YS1gIGF0dHJpYnV0ZXMpXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbyBARWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIC0ga2V5IChzdHJpbmcpIGtleSB0byBzdG9yZSBkYXRhXG4gICAgIC0gdmFsdWUgKGFueSkgI29wdGlvbmFsIHZhbHVlIHRvIHN0b3JlXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICAgKiBvciwgaWYgdmFsdWUgaXMgbm90IHNwZWNpZmllZDpcbiAgICAgPSAoYW55KSB2YWx1ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZm9yICh2YXIgaSA9IDAsIGkgPCA1LCBpKyspIHtcbiAgICAgfCAgICAgcGFwZXIuY2lyY2xlKDEwICsgMTUgKiBpLCAxMCwgMTApXG4gICAgIHwgICAgICAgICAgLmF0dHIoe2ZpbGw6IFwiIzAwMFwifSlcbiAgICAgfCAgICAgICAgICAuZGF0YShcImlcIiwgaSlcbiAgICAgfCAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICAgICAgICAgIGFsZXJ0KHRoaXMuZGF0YShcImlcIikpO1xuICAgICB8ICAgICAgICAgIH0pO1xuICAgICB8IH1cbiAgICBcXCovXG4gICAgZWxwcm90by5kYXRhID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlbGRhdGFbdGhpcy5pZF0gPSBlbGRhdGFbdGhpcy5pZF0gfHwge307XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgZXZlKFwic25hcC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGEsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKFNuYXAuaXMoa2V5LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4ga2V5KSBpZiAoa2V5W2hhc10oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhKGksIGtleVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlKFwic25hcC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGFba2V5XSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgIGV2ZShcInNuYXAuZGF0YS5zZXQuXCIgKyB0aGlzLmlkLCB0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhbiBlbGVtZW50IGJ5IGdpdmVuIGtleS5cbiAgICAgKiBJZiBrZXkgaXMgbm90IHByb3ZpZGVkLCByZW1vdmVzIGFsbCB0aGUgZGF0YSBvZiB0aGUgZWxlbWVudC5cbiAgICAgLSBrZXkgKHN0cmluZykgI29wdGlvbmFsIGtleVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGRhdGFbdGhpcy5pZF0gPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZGF0YVt0aGlzLmlkXSAmJiBkZWxldGUgZWxkYXRhW3RoaXMuaWRdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5vdXRlclNWR1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnQsIGVxdWl2YWxlbnQgdG8gSFRNTCdzIGBvdXRlckhUTUxgLlxuICAgICAqXG4gICAgICogU2VlIGFsc28gQEVsZW1lbnQuaW5uZXJTVkdcbiAgICAgPSAoc3RyaW5nKSBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9TdHJpbmdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBARWxlbWVudC5vdXRlclNWR1xuICAgIFxcKi9cbiAgICBlbHByb3RvLm91dGVyU1ZHID0gZWxwcm90by50b1N0cmluZyA9IHRvU3RyaW5nKDEpO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmlubmVyU1ZHXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudCdzIGNvbnRlbnRzLCBlcXVpdmFsZW50IHRvIEhUTUwncyBgaW5uZXJIVE1MYFxuICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmlubmVyU1ZHID0gdG9TdHJpbmcoKTtcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdHlwZSA/IFwiPFwiICsgdGhpcy50eXBlIDogXCJcIixcbiAgICAgICAgICAgICAgICBhdHRyID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgY2hsZCA9IHRoaXMubm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIFwiICsgYXR0cltpXS5uYW1lICsgJz1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJbaV0udmFsdWUucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCI+XCIpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gY2hsZC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGxkW2ldLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBjaGxkW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGxkW2ldLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSB3cmFwKGNobGRbaV0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiLz5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuYnRvYSkge1xuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCQm94KCksXG4gICAgICAgICAgICAgICAgc3ZnID0gU25hcC5mb3JtYXQoJzxzdmcgdmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB3aWR0aD1cInt3aWR0aH1cIiBoZWlnaHQ9XCJ7aGVpZ2h0fVwiIHZpZXdCb3g9XCJ7eH0ge3l9IHt3aWR0aH0ge2hlaWdodH1cIj57Y29udGVudHN9PC9zdmc+Jywge1xuICAgICAgICAgICAgICAgIHg6ICtiYi54LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgeTogK2JiLnkudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogK2JiLndpZHRoLnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiArYmIuaGVpZ2h0LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgY29udGVudHM6IHRoaXMub3V0ZXJTVkcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3ZnKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRnJhZ21lbnQuc2VsZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuc2VsZWN0XG4gICAgXFwqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5zZWxlY3QgPSBlbHByb3RvLnNlbGVjdDtcbiAgICAvKlxcXG4gICAgICogRnJhZ21lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgXFwqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5zZWxlY3RBbGwgPSBlbHByb3RvLnNlbGVjdEFsbDtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgRSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgaWYgKGIgPT0gbnVsbCAmJiBvYmplY3RUb1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBTVkdNYXRyaXhdXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYSA9IGEuYTtcbiAgICAgICAgICAgIHRoaXMuYiA9IGEuYjtcbiAgICAgICAgICAgIHRoaXMuYyA9IGEuYztcbiAgICAgICAgICAgIHRoaXMuZCA9IGEuZDtcbiAgICAgICAgICAgIHRoaXMuZSA9IGEuZTtcbiAgICAgICAgICAgIHRoaXMuZiA9IGEuZjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmEgPSArYTtcbiAgICAgICAgICAgIHRoaXMuYiA9ICtiO1xuICAgICAgICAgICAgdGhpcy5jID0gK2M7XG4gICAgICAgICAgICB0aGlzLmQgPSArZDtcbiAgICAgICAgICAgIHRoaXMuZSA9ICtlO1xuICAgICAgICAgICAgdGhpcy5mID0gK2Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmEgPSAxO1xuICAgICAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgICAgIHRoaXMuYyA9IDA7XG4gICAgICAgICAgICB0aGlzLmQgPSAxO1xuICAgICAgICAgICAgdGhpcy5lID0gMDtcbiAgICAgICAgICAgIHRoaXMuZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKGZ1bmN0aW9uIChtYXRyaXhwcm90bykge1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5hZGRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIEFkZHMgdGhlIGdpdmVuIG1hdHJpeCB0byBleGlzdGluZyBvbmVcbiAgICAgICAgIC0gYSAobnVtYmVyKVxuICAgICAgICAgLSBiIChudW1iZXIpXG4gICAgICAgICAtIGMgKG51bWJlcilcbiAgICAgICAgIC0gZCAobnVtYmVyKVxuICAgICAgICAgLSBlIChudW1iZXIpXG4gICAgICAgICAtIGYgKG51bWJlcilcbiAgICAgICAgICogb3JcbiAgICAgICAgIC0gbWF0cml4IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5hZGQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICAgICAgaWYgKGEgJiYgYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChhLmEsIGEuYiwgYS5jLCBhLmQsIGEuZSwgYS5mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhTmV3ID0gYSAqIHRoaXMuYSArIGIgKiB0aGlzLmMsXG4gICAgICAgICAgICAgICAgYk5ldyA9IGEgKiB0aGlzLmIgKyBiICogdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5lICs9IGUgKiB0aGlzLmEgKyBmICogdGhpcy5jO1xuICAgICAgICAgICAgdGhpcy5mICs9IGUgKiB0aGlzLmIgKyBmICogdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5jID0gYyAqIHRoaXMuYSArIGQgKiB0aGlzLmM7XG4gICAgICAgICAgICB0aGlzLmQgPSBjICogdGhpcy5iICsgZCAqIHRoaXMuZDtcblxuICAgICAgICAgICAgdGhpcy5hID0gYU5ldztcbiAgICAgICAgICAgIHRoaXMuYiA9IGJOZXc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgubXVsdExlZnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE11bHRpcGxpZXMgYSBwYXNzZWQgYWZmaW5lIHRyYW5zZm9ybSB0byB0aGUgbGVmdDogTSAqIHRoaXMuXG4gICAgICAgICAtIGEgKG51bWJlcilcbiAgICAgICAgIC0gYiAobnVtYmVyKVxuICAgICAgICAgLSBjIChudW1iZXIpXG4gICAgICAgICAtIGQgKG51bWJlcilcbiAgICAgICAgIC0gZSAobnVtYmVyKVxuICAgICAgICAgLSBmIChudW1iZXIpXG4gICAgICAgICAqIG9yXG4gICAgICAgICAtIG1hdHJpeCAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgTWF0cml4LnByb3RvdHlwZS5tdWx0TGVmdCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICBpZiAoYSAmJiBhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdExlZnQoYS5hLCBhLmIsIGEuYywgYS5kLCBhLmUsIGEuZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYU5ldyA9IGEgKiB0aGlzLmEgKyBjICogdGhpcy5iLFxuICAgICAgICAgICAgICAgIGNOZXcgPSBhICogdGhpcy5jICsgYyAqIHRoaXMuZCxcbiAgICAgICAgICAgICAgICBlTmV3ID0gYSAqIHRoaXMuZSArIGMgKiB0aGlzLmYgKyBlO1xuICAgICAgICAgICAgdGhpcy5iID0gYiAqIHRoaXMuYSArIGQgKiB0aGlzLmI7XG4gICAgICAgICAgICB0aGlzLmQgPSBiICogdGhpcy5jICsgZCAqIHRoaXMuZDtcbiAgICAgICAgICAgIHRoaXMuZiA9IGIgKiB0aGlzLmUgKyBkICogdGhpcy5mICsgZjtcblxuICAgICAgICAgICAgdGhpcy5hID0gYU5ldztcbiAgICAgICAgICAgIHRoaXMuYyA9IGNOZXc7XG4gICAgICAgICAgICB0aGlzLmUgPSBlTmV3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmludmVydFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmludmVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeCA9IG1lLmEgKiBtZS5kIC0gbWUuYiAqIG1lLmM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtZS5kIC8geCwgLW1lLmIgLyB4LCAtbWUuYyAvIHgsIG1lLmEgLyB4LCAobWUuYyAqIG1lLmYgLSBtZS5kICogbWUuZSkgLyB4LCAobWUuYiAqIG1lLmUgLSBtZS5hICogbWUuZikgLyB4KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguY2xvbmVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnRyYW5zbGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogVHJhbnNsYXRlIHRoZSBtYXRyaXhcbiAgICAgICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICAgLSB5IChudW1iZXIpIHZlcnRpY2FsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmUgKz0geCAqIHRoaXMuYSArIHkgKiB0aGlzLmM7XG4gICAgICAgICAgICB0aGlzLmYgKz0geCAqIHRoaXMuYiArIHkgKiB0aGlzLmQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2NhbGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNjYWxlcyB0aGUgbWF0cml4XG4gICAgICAgICAtIHggKG51bWJlcikgYW1vdW50IHRvIGJlIHNjYWxlZCwgd2l0aCBgMWAgcmVzdWx0aW5nIGluIG5vIGNoYW5nZVxuICAgICAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgdG8gc2NhbGUgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMuIChPdGhlcndpc2UgYHhgIGFwcGxpZXMgdG8gYm90aCBheGVzLilcbiAgICAgICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gc2NhbGVcbiAgICAgICAgIC0gY3kgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHNjYWxlXG4gICAgICAgICAqIERlZmF1bHQgY3gsIGN5IGlzIHRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XG4gICAgICAgICAgICB5ID09IG51bGwgJiYgKHkgPSB4KTtcbiAgICAgICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIHRoaXMuYSAqPSB4O1xuICAgICAgICAgICAgdGhpcy5iICo9IHg7XG4gICAgICAgICAgICB0aGlzLmMgKj0geTtcbiAgICAgICAgICAgIHRoaXMuZCAqPSB5O1xuICAgICAgICAgICAgKGN4IHx8IGN5KSAmJiB0aGlzLnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgucm90YXRlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBtYXRyaXhcbiAgICAgICAgIC0gYSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvbiwgaW4gZGVncmVlc1xuICAgICAgICAgLSB4IChudW1iZXIpIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgICAgICAtIHkgKG51bWJlcikgdmVydGljYWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ucm90YXRlID0gZnVuY3Rpb24gKGEsIHgsIHkpIHtcbiAgICAgICAgICAgIGEgPSBTbmFwLnJhZChhKTtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgdmFyIGNvcyA9ICttYXRoLmNvcyhhKS50b0ZpeGVkKDkpLFxuICAgICAgICAgICAgICAgIHNpbiA9ICttYXRoLnNpbihhKS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoY29zLCBzaW4sIC1zaW4sIGNvcywgeCwgeSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoMSwgMCwgMCwgMSwgLXgsIC15KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1hcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNrZXdzIHRoZSBtYXRyaXggYWxvbmcgdGhlIHgtYXhpc1xuICAgICAgICAgLSB4IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHgtYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2tld1ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1lcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNrZXdzIHRoZSBtYXRyaXggYWxvbmcgdGhlIHktYXhpc1xuICAgICAgICAgLSB5IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHktYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2tld1kgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tldygwLCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1xuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogU2tld3MgdGhlIG1hdHJpeFxuICAgICAgICAgLSB5IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHktYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgICAtIHggKG51bWJlcikgQW5nbGUgdG8gc2tldyBhbG9uZyB0aGUgeC1heGlzIChpbiBkZWdyZWVzKS5cbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5za2V3ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgeCA9IFNuYXAucmFkKHgpO1xuICAgICAgICAgICAgeSA9IFNuYXAucmFkKHkpO1xuICAgICAgICAgICAgdmFyIGMgPSBtYXRoLnRhbih4KS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdmFyIGIgPSBtYXRoLnRhbih5KS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKDEsIGIsIGMsIDEsIDAsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC54XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHggY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueVxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmEgKyB5ICogdGhpcy5jICsgdGhpcy5lO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC55XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHkgY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueFxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmIgKyB5ICogdGhpcy5kICsgdGhpcy5mO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzW1N0ci5mcm9tQ2hhckNvZGUoOTcgKyBpKV0udG9GaXhlZCg0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJtYXRyaXgoXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV0uam9pbigpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLm9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5lLnRvRml4ZWQoNCksIHRoaXMuZi50b0ZpeGVkKDQpXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbm9ybShhKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUoYSkge1xuICAgICAgICAgICAgdmFyIG1hZyA9IG1hdGguc3FydChub3JtKGEpKTtcbiAgICAgICAgICAgIGFbMF0gJiYgKGFbMF0gLz0gbWFnKTtcbiAgICAgICAgICAgIGFbMV0gJiYgKGFbMV0gLz0gbWFnKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5kZXRlcm1pbmFudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogRmluZHMgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgICAgID0gKG51bWJlcikgZGV0ZXJtaW5hbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmEgKiB0aGlzLmQgLSB0aGlzLmIgKiB0aGlzLmM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNwbGl0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTcGxpdHMgbWF0cml4IGludG8gcHJpbWl0aXZlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgICAgICBvIGR4IChudW1iZXIpIHRyYW5zbGF0aW9uIGJ5IHhcbiAgICAgICAgIG8gZHkgKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeVxuICAgICAgICAgbyBzY2FsZXggKG51bWJlcikgc2NhbGUgYnkgeFxuICAgICAgICAgbyBzY2FsZXkgKG51bWJlcikgc2NhbGUgYnkgeVxuICAgICAgICAgbyBzaGVhciAobnVtYmVyKSBzaGVhclxuICAgICAgICAgbyByb3RhdGUgKG51bWJlcikgcm90YXRpb24gaW4gZGVnXG4gICAgICAgICBvIGlzU2ltcGxlIChib29sZWFuKSBjb3VsZCBpdCBiZSByZXByZXNlbnRlZCB2aWEgc2ltcGxlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb25cbiAgICAgICAgICAgIG91dC5keCA9IHRoaXMuZTtcbiAgICAgICAgICAgIG91dC5keSA9IHRoaXMuZjtcblxuICAgICAgICAgICAgLy8gc2NhbGUgYW5kIHNoZWFyXG4gICAgICAgICAgICB2YXIgcm93ID0gW1t0aGlzLmEsIHRoaXMuYl0sIFt0aGlzLmMsIHRoaXMuZF1dO1xuICAgICAgICAgICAgb3V0LnNjYWxleCA9IG1hdGguc3FydChub3JtKHJvd1swXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1swXSk7XG5cbiAgICAgICAgICAgIG91dC5zaGVhciA9IHJvd1swXVswXSAqIHJvd1sxXVswXSArIHJvd1swXVsxXSAqIHJvd1sxXVsxXTtcbiAgICAgICAgICAgIHJvd1sxXSA9IFtyb3dbMV1bMF0gLSByb3dbMF1bMF0gKiBvdXQuc2hlYXIsIHJvd1sxXVsxXSAtIHJvd1swXVsxXSAqIG91dC5zaGVhcl07XG5cbiAgICAgICAgICAgIG91dC5zY2FsZXkgPSBtYXRoLnNxcnQobm9ybShyb3dbMV0pKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShyb3dbMV0pO1xuICAgICAgICAgICAgb3V0LnNoZWFyIC89IG91dC5zY2FsZXk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVybWluYW50KCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb3V0LnNjYWxleCA9IC1vdXQuc2NhbGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgICAgdmFyIHNpbiA9IHJvd1swXVsxXSxcbiAgICAgICAgICAgICAgICBjb3MgPSByb3dbMV1bMV07XG4gICAgICAgICAgICBpZiAoY29zIDwgMCkge1xuICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSBTbmFwLmRlZyhtYXRoLmFjb3MoY29zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IDM2MCAtIG91dC5yb3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gU25hcC5kZWcobWF0aC5hc2luKHNpbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXQuaXNTaW1wbGUgPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmIChvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpIHx8ICFvdXQucm90YXRlKTtcbiAgICAgICAgICAgIG91dC5pc1N1cGVyU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiBvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgb3V0Lm5vUm90YXRpb24gPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgudG9UcmFuc2Zvcm1TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgdHJhbnNmb3JtIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gbWF0cml4XG4gICAgICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmdcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by50b1RyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uIChzaG9ydGVyKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNob3J0ZXIgfHwgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKCErcy5zaGVhci50b0ZpeGVkKDkpKSB7XG4gICAgICAgICAgICAgICAgcy5zY2FsZXggPSArcy5zY2FsZXgudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICBzLnNjYWxleSA9ICtzLnNjYWxleS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHMucm90YXRlID0gK3Mucm90YXRlLnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICAocy5keCB8fCBzLmR5ID8gXCJ0XCIgKyBbK3MuZHgudG9GaXhlZCg0KSwgK3MuZHkudG9GaXhlZCg0KV0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5yb3RhdGUgPyBcInJcIiArIFsrcy5yb3RhdGUudG9GaXhlZCg0KSwgMCwgMF0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5zY2FsZXggIT0gMSB8fCBzLnNjYWxleSAhPSAxID8gXCJzXCIgKyBbcy5zY2FsZXgsIHMuc2NhbGV5LCAwLCAwXSA6IEUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoTWF0cml4LnByb3RvdHlwZSk7XG4gICAgLypcXFxuICAgICAqIFNuYXAuTWF0cml4XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNYXRyaXggY29uc3RydWN0b3IsIGV4dGVuZCBvbiB5b3VyIG93biByaXNrLlxuICAgICAqIFRvIGNyZWF0ZSBtYXRyaWNlcyB1c2UgQFNuYXAubWF0cml4LlxuICAgIFxcKi9cbiAgICBTbmFwLk1hdHJpeCA9IE1hdHJpeDtcbiAgICAvKlxcXG4gICAgICogU25hcC5tYXRyaXhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xuICAgICAtIGEgKG51bWJlcilcbiAgICAgLSBiIChudW1iZXIpXG4gICAgIC0gYyAobnVtYmVyKVxuICAgICAtIGQgKG51bWJlcilcbiAgICAgLSBlIChudW1iZXIpXG4gICAgIC0gZiAobnVtYmVyKVxuICAgICAqIG9yXG4gICAgIC0gc3ZnTWF0cml4IChTVkdNYXRyaXgpXG4gICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgIFxcKi9cbiAgICBTbmFwLm1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwLFxuICAgICAgICBpcyA9IFNuYXAuaXMsXG4gICAgICAgIGdldFNvbWVEZWZzID0gU25hcC5fLmdldFNvbWVEZWZzLFxuICAgICAgICByZVVSTFZhbHVlID0gL151cmxcXCgoWydcIl0/KShbXildKylcXDFcXCkkLyxcbiAgICAgICAgJCA9IFNuYXAuXy4kLFxuICAgICAgICBVUkwgPSBTbmFwLnVybCxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBzZXBhcmF0b3IgPSBTbmFwLl8uc2VwYXJhdG9yLFxuICAgICAgICBFID0gXCJcIjtcbiAgICAvKlxcXG4gICAgICogU25hcC5kZXVybFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVW53cmFwcyBwYXRoIGZyb20gYFwidXJsKDxwYXRoPilcImAuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgdXJsIHBhdGhcbiAgICAgPSAoc3RyaW5nKSB1bndyYXBwZWQgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLmRldXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBTdHJpbmcodmFsdWUpLm1hdGNoKHJlVVJMVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzID8gcmVzWzJdIDogdmFsdWU7XG4gICAgfVxuICAgIC8vIEF0dHJpYnV0ZXMgZXZlbnQgaGFuZGxlcnNcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXNrXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCAmJiB2YWx1ZS5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBnZXRTb21lRGVmcyh0aGlzKS5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwibWFza1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IG1ha2UoXCJtYXNrXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBtYXNrLm5vZGUuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhbWFzay5ub2RlLmlkICYmICQobWFzay5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IG1hc2suaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBtYXNrOiBVUkwobWFzay5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKGZ1bmN0aW9uIChjbGlwSXQpIHtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFwiLCBjbGlwSXQpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5jbGlwLXBhdGhcIiwgY2xpcEl0KTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFBhdGhcIiwgY2xpcEl0KTtcbiAgICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgY2xpcCxcbiAgICAgICAgICAgICAgICBub2RlID0gdmFsdWUubm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiY2xpcFBhdGhcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gbmV3IEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJzdmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xpcCkge1xuICAgICAgICAgICAgICAgIGNsaXAgPSBtYWtlKFwiY2xpcFBhdGhcIiwgZ2V0U29tZURlZnModGhpcykpO1xuICAgICAgICAgICAgICAgIGNsaXAubm9kZS5hcHBlbmRDaGlsZCh2YWx1ZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAhY2xpcC5ub2RlLmlkICYmICQoY2xpcC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjbGlwLmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgICAgIFwiY2xpcC1wYXRoXCI6IFVSTChjbGlwLm5vZGUuaWQgfHwgY2xpcC5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGZpbGxTdHJva2UobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQgJiYgdmFsdWUubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicmFkaWFsR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwibGluZWFyR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicGF0dGVyblwiKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGdldFNvbWVEZWZzKHRoaXMpLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXAodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwicmFkaWFsR3JhZGllbnRcIiB8fCB2YWx1ZS50eXBlID09IFwibGluZWFyR3JhZGllbnRcIlxuICAgICAgICAgICAgICAgICAgIHx8IHZhbHVlLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxsID0gVVJMKHZhbHVlLm5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSB2YWx1ZS5hdHRyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsbCA9IFNuYXAuY29sb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFkID0gU25hcChnZXRTb21lRGVmcyh0aGlzKS5vd25lclNWR0VsZW1lbnQpLmdyYWRpZW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ3JhZC5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChncmFkLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGdyYWQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgPSBVUkwoZ3JhZC5ub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSBTdHIoZmlsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGZpbGw7XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwgYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLnN0eWxlW25hbWVdID0gRTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZmlsbFwiLCBmaWxsU3Ryb2tlKFwiZmlsbFwiKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuc3Ryb2tlXCIsIGZpbGxTdHJva2UoXCJzdHJva2VcIikpO1xuICAgIHZhciBncmFkcmcgPSAvXihbbHJdKSg/OlxcKChbXildKilcXCkpPyguKikkL2k7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdyYWQucGFyc2VcIiwgZnVuY3Rpb24gcGFyc2VHcmFkKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBTdHIoc3RyaW5nKTtcbiAgICAgICAgdmFyIHRva2VucyA9IHN0cmluZy5tYXRjaChncmFkcmcpO1xuICAgICAgICBpZiAoIXRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlbnNbMV0sXG4gICAgICAgICAgICBwYXJhbXMgPSB0b2tlbnNbMl0sXG4gICAgICAgICAgICBzdG9wcyA9IHRva2Vuc1szXTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNwbGl0KC9cXHMqLFxccyovKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gK2VsID09IGVsID8gK2VsIDogZWw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PSAxICYmIHBhcmFtc1swXSA9PSAwKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcyA9IHN0b3BzLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgc3RvcHMgPSBzdG9wcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGVsWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVsWzFdKSB7XG4gICAgICAgICAgICAgICAgb3V0Lm9mZnNldCA9IHBhcnNlRmxvYXQoZWxbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZW4gPSBzdG9wcy5sZW5ndGgsXG4gICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgZnVuY3Rpb24gc2VlZChpLCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gKGVuZCAtIHN0YXJ0KSAvIChpIC0gaik7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gajsgayA8IGk7IGsrKykge1xuICAgICAgICAgICAgICAgIHN0b3BzW2tdLm9mZnNldCA9ICsoK3N0YXJ0ICsgc3RlcCAqIChrIC0gaikpLnRvRml4ZWQoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBpZiAoXCJvZmZzZXRcIiBpbiBzdG9wc1tpXSkge1xuICAgICAgICAgICAgc2VlZChpLCBzdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BzW2xlbl0ub2Zmc2V0ID0gc3RvcHNbbGVuXS5vZmZzZXQgfHwgMTAwO1xuICAgICAgICBzZWVkKGxlbiwgc3RvcHNbbGVuXS5vZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgc3RvcHM6IHN0b3BzXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5kXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAoaXModmFsdWUsIFwiYXJyYXlcIikgJiYgaXModmFsdWVbMF0sIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9bcnVvXS9pKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBTbmFwLnBhdGgudG9BYnNvbHV0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtkOiB2YWx1ZX0pO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFsdWUgPSBTdHIodmFsdWUpO1xuICAgICAgICB2YXIgdHh0ID0gZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHR4dCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnBhdGhcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMuYXR0cih7ZDogdmFsdWV9KTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xhc3NcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IHZhbHVlO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci52aWV3Qm94XCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdmI7XG4gICAgICAgIGlmIChpcyh2YWx1ZSwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZiID0gW3ZhbHVlLngsIHZhbHVlLnksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKHZhbHVlLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YiA9IHZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogdmJcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odmFsdWUpO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5yXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICByeDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcnk6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGlkLCB0cCwgbm9kZTtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy50ZXh0UGF0aCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHAubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0cC5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXModmFsdWUsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZnMgPSBnZXRTb21lRGVmcyh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHdyYXAoZGVmcy5wYXJlbnROb2RlKS5wYXRoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgubm9kZSk7XG4gICAgICAgICAgICAgICAgaWQgPSBwYXRoLmlkO1xuICAgICAgICAgICAgICAgIHBhdGguYXR0cih7aWQ6IGlkfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmF0dHIoe2lkOiBpZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdHAgPSB0aGlzLnRleHRQYXRoO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRwLmF0dHIoe1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHAgPSAkKFwidGV4dFBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0cCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFBhdGggPSB3cmFwKHRwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIudGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgdHVuZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9ICQoXCJ0c3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGNodW5rLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZENoaWxkKHR1bmVyKGNodW5rW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQ2hpbGQoZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUoY2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQubm9ybWFsaXplICYmIG91dC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0dW5lZCA9IHR1bmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHdoaWxlICh0dW5lZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0dW5lZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBmdW5jdGlvbiBzZXRGb250U2l6ZSh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAodmFsdWUgPT0gK3ZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLmZvbnRTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZvbnRTaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZm9udC1zaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG5cblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRQYXRoO1xuICAgIH0pKC0xKTtcbiAgICAvLyBNYXJrZXJzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdsb2IuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFya2VyLVwiICsgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTbmFwKGdsb2IuZG9jLmdldEVsZW1lbnRCeUlkKHN0eWxlLm1hdGNoKHJlVVJMVmFsdWUpWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIoZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFwibWFya2VyXCIgKyBlbmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiIHx8ICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcIm1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHZhbHVlLm5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVtuYW1lXSA9IFVSTChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1lbmRcIiwgZ2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlckVuZFwiLCBnZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyLXN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlclN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1taWRcIiwgZ2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlck1pZFwiLCBnZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLWVuZFwiLCBzZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyRW5kXCIsIHNldHRlcihcImVuZFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXItc3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyU3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLW1pZFwiLCBzZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyTWlkXCIsIHNldHRlcihcIm1pZFwiKSkoLTEpO1xuICAgIH0oKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJyZWN0XCIgJiYgJCh0aGlzLm5vZGUsIFwicnhcIikgPT0gJCh0aGlzLm5vZGUsIFwicnlcIikpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUsIFwicnhcIik7XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gdGV4dEV4dHJhY3Qobm9kZSkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpLnRhZ05hbWUgPT0gXCJ0c3BhblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIGNoaS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh0ZXh0RXh0cmFjdChjaGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB0ZXh0RXh0cmFjdCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG91dC5sZW5ndGggPT0gMSA/IG91dFswXSA6IG91dDtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbGxcIiwgZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV2ZShcInNuYXAudXRpbC5nZXRhdHRyLmZpbGxcIiwgdGhpcywgdHJ1ZSkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBTbmFwKFNuYXAuZGV1cmwodmFsdWUpKSB8fCB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuc3Ryb2tlXCIsIGZ1bmN0aW9uIChpbnRlcm5hbCkge1xuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5zdHJva2VcIiwgdGhpcywgdHJ1ZSkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBTbmFwKFNuYXAuZGV1cmwodmFsdWUpKSB8fCB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudmlld0JveFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciB2YiA9ICQodGhpcy5ub2RlLCBcInZpZXdCb3hcIik7XG4gICAgICAgIGlmICh2Yikge1xuICAgICAgICAgICAgdmIgPSB2Yi5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goK3ZiWzBdLCArdmJbMV0sICt2YlsyXSwgK3ZiWzNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5wb2ludHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9ICQodGhpcy5ub2RlLCBcInBvaW50c1wiKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIucGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZFwiKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmNsYXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gZ2V0Rm9udFNpemUoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGUuZm9udFNpemU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZvbnRTaXplXCIsIGdldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuZm9udC1zaXplXCIsIGdldEZvbnRTaXplKSgtMSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciByZ05vdFNwYWNlID0gL1xcUysvZyxcbiAgICAgICAgcmdCYWRTcGFjZSA9IC9bXFx0XFxyXFxuXFxmXS9nLFxuICAgICAgICByZ1RyaW0gPSAvKF5cXHMrfFxccyskKS9nLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hZGRDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgY2xhc3MgbmFtZSBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgICAqKlxuICAgICA9IChFbGVtZW50KSBvcmlnaW5hbCBlbGVtZW50LlxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFkZENsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gU3RyKHZhbHVlIHx8IFwiXCIpLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgZWxlbSA9IHRoaXMubm9kZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwsXG4gICAgICAgICAgICBjdXJDbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIGNsYXp6LFxuICAgICAgICAgICAgZmluYWxWYWx1ZTtcblxuICAgICAgICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAoIX5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5wdXNoKGNsYXp6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBjdXJDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUuYmFzZVZhbCA9IGZpbmFsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBTdHIodmFsdWUgfHwgXCJcIikubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgY2xhenosXG4gICAgICAgICAgICBmaW5hbFZhbHVlO1xuICAgICAgICBpZiAoY3VyQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGN1ckNsYXNzZXMuam9pbihcIiBcIik7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lICE9IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmhhc0NsYXNzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGVsZW1lbnQgaGFzIGEgZ2l2ZW4gY2xhc3MgbmFtZSBpbiB0aGUgbGlzdCBvZiBjbGFzcyBuYW1lcyBhcHBsaWVkIHRvIGl0LlxuICAgICAtIHZhbHVlIChzdHJpbmcpIGNsYXNzIG5hbWVcbiAgICAgKipcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHRoZSBlbGVtZW50IGhhcyBnaXZlbiBjbGFzc1xuICAgIFxcKi9cbiAgICBlbHByb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW107XG4gICAgICAgIHJldHVybiAhIX5jdXJDbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9nZ2xlQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZCBvciByZW1vdmUgb25lIG9yIG1vcmUgY2xhc3NlcyBmcm9tIHRoZSBlbGVtZW50LCBkZXBlbmRpbmcgb24gZWl0aGVyXG4gICAgICogdGhlIGNsYXNz4oCZcyBwcmVzZW5jZSBvciB0aGUgdmFsdWUgb2YgdGhlIGBmbGFnYCBhcmd1bWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgIC0gZmxhZyAoYm9vbGVhbikgdmFsdWUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNsYXNzIHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUsIGZsYWcpIHtcbiAgICAgICAgaWYgKGZsYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NlcyA9ICh2YWx1ZSB8fCBcIlwiKS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsLFxuICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBjbGF6eixcbiAgICAgICAgICAgIGZpbmFsVmFsdWU7XG4gICAgICAgIGogPSAwO1xuICAgICAgICB3aGlsZSAoY2xhenogPSBjbGFzc2VzW2orK10pIHtcbiAgICAgICAgICAgIHBvcyA9IGN1ckNsYXNzZXMuaW5kZXhPZihjbGF6eik7XG4gICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMucHVzaChjbGF6eik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbFZhbHVlID0gY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0ge1xuICAgICAgICAgICAgXCIrXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgeTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCItXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIvXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4IC8geTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICogeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgcmVVbml0ID0gL1thLXpdKyQvaSxcbiAgICAgICAgcmVBZGRvbiA9IC9eXFxzKihbK1xcLVxcLypdKVxccyo9XFxzKihbXFxkLmVFK1xcLV0rKVxccyooW15cXGRcXHNdKyk/XFxzKiQvO1xuICAgIGZ1bmN0aW9uIGdldE51bWJlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VW5pdCh1bml0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gK3ZhbC50b0ZpeGVkKDMpICsgdW5pdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHJcIiwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgcGx1cyA9IFN0cih2YWwpLm1hdGNoKHJlQWRkb24pO1xuICAgICAgICBpZiAocGx1cykge1xuICAgICAgICAgICAgdmFyIGV2bnQgPSBldmUubnQoKSxcbiAgICAgICAgICAgICAgICBuYW1lID0gZXZudC5zdWJzdHJpbmcoZXZudC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKSxcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5hdHRyKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0ciA9IHt9O1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciB1bml0ID0gcGx1c1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW3BsdXNbMV1dO1xuICAgICAgICAgICAgaWYgKGFVbml0ICYmIGFVbml0ID09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvcChwYXJzZUZsb2F0KGEpLCArcGx1c1syXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmFzUFgobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFsID0gb3AodGhpcy5hc1BYKG5hbWUpLCB0aGlzLmFzUFgobmFtZSwgcGx1c1syXSArIHVuaXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihhKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXRyW25hbWVdID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5hdHRyKGF0cik7XG4gICAgICAgIH1cbiAgICB9KSgtMTApO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5lcXVhbFwiLCBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICB2YXIgQSwgQiwgYSA9IFN0cih0aGlzLmF0dHIobmFtZSkgfHwgXCJcIiksXG4gICAgICAgICAgICBlbCA9IHRoaXMsXG4gICAgICAgICAgICBicGx1cyA9IFN0cihiKS5tYXRjaChyZUFkZG9uKTtcbiAgICAgICAgaWYgKGJwbHVzKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBicGx1c1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW2JwbHVzWzFdXTtcbiAgICAgICAgICAgIGlmIChhVW5pdCAmJiBhVW5pdCA9PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcGFyc2VGbG9hdChhKSxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9wKHBhcnNlRmxvYXQoYSksICticGx1c1syXSksXG4gICAgICAgICAgICAgICAgICAgIGY6IGdldFVuaXQoYVVuaXQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuYXNQWChuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBhLFxuICAgICAgICAgICAgICAgICAgICB0bzogb3AoYSwgdGhpcy5hc1BYKG5hbWUsIGJwbHVzWzJdICsgdW5pdCkpLFxuICAgICAgICAgICAgICAgICAgICBmOiBnZXROdW1iZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoLTEwKTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIHByb3RvID0gUGFwZXIucHJvdG90eXBlLFxuICAgICAgICBpcyA9IFNuYXAuaXM7XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnJlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqXG4gICAgICogRHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodFxuICAgICAtIHJ4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHJhZGl1cyBmb3Igcm91bmRlZCBjb3JuZXJzLCBkZWZhdWx0IGlzIDBcbiAgICAgLSByeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgcmFkaXVzIGZvciByb3VuZGVkIGNvcm5lcnMsIGRlZmF1bHQgaXMgcnggb3IgMFxuICAgICA9IChvYmplY3QpIHRoZSBgcmVjdGAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gcmVndWxhciByZWN0YW5nbGVcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnJlY3QoMTAsIDEwLCA1MCwgNTApO1xuICAgICB8IC8vIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVyc1xuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCg0MCwgNDAsIDUwLCA1MCwgMTApO1xuICAgIFxcKi9cbiAgICBwcm90by5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHJ4LCByeSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIHggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIucnggPSByeDtcbiAgICAgICAgICAgICAgICBhdHRyLnJ5ID0gcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJyZWN0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNpcmNsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBjaXJjbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHIgKG51bWJlcikgcmFkaXVzXG4gICAgID0gKG9iamVjdCkgdGhlIGBjaXJjbGVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDUwLCA1MCwgNDApO1xuICAgIFxcKi9cbiAgICBwcm90by5jaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5LCByKSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAoaXMoY3gsIFwib2JqZWN0XCIpICYmIGN4ID09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICAgIGF0dHIgPSBjeDtcbiAgICAgICAgfSBlbHNlIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcImNpcmNsZVwiLCBhdHRyKTtcbiAgICB9O1xuXG4gICAgdmFyIHByZWxvYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3JjLCBmKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gZ2xvYi5kb2MuY3JlYXRlRWxlbWVudChcImltZ1wiKSxcbiAgICAgICAgICAgICAgICBib2R5ID0gZ2xvYi5kb2MuYm9keTtcbiAgICAgICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZi5jYWxsKGltZyk7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmltYWdlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQbGFjZXMgYW4gaW1hZ2Ugb24gdGhlIHN1cmZhY2VcbiAgICAgKipcbiAgICAgLSBzcmMgKHN0cmluZykgVVJJIG9mIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgLSB4IChudW1iZXIpIHggb2Zmc2V0IHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IG9mZnNldCBwb3NpdGlvblxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgICAtIGhlaWdodCAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAgID0gKG9iamVjdCkgdGhlIGBpbWFnZWAgZWxlbWVudFxuICAgICAqIG9yXG4gICAgID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUgYGltYWdlYFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5pbWFnZShcImFwcGxlLnBuZ1wiLCAxMCwgMTAsIDgwLCA4MCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmltYWdlID0gZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsKFwiaW1hZ2VcIik7XG4gICAgICAgIGlmIChpcyhzcmMsIFwib2JqZWN0XCIpICYmIFwic3JjXCIgaW4gc3JjKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHNyYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSB7XG4gICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IHNyYyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LnggPSB4O1xuICAgICAgICAgICAgICAgIHNldC55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc2V0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZChzcmMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZWxsaXBzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYW4gZWxsaXBzZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0gcnggKG51bWJlcikgaG9yaXpvbnRhbCByYWRpdXNcbiAgICAgLSByeSAobnVtYmVyKSB2ZXJ0aWNhbCByYWRpdXNcbiAgICAgPSAob2JqZWN0KSB0aGUgYGVsbGlwc2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuZWxsaXBzZSg1MCwgNTAsIDQwLCAyMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmVsbGlwc2UgPSBmdW5jdGlvbiAoY3gsIGN5LCByeCwgcnkpIHtcbiAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgIGlmIChpcyhjeCwgXCJvYmplY3RcIikgJiYgY3ggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IGN4O1xuICAgICAgICB9IGVsc2UgaWYgKGN4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPXtcbiAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICAgICAgICByeTogcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJlbGxpcHNlXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIFBhcGVyLnBhdGgoKTogVW5jbGVhciBmcm9tIHRoZSBsaW5rIHdoYXQgYSBDYXRtdWxsLVJvbSBjdXJ2ZXRvIGlzLCBhbmQgd2h5IGl0IHdvdWxkIG1ha2UgbGlmZSBhbnkgZWFzaWVyLlxuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wYXRoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxwYXRoPmAgZWxlbWVudCB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIHRoZSBwYXRoJ3MgZGVmaW5pdGlvblxuICAgICAtIHBhdGhTdHJpbmcgKHN0cmluZykgI29wdGlvbmFsIHBhdGggc3RyaW5nIGluIFNWRyBmb3JtYXRcbiAgICAgKiBQYXRoIHN0cmluZyBjb25zaXN0cyBvZiBvbmUtbGV0dGVyIGNvbW1hbmRzLCBmb2xsb3dlZCBieSBjb21tYSBzZXByYXJhdGVkIGFyZ3VtZW50cyBpbiBudW1lcmljYWwgZm9ybS4gRXhhbXBsZTpcbiAgICAgfCBcIk0xMCwyMEwzMCw0MFwiXG4gICAgICogVGhpcyBleGFtcGxlIGZlYXR1cmVzIHR3byBjb21tYW5kczogYE1gLCB3aXRoIGFyZ3VtZW50cyBgKDEwLCAyMClgIGFuZCBgTGAgd2l0aCBhcmd1bWVudHMgYCgzMCwgNDApYC4gVXBwZXJjYXNlIGxldHRlciBjb21tYW5kcyBleHByZXNzIGNvb3JkaW5hdGVzIGluIGFic29sdXRlIHRlcm1zLCB3aGlsZSBsb3dlcmNhc2UgY29tbWFuZHMgZXhwcmVzcyB0aGVtIGluIHJlbGF0aXZlIHRlcm1zIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZGVjbGFyZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgIyA8cD5IZXJlIGlzIHNob3J0IGxpc3Qgb2YgY29tbWFuZHMgYXZhaWxhYmxlLCBmb3IgbW9yZSBkZXRhaWxzIHNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcIiB0aXRsZT1cIkRldGFpbHMgb2YgYSBwYXRoJ3MgZGF0YSBhdHRyaWJ1dGUncyBmb3JtYXQgYXJlIGRlc2NyaWJlZCBpbiB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXCI+U1ZHIHBhdGggc3RyaW5nIGZvcm1hdDwvYT4gb3IgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NWRy9UdXRvcmlhbC9QYXRoc1wiPmFydGljbGUgYWJvdXQgcGF0aCBzdHJpbmdzIGF0IE1ETjwvYT4uPC9wPlxuICAgICAjIDx0YWJsZT48dGhlYWQ+PHRyPjx0aD5Db21tYW5kPC90aD48dGg+TmFtZTwvdGg+PHRoPlBhcmFtZXRlcnM8L3RoPjwvdHI+PC90aGVhZD48dGJvZHk+XG4gICAgICMgPHRyPjx0ZD5NPC90ZD48dGQ+bW92ZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+WjwvdGQ+PHRkPmNsb3NlcGF0aDwvdGQ+PHRkPihub25lKTwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkw8L3RkPjx0ZD5saW5ldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5IPC90ZD48dGQ+aG9yaXpvbnRhbCBsaW5ldG88L3RkPjx0ZD54KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlY8L3RkPjx0ZD52ZXJ0aWNhbCBsaW5ldG88L3RkPjx0ZD55KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkM8L3RkPjx0ZD5jdXJ2ZXRvPC90ZD48dGQ+KHgxIHkxIHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UzwvdGQ+PHRkPnNtb290aCBjdXJ2ZXRvPC90ZD48dGQ+KHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UTwvdGQ+PHRkPnF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5UPC90ZD48dGQ+c21vb3RoIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5BPC90ZD48dGQ+ZWxsaXB0aWNhbCBhcmM8L3RkPjx0ZD4ocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5SPC90ZD48dGQ+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F0bXVsbOKAk1JvbV9zcGxpbmUjQ2F0bXVsbC5FMi44MC45M1JvbV9zcGxpbmVcIj5DYXRtdWxsLVJvbSBjdXJ2ZXRvPC9hPio8L3RkPjx0ZD54MSB5MSAoeCB5KSs8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPlxuICAgICAqICogX0NhdG11bGwtUm9tIGN1cnZldG9fIGlzIGEgbm90IHN0YW5kYXJkIFNWRyBjb21tYW5kIGFuZCBhZGRlZCB0byBtYWtlIGxpZmUgZWFzaWVyLlxuICAgICAqIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gYSBwYXRoIGNvbnNpc3RzIG9mIG9ubHkgdGhyZWUgY29tbWFuZHM6IGBNMTAsMTBS4oCmemAuIEluIHRoaXMgY2FzZSB0aGUgcGF0aCBjb25uZWN0cyBiYWNrIHRvIGl0cyBzdGFydGluZyBwb2ludC5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIucGF0aChcIk0xMCAxMEw5MCA5MFwiKTtcbiAgICAgfCAvLyBkcmF3IGEgZGlhZ29uYWwgbGluZTpcbiAgICAgfCAvLyBtb3ZlIHRvIDEwLDEwLCBsaW5lIHRvIDkwLDkwXG4gICAgXFwqL1xuICAgIHByb3RvLnBhdGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKGlzKGQsIFwib2JqZWN0XCIpICYmICFpcyhkLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0gZDtcbiAgICAgICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgICAgICBhdHRyID0ge2Q6IGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0aFwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgZ3JvdXAgZWxlbWVudFxuICAgICAqKlxuICAgICAtIHZhcmFyZ3MgKOKApikgI29wdGlvbmFsIGVsZW1lbnRzIHRvIG5lc3Qgd2l0aGluIHRoZSBncm91cFxuICAgICA9IChvYmplY3QpIHRoZSBgZ2AgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZyhjMiwgYzEpOyAvLyBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIGRpZmZlcmVudFxuICAgICAqIG9yXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZygpO1xuICAgICB8IGcuYWRkKGMyLCBjMSk7XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5ncm91cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBQYXBlci5nXG4gICAgXFwqL1xuICAgIHByb3RvLmdyb3VwID0gcHJvdG8uZyA9IGZ1bmN0aW9uIChmaXJzdCkge1xuICAgICAgICB2YXIgYXR0cixcbiAgICAgICAgICAgIGVsID0gdGhpcy5lbChcImdcIik7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZmlyc3QgJiYgIWZpcnN0LnR5cGUpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLmFkZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc3ZnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgbmVzdGVkIFNWRyBlbGVtZW50LlxuICAgICAtIHggKG51bWJlcikgQG9wdGlvbmFsIFggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB5IChudW1iZXIpIEBvcHRpb25hbCBZIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gd2lkdGggKG51bWJlcikgQG9wdGlvbmFsIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIEBvcHRpb25hbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB2YnggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggWFxuICAgICAtIHZieSAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBZXG4gICAgIC0gdmJ3IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IHdpZHRoXG4gICAgIC0gdmJoIChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IGhlaWdodFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgc3ZnYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnN2ZyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB2YngsIHZieSwgdmJ3LCB2YmgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiB5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YnggIT0gbnVsbCAmJiB2YnkgIT0gbnVsbCAmJiB2YncgIT0gbnVsbCAmJiB2YmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLnZpZXdCb3ggPSBbdmJ4LCB2YnksIHZidywgdmJoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInN2Z1wiLCBhdHRycyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIubWFza1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXF1aXZhbGVudCBpbiBiZWhhdmlvdXIgdG8gQFBhcGVyLmcsIGV4Y2VwdCBpdOKAmXMgYSBtYXNrLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgbWFza2AgZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBwcm90by5tYXNrID0gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgZWwgPSB0aGlzLmVsKFwibWFza1wiKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBmaXJzdCAmJiAhZmlyc3QudHlwZSkge1xuICAgICAgICAgICAgZWwuYXR0cihmaXJzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWwuYWRkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wdHJuXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IGluIGJlaGF2aW91ciB0byBAUGFwZXIuZywgZXhjZXB0IGl04oCZcyBhIHBhdHRlcm4uXG4gICAgIC0geCAobnVtYmVyKSBAb3B0aW9uYWwgWCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHkgKG51bWJlcikgQG9wdGlvbmFsIFkgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB3aWR0aCAobnVtYmVyKSBAb3B0aW9uYWwgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgQG9wdGlvbmFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGBwYXR0ZXJuYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnB0cm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgdngsIHZ5LCB2dywgdmgpIHtcbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyID0ge3BhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwifTtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgYXR0ci54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgICAgICAgYXR0ci55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnggIT0gbnVsbCAmJiB2eSAhPSBudWxsICYmIHZ3ICE9IG51bGwgJiYgdmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt2eCwgdnksIHZ3LCB2aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt4IHx8IDAsIHkgfHwgMCwgd2lkdGggfHwgMCwgaGVpZ2h0IHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0dGVyblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci51c2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8dXNlPiBlbGVtZW50LlxuICAgICAtIGlkIChzdHJpbmcpIEBvcHRpb25hbCBpZCBvZiBlbGVtZW50IHRvIGxpbmtcbiAgICAgKiBvclxuICAgICAtIGlkIChFbGVtZW50KSBAb3B0aW9uYWwgZWxlbWVudCB0byBsaW5rXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGB1c2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8udXNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaWQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZC5hdHRyKFwiaWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQuYXR0cih7aWQ6IFNuYXAuXy5pZChpZCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoU3RyaW5nKGlkKS5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ1c2VcIiwge1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUudXNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zeW1ib2xcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8c3ltYm9sPiBlbGVtZW50LlxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgID0gKG9iamVjdCkgdGhlIGBzeW1ib2xgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8uc3ltYm9sID0gZnVuY3Rpb24gKHZ4LCB2eSwgdncsIHZoKSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmICh2eCAhPSBudWxsICYmIHZ5ICE9IG51bGwgJiYgdncgIT0gbnVsbCAmJiB2aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyLnZpZXdCb3ggPSBbdngsIHZ5LCB2dywgdmhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJzeW1ib2xcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIudGV4dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSB0ZXh0IHN0cmluZ1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB0ZXh0IChzdHJpbmd8YXJyYXkpIFRoZSB0ZXh0IHN0cmluZyB0byBkcmF3IG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gbmVzdCB3aXRoaW4gc2VwYXJhdGUgYDx0c3Bhbj5gIGVsZW1lbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGB0ZXh0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdDEgPSBwYXBlci50ZXh0KDUwLCA1MCwgXCJTbmFwXCIpO1xuICAgICB8IHZhciB0MiA9IHBhcGVyLnRleHQoNTAsIDUwLCBbXCJTXCIsXCJuXCIsXCJhXCIsXCJwXCJdKTtcbiAgICAgfCAvLyBUZXh0IHBhdGggdXNhZ2VcbiAgICAgfCB0MS5hdHRyKHt0ZXh0cGF0aDogXCJNMTAsMTBMMTAwLDEwMFwifSk7XG4gICAgIHwgLy8gb3JcbiAgICAgfCB2YXIgcHRoID0gcGFwZXIucGF0aChcIk0xMCwxMEwxMDAsMTAwXCIpO1xuICAgICB8IHQxLmF0dHIoe3RleHRwYXRoOiBwdGh9KTtcbiAgICBcXCovXG4gICAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uICh4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0IHx8IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ0ZXh0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmxpbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgbGluZVxuICAgICAqKlxuICAgICAtIHgxIChudW1iZXIpIHggY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnRcbiAgICAgLSB5MSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0XG4gICAgIC0geDIgKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBlbmRcbiAgICAgLSB5MiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIGVuZFxuICAgICA9IChvYmplY3QpIHRoZSBgbGluZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHQxID0gcGFwZXIubGluZSg1MCwgNTAsIDEwMCwgMTAwKTtcbiAgICBcXCovXG4gICAgcHJvdG8ubGluZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICBpZiAoaXMoeDEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0geDE7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJsaW5lXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBvbHlsaW5lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlsaW5lXG4gICAgICoqXG4gICAgIC0gcG9pbnRzIChhcnJheSkgYXJyYXkgb2YgcG9pbnRzXG4gICAgICogb3JcbiAgICAgLSB2YXJhcmdzICjigKYpIHBvaW50c1xuICAgICA9IChvYmplY3QpIHRoZSBgcG9seWxpbmVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBwMSA9IHBhcGVyLnBvbHlsaW5lKFsxMCwgMTAsIDEwMCwgMTAwXSk7XG4gICAgIHwgdmFyIHAyID0gcGFwZXIucG9seWxpbmUoMTAsIDEwLCAxMDAsIDEwMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLnBvbHlsaW5lID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtwb2ludHM6IHBvaW50c307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwb2x5bGluZVwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wb2x5Z29uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24uIFNlZSBAUGFwZXIucG9seWxpbmVcbiAgICBcXCovXG4gICAgcHJvdG8ucG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyhwb2ludHMsIFwib2JqZWN0XCIpICYmICFpcyhwb2ludHMsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGF0dHIgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7cG9pbnRzOiBwb2ludHN9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicG9seWdvblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8vIGdyYWRpZW50c1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkID0gU25hcC5fLiQ7XG4gICAgICAgIC8vIGdyYWRpZW50cycgaGVscGVyc1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuc3RvcHNcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE9ubHkgZm9yIGdyYWRpZW50cyFcbiAgICAgICAgICogUmV0dXJucyBhcnJheSBvZiBncmFkaWVudCBzdG9wcyBlbGVtZW50cy5cbiAgICAgICAgID0gKGFycmF5KSB0aGUgc3RvcHMgYXJyYXkuXG4gICAgICAgIFxcKi9cbiAgICAgICAgZnVuY3Rpb24gR3N0b3BzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKFwic3RvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuYWRkU3RvcFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogT25seSBmb3IgZ3JhZGllbnRzIVxuICAgICAgICAgKiBBZGRzIGFub3RoZXIgc3RvcCB0byB0aGUgZ3JhZGllbnQuXG4gICAgICAgICAtIGNvbG9yIChzdHJpbmcpIHN0b3BzIGNvbG9yXG4gICAgICAgICAtIG9mZnNldCAobnVtYmVyKSBzdG9wcyBvZmZzZXQgMC4uMTAwXG4gICAgICAgICA9IChvYmplY3QpIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBmdW5jdGlvbiBHYWRkU3RvcChjb2xvciwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9ICQoXCJzdG9wXCIpLFxuICAgICAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogK29mZnNldCArIFwiJVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbG9yID0gU25hcC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBhdHRyW1wic3RvcC1jb2xvclwiXSA9IGNvbG9yLmhleDtcbiAgICAgICAgICAgIGlmIChjb2xvci5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgIGF0dHJbXCJzdG9wLW9wYWNpdHlcIl0gPSBjb2xvci5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChzdG9wLCBhdHRyKTtcbiAgICAgICAgICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHMoKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRlZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcE9mZnNldCA9IHBhcnNlRmxvYXQoc3RvcHNbaV0uYXR0cihcIm9mZnNldFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BPZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShzdG9wLCBzdG9wc1tpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gR2dldEJCb3goKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciB4MSA9ICQodGhpcy5ub2RlLCBcIngxXCIpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyID0gJCh0aGlzLm5vZGUsIFwieDJcIikgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAkKHRoaXMubm9kZSwgXCJ5MVwiKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB5MiA9ICQodGhpcy5ub2RlLCBcInkyXCIpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goeDEsIHkxLCBtYXRoLmFicyh4MiAtIHgxKSwgbWF0aC5hYnMoeTIgLSB5MSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSB0aGlzLm5vZGUuY3ggfHwgLjUsXG4gICAgICAgICAgICAgICAgICAgIGN5ID0gdGhpcy5ub2RlLmN5IHx8IC41LFxuICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5ub2RlLnIgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChjeCAtIHIsIGN5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuc2V0U3RvcHNcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE9ubHkgZm9yIGdyYWRpZW50cyFcbiAgICAgICAgICogVXBkYXRlcyBzdG9wcyBvZiB0aGUgZ3JhZGllbnQgYmFzZWQgb24gcGFzc2VkIGdyYWRpZW50IGRlc2NyaXB0b3IuIFNlZSBAUHBhZXIuZ3JhZGllbnRcbiAgICAgICAgIC0gc3RyIChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3IgcGFydCBhZnRlciBgKClgLlxuICAgICAgICAgPSAob2JqZWN0KSBncmFkaWVudCBlbGVtZW50XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJsKDAsIDAsIDEsIDEpIzAwMC0jZjAwLSNmZmZcIik7XG4gICAgICAgICB8IGcuc2V0U3RvcHMoXCIjZmZmLSMwMDAtI2YwMC0jZmMwXCIpO1xuICAgICAgICBcXCovXG4gICAgICAgIGZ1bmN0aW9uIEdzZXRTdG9wcyhzdHIpIHtcbiAgICAgICAgICAgIHZhciBncmFkID0gc3RyLFxuICAgICAgICAgICAgICAgIHN0b3BzID0gdGhpcy5zdG9wcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBcImwoMCwwLDAsMSlcIiArIHN0cikuZmlyc3REZWZpbmVkKCkuc3RvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVNuYXAuaXMoZ3JhZCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBTbmFwLmNvbG9yKGdyYWRbaV0uY29sb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHtcIm9mZnNldFwiOiBncmFkW2ldLm9mZnNldCArIFwiJVwifTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cltcInN0b3AtY29sb3JcIl0gPSBjb2xvci5oZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvci5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cltcInN0b3Atb3BhY2l0eVwiXSA9IGNvbG9yLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHNbaV0uYXR0cihhdHRyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBzdG9wcy5sZW5ndGg7IGkgPCBncmFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTdG9wKGdyYWRbaV0uY29sb3IsIGdyYWRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdyYWRpZW50KGRlZnMsIHN0cikge1xuICAgICAgICAgICAgdmFyIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBzdHIpLmZpcnN0RGVmaW5lZCgpLFxuICAgICAgICAgICAgICAgIGVsO1xuICAgICAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkLnBhcmFtcy51bnNoaWZ0KGRlZnMpO1xuICAgICAgICAgICAgaWYgKGdyYWQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwibFwiKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBncmFkaWVudExpbmVhci5hcHBseSgwLCBncmFkLnBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZ3JhZGllbnRSYWRpYWwuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYWQudHlwZSAhPSBncmFkLnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdG9wcyA9IGdyYWQuc3RvcHMsXG4gICAgICAgICAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgICAgICAgZWwuYWRkU3RvcChzdG9wLmNvbG9yLCBzdG9wLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRMaW5lYXIoZGVmcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwibGluZWFyR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGVsLnNldFN0b3BzID0gR3NldFN0b3BzO1xuICAgICAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRSYWRpYWwoZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwicmFkaWFsR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnggIT0gbnVsbCAmJiBmeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ4OiBmeCxcbiAgICAgICAgICAgICAgICAgICAgZnk6IGZ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5ncmFkaWVudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgICoqXG4gICAgICAgICAtIGdyYWRpZW50IChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3JcbiAgICAgICAgID4gR3JhZGllbnQgRGVzY3JpcHRvclxuICAgICAgICAgKiBUaGUgZ3JhZGllbnQgZGVzY3JpcHRvciBpcyBhbiBleHByZXNzaW9uIGZvcm1hdHRlZCBhc1xuICAgICAgICAgKiBmb2xsb3dzOiBgPHR5cGU+KDxjb29yZHM+KTxjb2xvcnM+YC4gIFRoZSBgPHR5cGU+YCBjYW4gYmVcbiAgICAgICAgICogZWl0aGVyIGxpbmVhciBvciByYWRpYWwuICBUaGUgdXBwZXJjYXNlIGBMYCBvciBgUmAgbGV0dGVyc1xuICAgICAgICAgKiBpbmRpY2F0ZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZmZzZXQgZnJvbSB0aGUgU1ZHIHN1cmZhY2UuXG4gICAgICAgICAqIExvd2VyY2FzZSBgbGAgb3IgYHJgIGxldHRlcnMgaW5kaWNhdGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICogY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZ3JhZGllbnQgaXNcbiAgICAgICAgICogYXBwbGllZC4gIENvb3JkaW5hdGVzIHNwZWNpZnkgYSBsaW5lYXIgZ3JhZGllbnQgdmVjdG9yIGFzXG4gICAgICAgICAqIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAsIG9yIGEgcmFkaWFsIGdyYWRpZW50IGFzIGBjeGAsIGBjeWAsXG4gICAgICAgICAqIGByYCBhbmQgb3B0aW9uYWwgYGZ4YCwgYGZ5YCBzcGVjaWZ5aW5nIGEgZm9jYWwgcG9pbnQgYXdheVxuICAgICAgICAgKiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS4gU3BlY2lmeSBgPGNvbG9ycz5gIGFzIGEgbGlzdFxuICAgICAgICAgKiBvZiBkYXNoLXNlcGFyYXRlZCBDU1MgY29sb3IgdmFsdWVzLiAgRWFjaCBjb2xvciBtYXkgYmVcbiAgICAgICAgICogZm9sbG93ZWQgYnkgYSBjdXN0b20gb2Zmc2V0IHZhbHVlLCBzZXBhcmF0ZWQgd2l0aCBhIGNvbG9uXG4gICAgICAgICAqIGNoYXJhY3Rlci5cbiAgICAgICAgID4gRXhhbXBsZXNcbiAgICAgICAgICogTGluZWFyIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRvcC1sZWZ0IGNvcm5lciB0byBib3R0b20tcmlnaHRcbiAgICAgICAgICogY29ybmVyLCBmcm9tIGJsYWNrIHRocm91Z2ggcmVkIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwibCgwLCAwLCAxLCAxKSMwMDAtI2YwMC0jZmZmXCIpO1xuICAgICAgICAgKiBMaW5lYXIgZ3JhZGllbnQsIGFic29sdXRlIGZyb20gKDAsIDApIHRvICgxMDAsIDEwMCksIGZyb20gYmxhY2tcbiAgICAgICAgICogdGhyb3VnaCByZWQgYXQgMjUlIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwiTCgwLCAwLCAxMDAsIDEwMCkjMDAwLSNmMDA6MjUtI2ZmZlwiKTtcbiAgICAgICAgICogUmFkaWFsIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgd2l0aCByYWRpdXNcbiAgICAgICAgICogaGFsZiB0aGUgd2lkdGgsIGZyb20gYmxhY2sgdG8gd2hpdGU6XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJyKDAuNSwgMC41LCAwLjUpIzAwMC0jZmZmXCIpO1xuICAgICAgICAgKiBUbyBhcHBseSB0aGUgZ3JhZGllbnQ6XG4gICAgICAgICB8IHBhcGVyLmNpcmNsZSg1MCwgNTAsIDQwKS5hdHRyKHtcbiAgICAgICAgIHwgICAgIGZpbGw6IGdcbiAgICAgICAgIHwgfSk7XG4gICAgICAgICA9IChvYmplY3QpIHRoZSBgZ3JhZGllbnRgIGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by5ncmFkaWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFkaWVudCh0aGlzLmRlZnMsIHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50TGluZWFyID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRMaW5lYXIodGhpcy5kZWZzLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50UmFkaWFsID0gZnVuY3Rpb24gKGN4LCBjeSwgciwgZngsIGZ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRSYWRpYWwodGhpcy5kZWZzLCBjeCwgY3ksIHIsIGZ4LCBmeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUGFwZXIudG9TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBkID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgc3ZnID0gdGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBmLmFwcGVuZENoaWxkKGQpO1xuICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICAgICAgU25hcC5fLiQoc3ZnLCB7eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0pO1xuICAgICAgICAgICAgcmVzID0gZC5pbm5lckhUTUw7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKGYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLnRvRGF0YVVSTFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIEBQYXBlciBhcyBEYXRhIFVSSSBzdHJpbmcuXG4gICAgICAgICA9IChzdHJpbmcpIERhdGEgVVJJIHN0cmluZ1xuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmJ0b2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGhpcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5jbGVhclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIHBhcGVyLCBleGNlcHQgPGRlZnM+LlxuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lICE9IFwiZGVmc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm90by5jbGVhci5jYWxsKHtub2RlOiBub2RlfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBjbG9uZSA9IFNuYXAuXy5jbG9uZSxcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgUEkgPSBtYXRoLlBJLFxuICAgICAgICBtbWluID0gbWF0aC5taW4sXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgcG93ID0gbWF0aC5wb3csXG4gICAgICAgIGFicyA9IG1hdGguYWJzO1xuICAgIGZ1bmN0aW9uIHBhdGhzKHBzKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcbiAgICAgICAgaWYgKHBbcHNdKSB7XG4gICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBbcHNdID0ge1xuICAgICAgICAgICAgICAgIHNsZWVwOiAxMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkgaWYgKHBbaGFzXShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICAgICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAgICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwW3BzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHkgPSB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICAgICAgeDI6IHggKyB3aWR0aCxcbiAgICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgY3g6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICByMTogbWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcjI6IG1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHIwOiBtYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcGF0aDogcmVjdFBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgICB2YjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiLFwiKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aENsb25lKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmV6bGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSxcbiAgICAgICAgICAgICAgICBnZXRUb3RMZW4ocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlbmd0aEZhY3RvcnkoaXN0b3RhbCwgc3VicGF0aCkge1xuICAgICAgICBmdW5jdGlvbiBPKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICsoK3ZhbCkudG9GaXhlZCgzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5fLmNhY2hlcihmdW5jdGlvbiAocGF0aCwgbGVuZ3RoLCBvbmx5c3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmF0dHIoXCJkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcCwgbCwgc3AgPSBcIlwiLCBzdWJwYXRocyA9IHt9LCBwb2ludCxcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuICsgbCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnBhdGggJiYgIXN1YnBhdGhzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwICs9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDXCIgKyBPKHBvaW50LnN0YXJ0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnN0YXJ0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm0ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubS55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC55KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlzdGFydCkge3JldHVybiBzcDt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGF0aHMuc3RhcnQgPSBzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNXCIgKyBPKHBvaW50LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnkpICsgXCJDXCIgKyBPKHBvaW50Lm4ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubi55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5lbmQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQuZW5kLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXN0b3RhbCAmJiAhc3VicGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcCArPSBwLnNoaWZ0KCkgKyBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicGF0aHMuZW5kID0gc3A7XG4gICAgICAgICAgICBwb2ludCA9IGlzdG90YWwgPyBsZW4gOiBzdWJwYXRoID8gc3VicGF0aHMgOiBmaW5kRG90c0F0U2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSwgbnVsbCwgU25hcC5fLmNsb25lKTtcbiAgICB9XG4gICAgdmFyIGdldFRvdGFsTGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgxKSxcbiAgICAgICAgZ2V0UG9pbnRBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoKSxcbiAgICAgICAgZ2V0U3VicGF0aHNBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMCwgMSk7XG4gICAgZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQsXG4gICAgICAgICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgICAgICB0MyA9IHQyICogdCxcbiAgICAgICAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICAgICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5LFxuICAgICAgICAgICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgICAgICAgICBteSA9IHAxeSArIDIgKiB0ICogKGMxeSAtIHAxeSkgKyB0MiAqIChjMnkgLSAyICogYzF5ICsgcDF5KSxcbiAgICAgICAgICAgIG54ID0gYzF4ICsgMiAqIHQgKiAoYzJ4IC0gYzF4KSArIHQyICogKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgICAgICAgICBheCA9IHQxICogcDF4ICsgdCAqIGMxeCxcbiAgICAgICAgICAgIGF5ID0gdDEgKiBwMXkgKyB0ICogYzF5LFxuICAgICAgICAgICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgICAgICAgICBjeSA9IHQxICogYzJ5ICsgdCAqIHAyeSxcbiAgICAgICAgICAgIGFscGhhID0gOTAgLSBtYXRoLmF0YW4yKG14IC0gbngsIG15IC0gbnkpICogMTgwIC8gUEk7XG4gICAgICAgIC8vIChteCA+IG54IHx8IG15IDwgbnkpICYmIChhbHBoYSArPSAxODApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBtOiB7eDogbXgsIHk6IG15fSxcbiAgICAgICAgICAgIG46IHt4OiBueCwgeTogbnl9LFxuICAgICAgICAgICAgc3RhcnQ6IHt4OiBheCwgeTogYXl9LFxuICAgICAgICAgICAgZW5kOiB7eDogY3gsIHk6IGN5fSxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZXppZXJCQm94KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XG4gICAgICAgIGlmICghU25hcC5pcyhwMXgsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHAxeCA9IFtwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJib3ggPSBjdXJ2ZURpbS5hcHBseShudWxsLCBwMXgpO1xuICAgICAgICByZXR1cm4gYm94KFxuICAgICAgICAgICAgYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWluLnksXG4gICAgICAgICAgICBiYm94Lm1heC54IC0gYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWF4LnkgLSBiYm94Lm1pbi55XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuICB4ID49IGJib3gueCAmJlxuICAgICAgICAgICAgICAgIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJlxuICAgICAgICAgICAgICAgIHkgPj0gYmJveC55ICYmXG4gICAgICAgICAgICAgICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94Mikge1xuICAgICAgICBiYm94MSA9IGJveChiYm94MSk7XG4gICAgICAgIGJib3gyID0gYm94KGJib3gyKTtcbiAgICAgICAgcmV0dXJuIGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54LCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55MilcbiAgICAgICAgICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55MilcbiAgICAgICAgICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnhcbiAgICAgICAgICAgICAgICB8fCBiYm94Mi54IDwgYmJveDEueDIgJiYgYmJveDIueCA+IGJib3gxLngpXG4gICAgICAgICAgICAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55XG4gICAgICAgICAgICAgICAgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICAgICAgICAgIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgICAgICAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICB6ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgICAgICAgdmFyIHoyID0geiAvIDIsXG4gICAgICAgICAgICBuID0gMTIsXG4gICAgICAgICAgICBUdmFsdWVzID0gWy0uMTI1MiwuMTI1MiwtLjM2NzgsLjM2NzgsLS41ODczLC41ODczLC0uNzY5OSwuNzY5OSwtLjkwNDEsLjkwNDEsLS45ODE2LC45ODE2XSxcbiAgICAgICAgICAgIEN2YWx1ZXMgPSBbMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLFxuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgICAgICAgICAgIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KSxcbiAgICAgICAgICAgICAgICB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCksXG4gICAgICAgICAgICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuICAgICAgICAgICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBtYXRoLnNxcnQoY29tYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoyICogc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUb3RMZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsbCkge1xuICAgICAgICBpZiAobGwgPCAwIHx8IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIDwgbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IDEsXG4gICAgICAgICAgICBzdGVwID0gdCAvIDIsXG4gICAgICAgICAgICB0MiA9IHQgLSBzdGVwLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGUgPSAuMDE7XG4gICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIHdoaWxlIChhYnMobCAtIGxsKSA+IGUpIHtcbiAgICAgICAgICAgIHN0ZXAgLz0gMjtcbiAgICAgICAgICAgIHQyICs9IChsIDwgbGwgPyAxIDogLTEpICogc3RlcDtcbiAgICAgICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1tYXgoeDEsIHgyKSA8IG1taW4oeDMsIHg0KSB8fFxuICAgICAgICAgICAgbW1pbih4MSwgeDIpID4gbW1heCh4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWF4KHkxLCB5MikgPCBtbWluKHkzLCB5NCkgfHxcbiAgICAgICAgICAgIG1taW4oeTEsIHkyKSA+IG1tYXgoeTMsIHk0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICAgICAgICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB5ID0gbnkgLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB4MiA9ICtweC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPCArbW1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA+ICttbWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA8ICttbWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyID4gK21tYXgoeTMsIHk0KS50b0ZpeGVkKDIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDogcHgsIHk6IHB5fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXIoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyQ291bnQoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICAgICAgICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpLFxuICAgICAgICAgICAgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuICAgICAgICBpZiAoIWlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgICAgICAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsMSA9IGJlemxlbi5hcHBseSgwLCBiZXoxKSxcbiAgICAgICAgICAgIGwyID0gYmV6bGVuLmFwcGx5KDAsIGJlejIpLFxuICAgICAgICAgICAgbjEgPSB+fihsMSAvIDgpLFxuICAgICAgICAgICAgbjIgPSB+fihsMiAvIDgpLFxuICAgICAgICAgICAgZG90czEgPSBbXSxcbiAgICAgICAgICAgIGRvdHMyID0gW10sXG4gICAgICAgICAgICB4eSA9IHt9LFxuICAgICAgICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgICAgICAgICAgZG90czEucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMiArIDE7IGkrKykge1xuICAgICAgICAgICAgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejIuY29uY2F0KGkgLyBuMikpO1xuICAgICAgICAgICAgZG90czIucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMn0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGkgPSBkb3RzMVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZGkxID0gZG90czFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkaiA9IGRvdHMyW2pdLFxuICAgICAgICAgICAgICAgICAgICBkajEgPSBkb3RzMltqICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNpID0gYWJzKGRpMS54IC0gZGkueCkgPCAuMDAxID8gXCJ5XCIgOiBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgY2ogPSBhYnMoZGoxLnggLSBkai54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBpcyA9IGludGVyc2VjdChkaS54LCBkaS55LCBkaTEueCwgZGkxLnksIGRqLngsIGRqLnksIGRqMS54LCBkajEueSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4eVtpcy54LnRvRml4ZWQoNCldID09IGlzLnkudG9GaXhlZCg0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeHlbaXMueC50b0ZpeGVkKDQpXSA9IGlzLnkudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gZGkudCArIGFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gZGoudCArIGFicygoaXNbY2pdIC0gZGpbY2pdKSAvIChkajFbY2pdIC0gZGpbY2pdKSkgKiAoZGoxLnQgLSBkai50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSAmJiB0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MTogdDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyOiB0MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhJbnRlcnNlY3Rpb24ocGF0aDEsIHBhdGgyKSB7XG4gICAgICAgIHJldHVybiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEludGVyc2VjdGlvbk51bWJlcihwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyLCBqdXN0Q291bnQpIHtcbiAgICAgICAgcGF0aDEgPSBwYXRoMmN1cnZlKHBhdGgxKTtcbiAgICAgICAgcGF0aDIgPSBwYXRoMmN1cnZlKHBhdGgyKTtcbiAgICAgICAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MW0sIHkxbSwgeDJtLCB5Mm0sIGJlejEsIGJlejIsXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuICAgICAgICAgICAgaWYgKHBpWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeDEgPSB4MW0gPSBwaVsxXTtcbiAgICAgICAgICAgICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTFdLmNvbmNhdChwaS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYmV6MVs2XTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBiZXoxWzddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlejEgPSBbeDEsIHkxLCB4MSwgeTEsIHgxbSwgeTFtLCB4MW0sIHkxbV07XG4gICAgICAgICAgICAgICAgICAgIHgxID0geDFtO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkxbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcGF0aDIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGogPSBwYXRoMltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm0gPSBwalsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwalswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gYmV6Mls2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGJlejJbN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyLCB4MiwgeTIsIHgybSwgeTJtLCB4Mm0sIHkybV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGludHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IGludHIubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQxID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MSA9IGJlejE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MiA9IGJlejI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoaW50cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBhdGgocGF0aCwgeCwgeSkge1xuICAgICAgICB2YXIgYmJveCA9IHBhdGhCQm94KHBhdGgpO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkgJiZcbiAgICAgICAgICAgICAgIGludGVyUGF0aEhlbHBlcihwYXRoLCBbW1wiTVwiLCB4LCB5XSwgW1wiSFwiLCBiYm94LngyICsgMTBdXSwgMSkgJSAyID09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhCQm94KHBhdGgpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuICAgICAgICBpZiAocHRoLmJib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZShwdGguYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgWCA9IFtdLFxuICAgICAgICAgICAgWSA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBbMV07XG4gICAgICAgICAgICAgICAgeSA9IHBbMl07XG4gICAgICAgICAgICAgICAgWC5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIFkucHVzaCh5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGN1cnZlRGltKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgIFggPSBYLmNvbmNhdChkaW0ubWluLngsIGRpbS5tYXgueCk7XG4gICAgICAgICAgICAgICAgWSA9IFkuY29uY2F0KGRpbS5taW4ueSwgZGltLm1heC55KTtcbiAgICAgICAgICAgICAgICB4ID0gcFs1XTtcbiAgICAgICAgICAgICAgICB5ID0gcFs2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgeG1pbiA9IG1taW4uYXBwbHkoMCwgWCksXG4gICAgICAgICAgICB5bWluID0gbW1pbi5hcHBseSgwLCBZKSxcbiAgICAgICAgICAgIHhtYXggPSBtbWF4LmFwcGx5KDAsIFgpLFxuICAgICAgICAgICAgeW1heCA9IG1tYXguYXBwbHkoMCwgWSksXG4gICAgICAgICAgICBiYiA9IGJveCh4bWluLCB5bWluLCB4bWF4IC0geG1pbiwgeW1heCAtIHltaW4pO1xuICAgICAgICBwdGguYmJveCA9IGNsb25lKGJiKTtcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN0UGF0aCh4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFtcIk1cIiwgK3ggKyArciwgeV0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCB3IC0gciAqIDIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCBoIC0gciAqIDJdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgLXIsIHJdLFxuICAgICAgICAgICAgICAgIFtcImxcIiwgciAqIDIgLSB3LCAwXSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCByICogMiAtIGhdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgLXJdLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtbXCJNXCIsIHgsIHldLCBbXCJsXCIsIHcsIDBdLCBbXCJsXCIsIDAsIGhdLCBbXCJsXCIsIC13LCAwXSwgW1wielwiXV07XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGxpcHNlUGF0aCh4LCB5LCByeCwgcnksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gbnVsbCAmJiByeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByeSA9IHJ4O1xuICAgICAgICB9XG4gICAgICAgIHggPSAreDtcbiAgICAgICAgeSA9ICt5O1xuICAgICAgICByeCA9ICtyeDtcbiAgICAgICAgcnkgPSArcnk7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgICAgICAgIHgxID0geCArIHJ4ICogTWF0aC5jb3MoLXJ5ICogcmFkKSxcbiAgICAgICAgICAgICAgICB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKSxcbiAgICAgICAgICAgICAgICB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCksXG4gICAgICAgICAgICAgICAgeTIgPSB5ICsgcnggKiBNYXRoLnNpbigtYSAqIHJhZCksXG4gICAgICAgICAgICAgICAgcmVzID0gW1tcIk1cIiwgeDEsIHkxXSwgW1wiQVwiLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBbXG4gICAgICAgICAgICAgICAgW1wiTVwiLCB4LCB5XSxcbiAgICAgICAgICAgICAgICBbXCJtXCIsIDAsIC1yeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIDIgKiByeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHZhciB1bml0MnB4ID0gU25hcC5fdW5pdDJweCxcbiAgICAgICAgZ2V0UGF0aCA9IHtcbiAgICAgICAgcGF0aDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihcInBhdGhcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGF0dHIuY3gsIGF0dHIuY3ksIGF0dHIucik7XG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbGxpcHNlUGF0aChhdHRyLmN4IHx8IDAsIGF0dHIuY3kgfHwgMCwgYXR0ci5yeCwgYXR0ci5yeSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0LCBhdHRyLnJ4LCBhdHRyLnJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBbZWwuYXR0cihcIngxXCIpIHx8IDAsIGVsLmF0dHIoXCJ5MVwiKSB8fCAwLCBlbC5hdHRyKFwieDJcIiksIGVsLmF0dHIoXCJ5MlwiKV07XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlsaW5lOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1cIiArIGVsLmF0dHIoXCJwb2ludHNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb246IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZWwuYXR0cihcInBvaW50c1wiKSArIFwielwiO1xuICAgICAgICB9LFxuICAgICAgICBkZWZsdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhdGhUb1JlbGF0aXZlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2U7XG4gICAgICAgIGlmIChwdGgucmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5yZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU25hcC5pcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIVNuYXAuaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgeSA9IHBhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICByZXMucHVzaChbXCJNXCIsIHgsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcmVzW2ldID0gW10sXG4gICAgICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAocGFbMF0gIT0gbG93ZXJDYXNlLmNhbGwocGFbMF0pKSB7XG4gICAgICAgICAgICAgICAgclswXSA9IGxvd2VyQ2FzZS5jYWxsKHBhWzBdKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArKHBhWzZdIC0geCkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArKHBhWzddIC0geSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICsocGFbMV0gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gKyhwYVtqXSAtIChqICUgMiA/IHggOiB5KSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHIgPSByZXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocGFbMF0gPT0gXCJtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXggPSBwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgIG15ID0gcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXVtrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSByZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgc3dpdGNoIChyZXNbaV1bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgICAgICAgICB4ID0gbXg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBteTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgICAgICAgICAgeCArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICB5ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHggKz0gK3Jlc1tpXVtsZW4gLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBwdGgucmVsID0gcGF0aENsb25lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhUb0Fic29sdXRlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KTtcbiAgICAgICAgaWYgKHB0aC5hYnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmFicyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIWlzKHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGhBcnJheSB8fCAhcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtbXCJNXCIsIDAsIDBdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgcGEwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICAgICAgICAgIHkgPSArcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgbXggPSB4O1xuICAgICAgICAgICAgbXkgPSB5O1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIHJlc1swXSA9IFtcIk1cIiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNyeiA9IHBhdGhBcnJheS5sZW5ndGggPT0gMyAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzBdWzBdID09IFwiTVwiICYmXG4gICAgICAgICAgICBwYXRoQXJyYXlbMV1bMF0udG9VcHBlckNhc2UoKSA9PSBcIlJcIiAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzJdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJaXCI7XG4gICAgICAgIGZvciAodmFyIHIsIHBhLCBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHIgPSBbXSk7XG4gICAgICAgICAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgIHBhMCA9IHBhWzBdO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBwYTAudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICtwYVs3XSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdHMgPSBbeCwgeV0uY29uY2F0KHBhLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAyLCBqaiA9IGRvdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbal0gPSArZG90c1tqXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1srK2pdID0gK2RvdHNbal0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiT1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGRvdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJVXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gK3BhWzJdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArcGFbal0gKyAoaiAlIDIgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYTAgPT0gXCJSXCIpIHtcbiAgICAgICAgICAgICAgICBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICAgICAgICAgICAgciA9IFtcIlJcIl0uY29uY2F0KHBhLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGEwID09IFwiVVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhMCA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcHRoLmFicyA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsMmMoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcTJjKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIF8xMyA9IDEgLyAzLFxuICAgICAgICAgICAgXzIzID0gMiAvIDM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXzEzICogeDEgKyBfMjMgKiBheCxcbiAgICAgICAgICAgICAgICBfMTMgKiB5MSArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgIF8xMyAqIHgyICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgXzEzICogeTIgKyBfMjMgKiBheSxcbiAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICB5MlxuICAgICAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICB2YXIgXzEyMCA9IFBJICogMTIwIC8gMTgwLFxuICAgICAgICAgICAgcmFkID0gUEkgLyAxODAgKiAoK2FuZ2xlIHx8IDApLFxuICAgICAgICAgICAgcmVzID0gW10sXG4gICAgICAgICAgICB4eSxcbiAgICAgICAgICAgIHJvdGF0ZSA9IFNuYXAuXy5jYWNoZXIoZnVuY3Rpb24gKHgsIHksIHJhZCkge1xuICAgICAgICAgICAgICAgIHZhciBYID0geCAqIG1hdGguY29zKHJhZCkgLSB5ICogbWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgICAgICAgICAgWSA9IHggKiBtYXRoLnNpbihyYWQpICsgeSAqIG1hdGguY29zKHJhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4OiBYLCB5OiBZfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJ4IHx8ICFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICAgICAgICAgIHgxID0geHkueDtcbiAgICAgICAgICAgIHkxID0geHkueTtcbiAgICAgICAgICAgIHh5ID0gcm90YXRlKHgyLCB5MiwgLXJhZCk7XG4gICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICB5MiA9IHh5Lnk7XG4gICAgICAgICAgICB2YXIgY29zID0gbWF0aC5jb3MoUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgc2luID0gbWF0aC5zaW4oUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgICAgICB2YXIgaCA9IHggKiB4IC8gKHJ4ICogcngpICsgeSAqIHkgLyAocnkgKiByeSk7XG4gICAgICAgICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgICAgICBoID0gbWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgICAgICAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgICAgICAgICAgcnkyID0gcnkgKiByeSxcbiAgICAgICAgICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgICAgICAgICAgbWF0aC5zcXJ0KGFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgICAgICAgICAgICBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgICAgICAgICBmMSA9IG1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgICAgICAgICAgIGYyID0gbWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG5cbiAgICAgICAgICAgIGYxID0geDEgPCBjeCA/IFBJIC0gZjEgOiBmMTtcbiAgICAgICAgICAgIGYyID0geDIgPCBjeCA/IFBJIC0gZjIgOiBmMjtcbiAgICAgICAgICAgIGYxIDwgMCAmJiAoZjEgPSBQSSAqIDIgKyBmMSk7XG4gICAgICAgICAgICBmMiA8IDAgJiYgKGYyID0gUEkgKiAyICsgZjIpO1xuICAgICAgICAgICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgICAgICAgICAgIGYxID0gZjEgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgICAgIGYyID0gZjIgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICAgICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICAgICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgICAgICAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGYgPSBmMiAtIGYxO1xuICAgICAgICBpZiAoYWJzKGRmKSA+IF8xMjApIHtcbiAgICAgICAgICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgICAgICAgICAgIHgyb2xkID0geDIsXG4gICAgICAgICAgICAgICAgeTJvbGQgPSB5MjtcbiAgICAgICAgICAgIGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSk7XG4gICAgICAgICAgICB4MiA9IGN4ICsgcnggKiBtYXRoLmNvcyhmMik7XG4gICAgICAgICAgICB5MiA9IGN5ICsgcnkgKiBtYXRoLnNpbihmMik7XG4gICAgICAgICAgICByZXMgPSBhMmMoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICAgICAgICB9XG4gICAgICAgIGRmID0gZjIgLSBmMTtcbiAgICAgICAgdmFyIGMxID0gbWF0aC5jb3MoZjEpLFxuICAgICAgICAgICAgczEgPSBtYXRoLnNpbihmMSksXG4gICAgICAgICAgICBjMiA9IG1hdGguY29zKGYyKSxcbiAgICAgICAgICAgIHMyID0gbWF0aC5zaW4oZjIpLFxuICAgICAgICAgICAgdCA9IG1hdGgudGFuKGRmIC8gNCksXG4gICAgICAgICAgICBoeCA9IDQgLyAzICogcnggKiB0LFxuICAgICAgICAgICAgaHkgPSA0IC8gMyAqIHJ5ICogdCxcbiAgICAgICAgICAgIG0xID0gW3gxLCB5MV0sXG4gICAgICAgICAgICBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV0sXG4gICAgICAgICAgICBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl0sXG4gICAgICAgICAgICBtNCA9IFt4MiwgeTJdO1xuICAgICAgICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICAgICAgICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB2YXIgbmV3cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld3Jlc1tpXSA9IGkgJSAyID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld3JlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRG90QXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gICAgICAgIHZhciB0MSA9IDEgLSB0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG93KHQxLCAzKSAqIHAxeCArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgcG93KHQsIDMpICogcDJ4LFxuICAgICAgICAgICAgeTogcG93KHQxLCAzKSAqIHAxeSArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgcG93KHQsIDMpICogcDJ5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBib3VuZGluZyBib3ggb2YgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgIC8vIFNvdXJjZTogaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4gICAgLy8gTW9kaWZpY2F0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL3RpbW8yMjM0NVxuICAgIGZ1bmN0aW9uIGN1cnZlRGltKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgdHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICAgICAgICBzcXJ0YjJhYyA9IG1hdGguc3FydChiMmFjKTtcbiAgICAgICAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGpsZW4gPSBqLFxuICAgICAgICAgICAgbXQ7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIGJvdW5kc1swXVtqXSA9IG10ICogbXQgKiBtdCAqIHgwICsgMyAqIG10ICogbXQgKiB0ICogeDEgKyAzICogbXQgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgICAgICAgICBib3VuZHNbMV1bal0gPSBtdCAqIG10ICogbXQgKiB5MCArIDMgKiBtdCAqIG10ICogdCAqIHkxICsgMyAqIG10ICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgICAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICAgICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluOiB7eDogbW1pbi5hcHBseSgwLCBib3VuZHNbMF0pLCB5OiBtbWluLmFwcGx5KDAsIGJvdW5kc1sxXSl9LFxuICAgICAgICAgIG1heDoge3g6IG1tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogbW1heC5hcHBseSgwLCBib3VuZHNbMV0pfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGgyY3VydmUocGF0aCwgcGF0aDIpIHtcbiAgICAgICAgdmFyIHB0aCA9ICFwYXRoMiAmJiBwYXRocyhwYXRoKTtcbiAgICAgICAgaWYgKCFwYXRoMiAmJiBwdGguY3VydmUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgICAgICBhdHRycyA9IHt4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbH0sXG4gICAgICAgICAgICBhdHRyczIgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCwgcGNvbSkge1xuICAgICAgICAgICAgICAgIHZhciBueCwgbnk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhKHBhdGhbMF0gaW4ge1Q6IDEsIFE6IDF9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQoYTJjLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09IFwiQ1wiIHx8IHBjb20gPT0gXCJTXCIpIHsgLy8gSW4gXCJTXCIgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDsgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCIsIG54LCBueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIlFcIiB8fCBwY29tID09IFwiVFwiKSB7IC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueSAqIDIgLSBkLnF5OyAgICAgICAgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhBcmMgPSBmdW5jdGlvbiAocHAsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXMxW2ldID0gXCJBXCI7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgQzpzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyICYmIChwY29tczJbaV0gPSBcIkFcIik7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbXCJDXCJdLmNvbmNhdChwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhNID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMiwgYTEsIGEyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09IFwiTVwiICYmIHBhdGgyW2ldWzBdICE9IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbXCJNXCIsIGEyLngsIGEyLnldKTtcbiAgICAgICAgICAgICAgICAgICAgYTEuYnggPSAwO1xuICAgICAgICAgICAgICAgICAgICBhMS5ieSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGExLnggPSBwYXRoMVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYTEueSA9IHBhdGgxW2ldWzJdO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGNvbXMxID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICAgICAgICBwY29tczIgPSBbXSwgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHAyXG4gICAgICAgICAgICBwZmlyc3QgPSBcIlwiLCAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgIHBjb20gPSBcIlwiOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHBbaV0gJiYgKHBmaXJzdCA9IHBbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICAgICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpIC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBpICYmICggcGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbaV0gPSBwcm9jZXNzUGF0aChwW2ldLCBhdHRycywgcGNvbSk7IC8vIFByZXZpb3VzIHBhdGggY29tbWFuZCBpcyBpbnB1dHRlZCB0byBwcm9jZXNzUGF0aFxuXG4gICAgICAgICAgICBpZiAocGNvbXMxW2ldICE9IFwiQVwiICYmIHBmaXJzdCA9PSBcIkNcIikgcGNvbXMxW2ldID0gXCJDXCI7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgICAgICAgICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgQzpzXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBjb21zMVxuXG4gICAgICAgICAgICBpZiAocDIpIHsgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICAgICAgICAgICAgcDJbaV0gJiYgKHBmaXJzdCA9IHAyW2ldWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAocGZpcnN0ICE9IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMltpIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIsIHBjb20pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBjb21zMltpXSAhPSBcIkFcIiAmJiBwZmlyc3QgPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGNvbXMyW2ldID0gXCJDXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZml4QXJjKHAyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeE0ocCwgcDIsIGF0dHJzLCBhdHRyczIsIGkpO1xuICAgICAgICAgICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgICAgICAgICB2YXIgc2VnID0gcFtpXSxcbiAgICAgICAgICAgICAgICBzZWcyID0gcDIgJiYgcDJbaV0sXG4gICAgICAgICAgICAgICAgc2VnbGVuID0gc2VnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZWcybGVuID0gcDIgJiYgc2VnMi5sZW5ndGg7XG4gICAgICAgICAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICAgICAgICAgIGF0dHJzLmJ4ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gNF0pIHx8IGF0dHJzLng7XG4gICAgICAgICAgICBhdHRycy5ieSA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgICAgICAgICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHRvRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICAgICAgICAgIGF0dHJzMi5ieSA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDNdKSB8fCBhdHRyczIueSk7XG4gICAgICAgICAgICBhdHRyczIueCA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAyKSB7XG4gICAgICAgICAgICBwdGguY3VydmUgPSBwYXRoQ2xvbmUocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAyID8gW3AsIHAyXSA6IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcFBhdGgocGF0aCwgbWF0cml4KSB7XG4gICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCwgeSwgaSwgaiwgaWksIGpqLCBwYXRoaTtcbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoaSA9IHBhdGhbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhpLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICB4ID0gbWF0cml4LngocGF0aGlbal0sIHBhdGhpW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgeSA9IG1hdHJpeC55KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgIHBhdGhpW2pdID0geDtcbiAgICAgICAgICAgICAgICBwYXRoaVtqICsgMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9zY2hlcGVycy5jYy9nZXR0aW5nLXRvLXRoZS1wb2ludFxuICAgIGZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyKGNycCwgeikge1xuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNycC5sZW5ndGg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSAtIDJdLCB5OiArY3JwW2kgLSAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpXSwgICAgIHk6ICtjcnBbaSArIDFdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyAyXSwgeTogK2NycFtpICsgM119LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XX1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpTGVuIC0gMl0sIHk6ICtjcnBbaUxlbiAtIDFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSA0ID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSAyID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzJdLCB5OiArY3JwWzNdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSBwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHt4OiArY3JwW2ldLCB5OiArY3JwW2kgKyAxXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5wdXNoKFtcIkNcIixcbiAgICAgICAgICAgICAgICAgICgtcFswXS54ICsgNiAqIHBbMV0ueCArIHBbMl0ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICAocFsxXS54ICsgNiAqIHBbMl0ueCAtIHBbM10ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueSArIDYqcFsyXS55IC0gcFszXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICBwWzJdLngsXG4gICAgICAgICAgICAgICAgICBwWzJdLnlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0XG4gICAgU25hcC5wYXRoID0gcGF0aHM7XG5cbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIHBhdGggaW4gcGl4ZWxzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgKipcbiAgICAgPSAobnVtYmVyKSBsZW5ndGhcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5nZXRQb2ludEF0TGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIGFsb25nIHRoZSBnaXZlbiBwYXRoXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBsZW5ndGggKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoLCBleGNsdWRpbmcgbm9uLXJlbmRlcmluZyBqdW1wc1xuICAgICAqKlxuICAgICA9IChvYmplY3QpIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlLFxuICAgICBvICAgICBhbHBoYTogKG51bWJlcikgYW5nbGUgb2YgZGVyaXZhdGl2ZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFBvaW50QXRMZW5ndGggPSBnZXRQb2ludEF0TGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgc3VicGF0aCBvZiBhIGdpdmVuIHBhdGggYmV0d2VlbiBnaXZlbiBzdGFydCBhbmQgZW5kIGxlbmd0aHNcbiAgICAgKipcbiAgICAgLSBwYXRoIChzdHJpbmcpIFNWRyBwYXRoIHN0cmluZ1xuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFN1YnBhdGggPSBmdW5jdGlvbiAocGF0aCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG90YWxMZW5ndGgocGF0aCkgLSB0byA8IDFlLTYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIGZyb20pLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IGdldFN1YnBhdGhzQXRMZW5ndGgocGF0aCwgdG8sIDEpO1xuICAgICAgICByZXR1cm4gZnJvbSA/IGdldFN1YnBhdGhzQXRMZW5ndGgoYSwgZnJvbSkuZW5kIDogYTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggaW4gcGl4ZWxzIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgID0gKG51bWJlcikgbGVuZ3RoXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0VG90YWxMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aCgpL0VsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTogSWYgYSA8cGF0aD4gaXMgYnJva2VuIGludG8gZGlmZmVyZW50IHNlZ21lbnRzLCBpcyB0aGUganVtcCBkaXN0YW5jZSB0byB0aGUgbmV3IGNvb3JkaW5hdGVzIHNldCBieSB0aGUgX01fIG9yIF9tXyBjb21tYW5kcyBjYWxjdWxhdGVkIGFzIHBhcnQgb2YgdGhlIHBhdGgncyB0b3RhbCBsZW5ndGg/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIG9uIHRoZSBnaXZlbiBwYXRoIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgICoqXG4gICAgIC0gbGVuZ3RoIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCwgZXhjbHVkaW5nIG5vbi1yZW5kZXJpbmcganVtcHNcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvaW50QXRMZW5ndGgodGhpcy5hdHRyKFwiZFwiKSwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmdldFN1YnBhdGgoKTogU2ltaWxhciB0byB0aGUgcHJvYmxlbSBmb3IgRWxlbWVudC5nZXRQb2ludEF0TGVuZ3RoKCkuIFVuY2xlYXIgaG93IHRoaXMgd291bGQgd29yayBmb3IgYSBzZWdtZW50ZWQgcGF0aC4gT3ZlcmFsbCwgdGhlIGNvbmNlcHQgb2YgX3N1YnBhdGhfIGFuZCB3aGF0IEknbSBjYWxsaW5nIGEgX3NlZ21lbnRfIChzZXJpZXMgb2Ygbm9uLV9NXyBvciBfWl8gY29tbWFuZHMpIGlzIHVuY2xlYXIuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzdWJwYXRoIG9mIGEgZ2l2ZW4gZWxlbWVudCBmcm9tIGdpdmVuIHN0YXJ0IGFuZCBlbmQgbGVuZ3RocyAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnBhdGguZ2V0U3VicGF0aCh0aGlzLmF0dHIoXCJkXCIpLCBmcm9tLCB0byk7XG4gICAgfTtcbiAgICBTbmFwLl8uYm94ID0gYm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZmluZERvdHNBdFNlZ21lbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogRmluZHMgZG90IGNvb3JkaW5hdGVzIG9uIHRoZSBnaXZlbiBjdWJpYyBiZXppw6lyIGN1cnZlIGF0IHRoZSBnaXZlbiB0XG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHQgKG51bWJlcikgcG9zaXRpb24gb24gdGhlIGN1cnZlICgwLi4xKVxuICAgICA9IChvYmplY3QpIHBvaW50IGluZm9ybWF0aW9uIGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIG06IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBhbmNob3IsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgYW5jaG9yXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIG46IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBhbmNob3JcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgc3RhcnQ6IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgZW5kOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIHRoZSBjdXJ2ZSBkZXJpdmF0aXZlIGF0IHRoZSBwb2ludFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmZpbmREb3RzQXRTZWdtZW50ID0gZmluZERvdHNBdFNlZ21lbnQ7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5iZXppZXJCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdpdmVuIGN1YmljIGJlemnDqXIgY3VydmVcbiAgICAgLSBwMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgICogb3JcbiAgICAgLSBiZXogKGFycmF5KSBhcnJheSBvZiBzaXggcG9pbnRzIGZvciBiZXppw6lyIGN1cnZlXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCB0b3AgcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYm90dG9tIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGggb2YgdGhlIGJveCxcbiAgICAgbyAgICAgaGVpZ2h0OiAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGJveFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmJlemllckJCb3ggPSBiZXppZXJCQm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNQb2ludEluc2lkZUJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIGJvdW5kaW5nIGJveFxuICAgICAtIGJib3ggKHN0cmluZykgYm91bmRpbmcgYm94XG4gICAgIC0geCAoc3RyaW5nKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIC0geSAoc3RyaW5nKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBwb2ludCBpcyBpbnNpZGVcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzUG9pbnRJbnNpZGVCQm94ID0gaXNQb2ludEluc2lkZUJCb3g7XG4gICAgU25hcC5jbG9zZXN0ID0gZnVuY3Rpb24gKHgsIHksIFgsIFkpIHtcbiAgICAgICAgdmFyIHIgPSAxMDAsXG4gICAgICAgICAgICBiID0gYm94KHggLSByIC8gMiwgeSAtIHIgLyAyLCByLCByKSxcbiAgICAgICAgICAgIGluc2lkZSA9IFtdLFxuICAgICAgICAgICAgZ2V0dGVyID0gWFswXS5oYXNPd25Qcm9wZXJ0eShcInhcIikgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogWFtpXS55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IFlbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvdW5kID0gMDtcbiAgICAgICAgd2hpbGUgKHIgPD0gMWU2ICYmICFmb3VuZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gWC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHh5ID0gZ2V0dGVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1BvaW50SW5zaWRlQkJveChiLCB4eS54LCB4eS55KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUucHVzaCh4eSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgICAgICAgYiA9IGJveCh4IC0gciAvIDIsIHkgLSByIC8gMiwgciwgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSAxZTYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gSW5maW5pdHksXG4gICAgICAgICAgICByZXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW5zaWRlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsID0gU25hcC5sZW4oeCwgeSwgaW5zaWRlW2ldLngsIGluc2lkZVtpXS55KTtcbiAgICAgICAgICAgIGlmIChsZW4gPiBsKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gbDtcbiAgICAgICAgICAgICAgICBpbnNpZGVbaV0ubGVuID0gbDtcbiAgICAgICAgICAgICAgICByZXMgPSBpbnNpZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNCQm94SW50ZXJzZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHR3byBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICAgLSBiYm94MSAoc3RyaW5nKSBmaXJzdCBib3VuZGluZyBib3hcbiAgICAgLSBiYm94MiAoc3RyaW5nKSBzZWNvbmQgYm91bmRpbmcgYm94XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzQkJveEludGVyc2VjdCA9IGlzQkJveEludGVyc2VjdDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmludGVyc2VjdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBGaW5kcyBpbnRlcnNlY3Rpb25zIG9mIHR3byBwYXRoc1xuICAgICAtIHBhdGgxIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0gcGF0aDIgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIGRvdHMgb2YgaW50ZXJzZWN0aW9uXG4gICAgIG8gW1xuICAgICBvICAgICB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCxcbiAgICAgbyAgICAgICAgIHQxOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgdDI6IChudW1iZXIpIHQgdmFsdWUgZm9yIHNlZ21lbnQgb2YgcGF0aDIsXG4gICAgIG8gICAgICAgICBzZWdtZW50MTogKG51bWJlcikgb3JkZXIgbnVtYmVyIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgc2VnbWVudDI6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMixcbiAgICAgbyAgICAgICAgIGJlejE6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgYmV6MjogKGFycmF5KSBlaWdodCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgYmV6acOpciBjdXJ2ZSBmb3IgdGhlIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgfVxuICAgICBvIF1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbiA9IHBhdGhJbnRlcnNlY3Rpb247XG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbk51bWJlciA9IHBhdGhJbnRlcnNlY3Rpb25OdW1iZXI7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBhIGdpdmVuIGNsb3NlZCBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZTogZmlsbCBtb2RlIGRvZXNu4oCZdCBhZmZlY3QgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0geCAobnVtYmVyKSB4IG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLnBhdGguaXNQb2ludEluc2lkZSA9IGlzUG9pbnRJbnNpZGVQYXRoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBwYXRoXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRCQm94ID0gcGF0aEJCb3g7XG4gICAgU25hcC5wYXRoLmdldCA9IGdldFBhdGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC50b1JlbGF0aXZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggY29vcmRpbmF0ZXMgaW50byByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKGFycmF5KSBwYXRoIHN0cmluZ1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9SZWxhdGl2ZSA9IHBhdGhUb1JlbGF0aXZlO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgudG9BYnNvbHV0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIGNvb3JkaW5hdGVzIGludG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgcGF0aCBzdHJpbmdcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvQWJzb2x1dGUgPSBwYXRoVG9BYnNvbHV0ZTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLnRvQ3ViaWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byBhIG5ldyBwYXRoIHdoZXJlIGFsbCBzZWdtZW50cyBhcmUgY3ViaWMgYmV6acOpciBjdXJ2ZXNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9DdWJpYyA9IHBhdGgyY3VydmU7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5tYXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgcGF0aCBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIG1hdHJpeCAob2JqZWN0KSBzZWUgQE1hdHJpeFxuICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybWVkIHBhdGggc3RyaW5nXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5tYXAgPSBtYXBQYXRoO1xuICAgIFNuYXAucGF0aC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIFNuYXAucGF0aC5jbG9uZSA9IHBhdGhDbG9uZTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbW1heCA9IE1hdGgubWF4LFxuICAgICAgICBtbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBTZXRcbiAgICB2YXIgU2V0ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcblx0dGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic2V0XCI7XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RoaXMuaXRlbXMubGVuZ3RoXSA9IHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRwcm90byA9IFNldC5wcm90b3R5cGU7XG4gICAgLypcXFxuICAgICAqIFNldC5wdXNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGVhY2ggYXJndW1lbnQgdG8gdGhlIGN1cnJlbnQgc2V0XG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSxcbiAgICAgICAgICAgIGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXNbbGVuXSA9IHRoaXMuaXRlbXNbbGVuXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQucG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGxhc3QgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICAgICA9IChvYmplY3QpIGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCAmJiBkZWxldGUgdGhpc1t0aGlzLmxlbmd0aC0tXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmZvckVhY2hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEV4ZWN1dGVzIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgICAqXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdGhlIGxvb3Agc3RvcHMgcnVubmluZy5cbiAgICAgKipcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pIGZ1bmN0aW9uIHRvIHJ1blxuICAgICAtIHRoaXNBcmcgKG9iamVjdCkgY29udGV4dCBvYmplY3QgZm9yIHRoZSBjYWxsYmFja1xuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuaXRlbXNbaV0sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyBlYWNoIGVsZW1lbnQgaW4gc2V0IGluIHN5bmMuXG4gICAgICpcbiAgICAgKipcbiAgICAgLSBhdHRycyAob2JqZWN0KSBrZXktdmFsdWUgcGFpcnMgb2YgZGVzdGluYXRpb24gYXR0cmlidXRlc1xuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiBmcm9tIEBtaW5hIG9yIGN1c3RvbVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHNcbiAgICAgKiBvclxuICAgICAtIGFuaW1hdGlvbiAoYXJyYXkpIGFycmF5IG9mIGFuaW1hdGlvbiBwYXJhbWV0ZXIgZm9yIGVhY2ggZWxlbWVudCBpbiBzZXQgaW4gZm9ybWF0IGBbYXR0cnMsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXWBcbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGFuaW1hdGUgYWxsIGVsZW1lbnRzIGluIHNldCB0byByYWRpdXMgMTBcbiAgICAgfCBzZXQuYW5pbWF0ZSh7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluKTtcbiAgICAgfCAvLyBvclxuICAgICB8IC8vIGFuaW1hdGUgZmlyc3QgZWxlbWVudCB0byByYWRpdXMgMTAsIGJ1dCBzZWNvbmQgdG8gcmFkaXVzIDIwIGFuZCBpbiBkaWZmZXJlbnQgdGltZVxuICAgICB8IHNldC5hbmltYXRlKFt7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluXSwgW3tyOiAyMH0sIDE1MDAsIG1pbmEuZWFzZWluXSk7XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIFNuYXAuXy5BbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXR0cnMuY2FsbGJhY2s7XG4gICAgICAgICAgICBlYXNpbmcgPSBhdHRycy5lYXNpbmc7XG4gICAgICAgICAgICBtcyA9IGVhc2luZy5kdXI7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzLmF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChTbmFwLmlzKGF0dHJzLCBcImFycmF5XCIpICYmIFNuYXAuaXMoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YXIgZWFjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZ2luLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gYmVnaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSB0aGlzLmI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNiID0gMCxcbiAgICAgICAgICAgIHNldCA9IHRoaXMsXG4gICAgICAgICAgICBjYWxsYmFja2VyID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgrK2NiID09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFuaW1jcmVhdGVkLlwiICsgZWwuaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldICYmIGVsLmFuaW1hdGUuYXBwbHkoZWwsIGFyZ3NbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5hbmltYXRlKGF0dHJzLCBtcywgZWFzaW5nLCBjYWxsYmFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnJlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gb2YgdGhlIHNldC5cbiAgICAgKlxuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wKCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmJpbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNwZWNpZmllcyBob3cgdG8gaGFuZGxlIGEgc3BlY2lmaWMgYXR0cmlidXRlIHdoZW4gYXBwbGllZFxuICAgICAqIHRvIGEgc2V0LlxuICAgICAqXG4gICAgICoqXG4gICAgIC0gYXR0ciAoc3RyaW5nKSBhdHRyaWJ1dGUgbmFtZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgICogb3JcbiAgICAgLSBhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBuYW1lXG4gICAgIC0gZWxlbWVudCAoRWxlbWVudCkgc3BlY2lmaWMgZWxlbWVudCBpbiB0aGUgc2V0IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgKiBvclxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSBlbGVtZW50IChFbGVtZW50KSBzcGVjaWZpYyBlbGVtZW50IGluIHRoZSBzZXQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICAtIGVhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCB0byBiaW5kIHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgPSAob2JqZWN0KSBTZXQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmJpbmQgPSBmdW5jdGlvbiAoYXR0ciwgYSwgYikge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2F0dHJdID0gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmFtZSA9IGIgfHwgYXR0cjtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbYXR0cl0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGRhdGFbYW5hbWVdID0gdjtcbiAgICAgICAgICAgICAgICBhLmF0dHIoZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hdHRyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IG9mIEBFbGVtZW50LmF0dHIuXG4gICAgID0gKG9iamVjdCkgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5hdHRyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB1bmJvdW5kID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW2tdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1trXSh2YWx1ZVtrXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuYm91bmRba10gPSB2YWx1ZVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uYXR0cih1bmJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuY2xlYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnNwbGljZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyByYW5nZSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBpbmRleCAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgZGVsZXRpb25cbiAgICAgLSBjb3VudCAobnVtYmVyKSBudW1iZXIgb2YgZWxlbWVudCB0byByZW1vdmVcbiAgICAgLSBpbnNlcnRpb27igKYgKG9iamVjdCkgI29wdGlvbmFsIGVsZW1lbnRzIHRvIGluc2VydFxuICAgICA9IChvYmplY3QpIHNldCBlbGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5zcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBpbnNlcnRpb24pIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBtbWF4KHRoaXMubGVuZ3RoICsgaW5kZXgsIDApIDogaW5kZXg7XG4gICAgICAgIGNvdW50ID0gbW1heCgwLCBtbWluKHRoaXMubGVuZ3RoIC0gaW5kZXgsIGNvdW50KSk7XG4gICAgICAgIHZhciB0YWlsID0gW10sXG4gICAgICAgICAgICB0b2RlbCA9IFtdLFxuICAgICAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvZGVsLnB1c2godGhpc1tpbmRleCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdGFpbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuICsgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleCArIGldID0gdGhpc1tpbmRleCArIGldID0gaSA8IGFyZ2xlbiA/IGFyZ3NbaV0gOiB0YWlsW2kgLSBhcmdsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCA9IHRoaXMubGVuZ3RoIC09IGNvdW50IC0gYXJnbGVuO1xuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldCh0b2RlbCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmV4Y2x1ZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBvYmplY3Qgd2FzIGZvdW5kIGFuZCByZW1vdmVkIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5leGNsdWRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKHRoaXNbaV0gPT0gZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5pbnNlcnRBZnRlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyBzZXQgZWxlbWVudHMgYWZ0ZXIgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIHNldCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIHRoaXMgZWxlbWVudFxuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5pbnNlcnRBZnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFVuaW9uIG9mIGFsbCBiYm94ZXMgb2YgdGhlIHNldC4gU2VlIEBFbGVtZW50LmdldEJCb3guXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94IGRlc2NyaXB0b3IuIFNlZSBARWxlbWVudC5nZXRCQm94LlxuICAgIFxcKi9cbiAgICBzZXRwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCA9IFtdLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgeDIgPSBbXSxcbiAgICAgICAgICAgIHkyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaS0tOykgaWYgKCF0aGlzLml0ZW1zW2ldLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLml0ZW1zW2ldLmdldEJCb3goKTtcbiAgICAgICAgICAgIHgucHVzaChib3gueCk7XG4gICAgICAgICAgICB5LnB1c2goYm94LnkpO1xuICAgICAgICAgICAgeDIucHVzaChib3gueCArIGJveC53aWR0aCk7XG4gICAgICAgICAgICB5Mi5wdXNoKGJveC55ICsgYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IG1taW4uYXBwbHkoMCwgeCk7XG4gICAgICAgIHkgPSBtbWluLmFwcGx5KDAsIHkpO1xuICAgICAgICB4MiA9IG1tYXguYXBwbHkoMCwgeDIpO1xuICAgICAgICB5MiA9IG1tYXguYXBwbHkoMCwgeTIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHksXG4gICAgICAgICAgICBjeDogeCArICh4MiAtIHgpIC8gMixcbiAgICAgICAgICAgIGN5OiB5ICsgKHkyIC0geSkgLyAyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0Lmluc2VydEFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIHNldC5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBOZXcgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbG9uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMgPSBuZXcgU2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHMucHVzaCh0aGlzLml0ZW1zW2ldLmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgc2V0cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNuYXBcXHUyMDE4cyBzZXRcIjtcbiAgICB9O1xuICAgIHNldHByb3RvLnR5cGUgPSBcInNldFwiO1xuICAgIC8vIGV4cG9ydFxuICAgIC8qXFxcbiAgICAgKiBTbmFwLlNldFxuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBTZXQgY29uc3RydWN0b3IuXG4gICAgXFwqL1xuICAgIFNuYXAuU2V0ID0gU2V0O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnNldFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBhbmQgZmlsbHMgaXQgd2l0aCBsaXN0IG9mIGFyZ3VtZW50cy5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBOZXcgU2V0IG9iamVjdFxuICAgICB8IHZhciByID0gcGFwZXIucmVjdCgwLCAwLCAxMCwgMTApLFxuICAgICB8ICAgICBzMSA9IFNuYXAuc2V0KCksIC8vIGVtcHR5IHNldFxuICAgICB8ICAgICBzMiA9IFNuYXAuc2V0KHIsIHBhcGVyLmNpcmNsZSgxMDAsIDEwMCwgMjApKTsgLy8gcHJlZmlsbGVkIHNldFxuICAgIFxcKi9cbiAgICBTbmFwLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXQucHVzaC5hcHBseShzZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbmFtZXMgPSB7fSxcbiAgICAgICAgcmVVbml0ID0gL1slYS16XSskL2ksXG4gICAgICAgIFN0ciA9IFN0cmluZztcbiAgICBuYW1lcy5zdHJva2UgPSBuYW1lcy5maWxsID0gXCJjb2xvdXJcIjtcbiAgICBmdW5jdGlvbiBnZXRFbXB0eShpdGVtKSB7XG4gICAgICAgIHZhciBsID0gaXRlbVswXTtcbiAgICAgICAgc3dpdGNoIChsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6IHJldHVybiBbbCwgMCwgMF07XG4gICAgICAgICAgICBjYXNlIFwibVwiOiByZXR1cm4gW2wsIDEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgY2FzZSBcInJcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDAsIGl0ZW1bMl0sIGl0ZW1bM11dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDEsIDEsIGl0ZW1bM10sIGl0ZW1bNF1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxLCAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbGlzZVRyYW5zZm9ybSh0MSwgdDIsIGdldEJCb3gpIHtcbiAgICAgICAgdDEgPSB0MSB8fCBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgIHQyID0gdDIgfHwgbmV3IFNuYXAuTWF0cml4O1xuICAgICAgICB0MSA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcodDEudG9UcmFuc2Zvcm1TdHJpbmcoKSkgfHwgW107XG4gICAgICAgIHQyID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0Mi50b1RyYW5zZm9ybVN0cmluZygpKSB8fCBbXTtcbiAgICAgICAgdmFyIG1heGxlbmd0aCA9IE1hdGgubWF4KHQxLmxlbmd0aCwgdDIubGVuZ3RoKSxcbiAgICAgICAgICAgIGZyb20gPSBbXSxcbiAgICAgICAgICAgIHRvID0gW10sXG4gICAgICAgICAgICBpID0gMCwgaiwgamosXG4gICAgICAgICAgICB0dDEsIHR0MjtcbiAgICAgICAgZm9yICg7IGkgPCBtYXhsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHQxID0gdDFbaV0gfHwgZ2V0RW1wdHkodDJbaV0pO1xuICAgICAgICAgICAgdHQyID0gdDJbaV0gfHwgZ2V0RW1wdHkodHQxKTtcbiAgICAgICAgICAgIGlmICh0dDFbMF0gIT0gdHQyWzBdIHx8XG4gICAgICAgICAgICAgICAgdHQxWzBdLnRvTG93ZXJDYXNlKCkgPT0gXCJyXCIgJiYgKHR0MVsyXSAhPSB0dDJbMl0gfHwgdHQxWzNdICE9IHR0MlszXSkgfHxcbiAgICAgICAgICAgICAgICB0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInNcIiAmJiAodHQxWzNdICE9IHR0MlszXSB8fCB0dDFbNF0gIT0gdHQyWzRdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IFNuYXAuXy50cmFuc2Zvcm0ybWF0cml4KHQxLCBnZXRCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICB0MiA9IFNuYXAuXy50cmFuc2Zvcm0ybWF0cml4KHQyLCBnZXRCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gW1tcIm1cIiwgdDEuYSwgdDEuYiwgdDEuYywgdDEuZCwgdDEuZSwgdDEuZl1dO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFtbXCJtXCIsIHQyLmEsIHQyLmIsIHQyLmMsIHQyLmQsIHQyLmUsIHQyLmZdXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tW2ldID0gW107XG4gICAgICAgICAgICB0b1tpXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBNYXRoLm1heCh0dDEubGVuZ3RoLCB0dDIubGVuZ3RoKTsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBqIGluIHR0MSAmJiAoZnJvbVtpXVtqXSA9IHR0MVtqXSk7XG4gICAgICAgICAgICAgICAgaiBpbiB0dDIgJiYgKHRvW2ldW2pdID0gdHQyW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShmcm9tKSxcbiAgICAgICAgICAgIHRvOiBwYXRoMmFycmF5KHRvKSxcbiAgICAgICAgICAgIGY6IGdldFBhdGgoZnJvbSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVbml0KHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiArdmFsLnRvRml4ZWQoMykgKyB1bml0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaWV3Qm94KHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb2xvdXIoY2xyKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnJnYihjbHJbMF0sIGNsclsxXSwgY2xyWzJdLCBjbHJbM10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQYXRoKHBhdGgpIHtcbiAgICAgICAgdmFyIGsgPSAwLCBpLCBpaSwgaiwgamosIG91dCwgYSwgYiA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgb3V0ID0gXCJbXCI7XG4gICAgICAgICAgICBhID0gWydcIicgKyBwYXRoW2ldWzBdICsgJ1wiJ107XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGFbal0gPSBcInZhbFtcIiArIGsrKyArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IGEgKyBcIl1cIjtcbiAgICAgICAgICAgIGJbaV0gPSBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKFwidmFsXCIsIFwicmV0dXJuIFNuYXAucGF0aC50b1N0cmluZy5jYWxsKFtcIiArIGIgKyBcIl0pXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoMmFycmF5KHBhdGgpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHBhdGhbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICAgICAgICBpZiAoIVNuYXAuaXMoYXJyMSwgXCJhcnJheVwiKSB8fCAhU25hcC5pcyhhcnIyLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjEudG9TdHJpbmcoKSA9PSBhcnIyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIEVsZW1lbnQucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKG5hbWUsIGIpIHtcbiAgICAgICAgcmV0dXJuIGV2ZShcInNuYXAudXRpbC5lcXVhbFwiLCB0aGlzLCBuYW1lLCBiKS5maXJzdERlZmluZWQoKTtcbiAgICB9O1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5lcXVhbFwiLCBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICB2YXIgQSwgQiwgYSA9IFN0cih0aGlzLmF0dHIobmFtZSkgfHwgXCJcIiksXG4gICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIGlmIChuYW1lc1tuYW1lXSA9PSBcImNvbG91clwiKSB7XG4gICAgICAgICAgICBBID0gU25hcC5jb2xvcihhKTtcbiAgICAgICAgICAgIEIgPSBTbmFwLmNvbG9yKGIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBbQS5yLCBBLmcsIEEuYiwgQS5vcGFjaXR5XSxcbiAgICAgICAgICAgICAgICB0bzogW0IuciwgQi5nLCBCLmIsIEIub3BhY2l0eV0sXG4gICAgICAgICAgICAgICAgZjogZ2V0Q29sb3VyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidmlld0JveFwiKSB7XG4gICAgICAgICAgICBBID0gdGhpcy5hdHRyKG5hbWUpLnZiLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIEIgPSBiLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogQSxcbiAgICAgICAgICAgICAgICB0bzogQixcbiAgICAgICAgICAgICAgICBmOiBnZXRWaWV3Qm94XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcImdyYWRpZW50VHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcInBhdHRlcm5UcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBiID0gU3RyKGIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IHRoaXMubWF0cml4O1xuICAgICAgICAgICAgaWYgKCFTbmFwLl8ucmdUcmFuc2Zvcm0udGVzdChiKSkge1xuICAgICAgICAgICAgICAgIGIgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeChTbmFwLl8uc3ZnVHJhbnNmb3JtMnN0cmluZyhiKSwgdGhpcy5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiID0gU25hcC5fLnRyYW5zZm9ybTJtYXRyaXgoYiwgdGhpcy5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVxdWFsaXNlVHJhbnNmb3JtKGEsIGIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QkJveCgxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwiZFwiIHx8IG5hbWUgPT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIEEgPSBTbmFwLnBhdGgudG9DdWJpYyhhLCBiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShBWzBdKSxcbiAgICAgICAgICAgICAgICB0bzogcGF0aDJhcnJheShBWzFdKSxcbiAgICAgICAgICAgICAgICBmOiBnZXRQYXRoKEFbMF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgICAgIEEgPSBTdHIoYSkuc3BsaXQoU25hcC5fLnNlcGFyYXRvcik7XG4gICAgICAgICAgICBCID0gU3RyKGIpLnNwbGl0KFNuYXAuXy5zZXBhcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBBLFxuICAgICAgICAgICAgICAgIHRvOiBCLFxuICAgICAgICAgICAgICAgIGY6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1lcmljKGEpICYmIGlzTnVtZXJpYyhiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgIHRvOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYVVuaXQgPSBhLm1hdGNoKHJlVW5pdCksXG4gICAgICAgICAgICBiVW5pdCA9IFN0cihiKS5tYXRjaChyZVVuaXQpO1xuICAgICAgICBpZiAoYVVuaXQgJiYgYXJyYXlFcXVhbChhVW5pdCwgYlVuaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHBhcnNlRmxvYXQoYSksXG4gICAgICAgICAgICAgICAgdG86IHBhcnNlRmxvYXQoYiksXG4gICAgICAgICAgICAgICAgZjogZ2V0VW5pdChhVW5pdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYXNQWChuYW1lKSxcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hc1BYKG5hbWUsIGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIHN1cHBvcnRzVG91Y2ggPSBcImNyZWF0ZVRvdWNoXCIgaW4gZ2xvYi5kb2MsXG4gICAgZXZlbnRzID0gW1xuICAgICAgICBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZWRvd25cIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLFxuICAgICAgICBcIm1vdXNlb3ZlclwiLCBcIm1vdXNldXBcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIixcbiAgICAgICAgXCJ0b3VjaGNhbmNlbFwiXG4gICAgXSxcbiAgICB0b3VjaE1hcCA9IHtcbiAgICAgICAgbW91c2Vkb3duOiBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgbW91c2Vtb3ZlOiBcInRvdWNobW92ZVwiLFxuICAgICAgICBtb3VzZXVwOiBcInRvdWNoZW5kXCJcbiAgICB9LFxuICAgIGdldFNjcm9sbCA9IGZ1bmN0aW9uICh4eSwgZWwpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB4eSA9PSBcInlcIiA/IFwic2Nyb2xsVG9wXCIgOiBcInNjcm9sbExlZnRcIixcbiAgICAgICAgICAgIGRvYyA9IGVsICYmIGVsLm5vZGUgPyBlbC5ub2RlLm93bmVyRG9jdW1lbnQgOiBnbG9iLmRvYztcbiAgICAgICAgcmV0dXJuIGRvY1tuYW1lIGluIGRvYy5kb2N1bWVudEVsZW1lbnQgPyBcImRvY3VtZW50RWxlbWVudFwiIDogXCJib2R5XCJdW25hbWVdO1xuICAgIH0sXG4gICAgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9LFxuICAgIHByZXZlbnRUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBzdG9wVG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciByZWFsTmFtZSA9IHN1cHBvcnRzVG91Y2ggJiYgdG91Y2hNYXBbdHlwZV0gPyB0b3VjaE1hcFt0eXBlXSA6IHR5cGUsXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IGdldFNjcm9sbChcInlcIiwgZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW2hhc10odHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzW2ldLnRhcmdldCA9PSBvYmogfHwgb2JqLmNvbnRhaW5zKGUudGFyZ2V0VG91Y2hlc1tpXS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZGUgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRhcmdldFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ID0gb2xkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gcHJldmVudFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5jbGllbnRYICsgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGUuY2xpZW50WSArIHNjcm9sbFk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbWVudCwgZSwgeCwgeSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlICE9PSByZWFsTmFtZSkge1xuICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIocmVhbE5hbWUsIGYsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHJlYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWFsTmFtZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkcmFnID0gW10sXG4gICAgZHJhZ01vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgICBzY3JvbGxZID0gZ2V0U2Nyb2xsKFwieVwiKSxcbiAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIpLFxuICAgICAgICAgICAgZHJhZ2ksXG4gICAgICAgICAgICBqID0gZHJhZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIGRyYWdpID0gZHJhZ1tqXTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaCA9IGUudG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT0gZHJhZ2kuZWwuX2RyYWcuaWQgfHwgZHJhZ2kuZWwubm9kZS5jb250YWlucyh0b3VjaC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCA/IGUub3JpZ2luYWxFdmVudCA6IGUpLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkcmFnaS5lbC5ub2RlLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIC8vIG8gPSBkcmFnaS5lbC5wYXBlci5nZXRFbGVtZW50QnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiAobmV4dCA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgLy8gbyAmJiBldmUoXCJzbmFwLmRyYWcub3Zlci5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbCwgbyk7XG4gICAgICAgICAgICB4ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICB5ICs9IHNjcm9sbFk7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcubW92ZS5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5tb3ZlX3Njb3BlIHx8IGRyYWdpLmVsLCB4IC0gZHJhZ2kuZWwuX2RyYWcueCwgeSAtIGRyYWdpLmVsLl9kcmFnLnksIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkcmFnVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBTbmFwLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgdmFyIGkgPSBkcmFnLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbaV07XG4gICAgICAgICAgICBkcmFnaS5lbC5fZHJhZyA9IHt9O1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnLmVuZC5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbmRfc2NvcGUgfHwgZHJhZ2kuc3RhcnRfc2NvcGUgfHwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgZSk7XG4gICAgICAgICAgICBldmUub2ZmKFwic25hcC5kcmFnLiouXCIgKyBkcmFnaS5lbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZyA9IFtdO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBjbGljayBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBkb3VibGUgY2xpY2sgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmRibGNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgZG91YmxlIGNsaWNrIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZWRvd24gZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlZG93blxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlZG93biBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2Vtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2Vtb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2VvdXQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2VvdXQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNlb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2VvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2VvdmVyIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZXVwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2V1cCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNldXAgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaHN0YXJ0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaHN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hzdGFydCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2htb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaG1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hjYW5jZWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hjYW5jZWwgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGZvciAodmFyIGkgPSBldmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBTbmFwW2V2ZW50TmFtZV0gPSBlbHByb3RvW2V2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNuYXAuaXMoZm4sIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmOiBmbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZDogYWRkRXZlbnQodGhpcy5ub2RlIHx8IGRvY3VtZW50LCBldmVudE5hbWUsIGZuLCBzY29wZSB8fCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAodGhpcy5ldmVudHNbaV0ubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbaV0uZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTbmFwW1widW5cIiArIGV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgZWxwcm90b1tcInVuXCIgKyBldmVudE5hbWVdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBsID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobC0tKSBpZiAoZXZlbnRzW2xdLm5hbWUgPT0gZXZlbnROYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50c1tsXS5mID09IGZuIHx8ICFmbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzW2xdLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaWNlKGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAhZXZlbnRzLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5ldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50c1tpXSk7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmhvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGhvdmVyIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gZl9pbiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIGluXG4gICAgIC0gZl9vdXQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBvdXRcbiAgICAgLSBpY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgaG92ZXIgaW4gaGFuZGxlclxuICAgICAtIG9jb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBob3ZlciBvdXQgaGFuZGxlclxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaG92ZXIgPSBmdW5jdGlvbiAoZl9pbiwgZl9vdXQsIHNjb3BlX2luLCBzY29wZV9vdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VvdmVyKGZfaW4sIHNjb3BlX2luKS5tb3VzZW91dChmX291dCwgc2NvcGVfb3V0IHx8IHNjb3BlX2luKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuaG92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgaG92ZXIgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGZfaW4gKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBpblxuICAgICAtIGZfb3V0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgb3V0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51bmhvdmVyID0gZnVuY3Rpb24gKGZfaW4sIGZfb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVubW91c2VvdmVyKGZfaW4pLnVubW91c2VvdXQoZl9vdXQpO1xuICAgIH07XG4gICAgdmFyIGRyYWdnYWJsZSA9IFtdO1xuICAgIC8vIFNJRVJSQSB1bmNsZWFyIHdoYXQgX2NvbnRleHRfIHJlZmVycyB0byBmb3Igc3RhcnRpbmcsIGVuZGluZywgbW92aW5nIHRoZSBkcmFnIGdlc3R1cmUuXG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZHJhZygpOiBfeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VfOiBXaGVyZSBhcmUgdGhlIHgveSB2YWx1ZXMgb2Zmc2V0IGZyb20/XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZHJhZygpOiBtdWNoIG9mIHRoaXMgbWVtYmVyJ3MgZG9jIGFwcGVhcnMgdG8gYmUgZHVwbGljYXRlZCBmb3Igc29tZSByZWFzb24uXG4gICAgLy8gU0lFUlJBIFVuY2xlYXIgYWJvdXQgdGhpcyBzZW50ZW5jZTogX0FkZGl0aW9uYWxseSBmb2xsb3dpbmcgZHJhZyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQ6IGRyYWcuc3RhcnQuPGlkPiBvbiBzdGFydCwgZHJhZy5lbmQuPGlkPiBvbiBlbmQgYW5kIGRyYWcubW92ZS48aWQ+IG9uIGV2ZXJ5IG1vdmUuXyBJcyB0aGVyZSBhIGdsb2JhbCBfZHJhZ18gb2JqZWN0IHRvIHdoaWNoIHlvdSBjYW4gYXNzaWduIGhhbmRsZXJzIGtleWVkIGJ5IGFuIGVsZW1lbnQncyBJRD9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kcmFnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBhbiBlbGVtZW50J3MgZHJhZyBnZXN0dXJlXG4gICAgICoqXG4gICAgIC0gb25tb3ZlIChmdW5jdGlvbikgaGFuZGxlciBmb3IgbW92aW5nXG4gICAgIC0gb25zdGFydCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGRyYWcgc3RhcnRcbiAgICAgLSBvbmVuZCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGRyYWcgZW5kXG4gICAgIC0gbWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIG1vdmluZyBoYW5kbGVyXG4gICAgIC0gc2NvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGRyYWcgc3RhcnQgaGFuZGxlclxuICAgICAtIGVjb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBkcmFnIGVuZCBoYW5kbGVyXG4gICAgICogQWRkaXRpb25hbHkgZm9sbG93aW5nIGBkcmFnYCBldmVudHMgYXJlIHRyaWdnZXJlZDogYGRyYWcuc3RhcnQuPGlkPmAgb24gc3RhcnQsIFxuICAgICAqIGBkcmFnLmVuZC48aWQ+YCBvbiBlbmQgYW5kIGBkcmFnLm1vdmUuPGlkPmAgb24gZXZlcnkgbW92ZS4gV2hlbiBlbGVtZW50IGlzIGRyYWdnZWQgb3ZlciBhbm90aGVyIGVsZW1lbnQgXG4gICAgICogYGRyYWcub3Zlci48aWQ+YCBmaXJlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogU3RhcnQgZXZlbnQgYW5kIHN0YXJ0IGhhbmRsZXIgYXJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogTW92ZSBldmVudCBhbmQgbW92ZSBoYW5kbGVyIGFyZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIGR4IChudW1iZXIpIHNoaWZ0IGJ5IHggZnJvbSB0aGUgc3RhcnQgcG9pbnRcbiAgICAgbyBkeSAobnVtYmVyKSBzaGlmdCBieSB5IGZyb20gdGhlIHN0YXJ0IHBvaW50XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogRW5kIGV2ZW50IGFuZCBlbmQgaGFuZGxlciBhcmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5kcmFnID0gZnVuY3Rpb24gKG9ubW92ZSwgb25zdGFydCwgb25lbmQsIG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ1RyYW5zZm9ybTtcbiAgICAgICAgICAgIHJldHVybiBlbC5kcmFnKGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IG9yaWdUcmFuc2Zvcm0gKyAob3JpZ1RyYW5zZm9ybSA/IFwiVFwiIDogXCJ0XCIpICsgW2R4LCBkeV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvcmlnVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0oKS5sb2NhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0KGUsIHgsIHkpIHtcbiAgICAgICAgICAgIChlLm9yaWdpbmFsRXZlbnQgfHwgZSkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVsLl9kcmFnLnggPSB4O1xuICAgICAgICAgICAgZWwuX2RyYWcueSA9IHk7XG4gICAgICAgICAgICBlbC5fZHJhZy5pZCA9IGUuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICFkcmFnLmxlbmd0aCAmJiBTbmFwLm1vdXNlbW92ZShkcmFnTW92ZSkubW91c2V1cChkcmFnVXApO1xuICAgICAgICAgICAgZHJhZy5wdXNoKHtlbDogZWwsIG1vdmVfc2NvcGU6IG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlOiBzdGFydF9zY29wZSwgZW5kX3Njb3BlOiBlbmRfc2NvcGV9KTtcbiAgICAgICAgICAgIG9uc3RhcnQgJiYgZXZlLm9uKFwic25hcC5kcmFnLnN0YXJ0LlwiICsgZWwuaWQsIG9uc3RhcnQpO1xuICAgICAgICAgICAgb25tb3ZlICYmIGV2ZS5vbihcInNuYXAuZHJhZy5tb3ZlLlwiICsgZWwuaWQsIG9ubW92ZSk7XG4gICAgICAgICAgICBvbmVuZCAmJiBldmUub24oXCJzbmFwLmRyYWcuZW5kLlwiICsgZWwuaWQsIG9uZW5kKTtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZy5zdGFydC5cIiArIGVsLmlkLCBzdGFydF9zY29wZSB8fCBtb3ZlX3Njb3BlIHx8IGVsLCB4LCB5LCBlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KGUsIHgsIHkpIHtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZ2luaXQuXCIgKyBlbC5pZCwgZWwsIGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAuZHJhZ2luaXQuXCIgKyBlbC5pZCwgc3RhcnQpO1xuICAgICAgICBlbC5fZHJhZyA9IHt9O1xuICAgICAgICBkcmFnZ2FibGUucHVzaCh7ZWw6IGVsLCBzdGFydDogc3RhcnQsIGluaXQ6IGluaXR9KTtcbiAgICAgICAgZWwubW91c2Vkb3duKGluaXQpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIEVsZW1lbnQub25EcmFnT3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2hvcnRjdXQgdG8gYXNzaWduIGV2ZW50IGhhbmRsZXIgZm9yIGBkcmFnLm92ZXIuPGlkPmAgZXZlbnQsIHdoZXJlIGBpZGAgaXMgdGhlIGVsZW1lbnQncyBgaWRgIChzZWUgQEVsZW1lbnQuaWQpXG4gICAgIC0gZiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGV2ZW50LCBmaXJzdCBhcmd1bWVudCB3b3VsZCBiZSB0aGUgZWxlbWVudCB5b3UgYXJlIGRyYWdnaW5nIG92ZXJcbiAgICBcXCovXG4gICAgLy8gZWxwcm90by5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGYpIHtcbiAgICAvLyAgICAgZiA/IGV2ZS5vbihcInNuYXAuZHJhZy5vdmVyLlwiICsgdGhpcy5pZCwgZikgOiBldmUudW5iaW5kKFwic25hcC5kcmFnLm92ZXIuXCIgKyB0aGlzLmlkKTtcbiAgICAvLyB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZHJhZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgZHJhZyBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udW5kcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IGRyYWdnYWJsZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIGlmIChkcmFnZ2FibGVbaV0uZWwgPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy51bm1vdXNlZG93bihkcmFnZ2FibGVbaV0uaW5pdCk7XG4gICAgICAgICAgICBkcmFnZ2FibGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgZXZlLnVuYmluZChcInNuYXAuZHJhZy4qLlwiICsgdGhpcy5pZCk7XG4gICAgICAgICAgICBldmUudW5iaW5kKFwic25hcC5kcmFnaW5pdC5cIiArIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgICFkcmFnZ2FibGUubGVuZ3RoICYmIFNuYXAudW5tb3VzZW1vdmUoZHJhZ01vdmUpLnVubW91c2V1cChkcmFnVXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIHBwcm90byA9IFBhcGVyLnByb3RvdHlwZSxcbiAgICAgICAgcmd1cmwgPSAvXlxccyp1cmxcXCgoLispXFwpLyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICAkID0gU25hcC5fLiQ7XG4gICAgU25hcC5maWx0ZXIgPSB7fTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZmlsdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxmaWx0ZXI+YCBlbGVtZW50XG4gICAgICoqXG4gICAgIC0gZmlsc3RyIChzdHJpbmcpIFNWRyBmcmFnbWVudCBvZiBmaWx0ZXIgcHJvdmlkZWQgYXMgYSBzdHJpbmdcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgICAqIE5vdGU6IEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBmaWx0ZXJzIGVtYmVkZGVkIGludG8gdGhlIHBhZ2UgaW5zaWRlIGFuIGVtcHR5IFNWRyBlbGVtZW50LlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGYgPSBwYXBlci5maWx0ZXIoJzxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCIyXCIvPicpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBwcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gKGZpbHN0cikge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzO1xuICAgICAgICBpZiAocGFwZXIudHlwZSAhPSBcInN2Z1wiKSB7XG4gICAgICAgICAgICBwYXBlciA9IHBhcGVyLnBhcGVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gU25hcC5wYXJzZShTdHIoZmlsc3RyKSksXG4gICAgICAgICAgICBpZCA9IFNuYXAuXy5pZCgpLFxuICAgICAgICAgICAgd2lkdGggPSBwYXBlci5ub2RlLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gcGFwZXIubm9kZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBmaWx0ZXIgPSAkKFwiZmlsdGVyXCIpO1xuICAgICAgICAkKGZpbHRlciwge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZmlsdGVyVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGYubm9kZSk7XG4gICAgICAgIHBhcGVyLmRlZnMuYXBwZW5kQ2hpbGQoZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGZpbHRlcik7XG4gICAgfTtcblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZmlsdGVyXCIpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gU3RyKHApLm1hdGNoKHJndXJsKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBTbmFwLnNlbGVjdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5maWx0ZXJcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdmFsdWUudHlwZSA9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIGlkID0gdmFsdWUubm9kZS5pZDtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtpZDogdmFsdWUuaWR9KTtcbiAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IFNuYXAudXJsKGlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuYmx1clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGJsdXIgZmlsdGVyXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSBhbW91bnQgb2YgaG9yaXpvbnRhbCBibHVyLCBpbiBwaXhlbHNcbiAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgdmVydGljYWwgYmx1ciwgaW4gcGl4ZWxzXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcihTbmFwLmZpbHRlci5ibHVyKDUsIDEwKSksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJsdXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0geSA9PSBudWxsID8geCA6IFt4LCB5XTtcbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCdcXDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCJ7ZGVmfVwiLz4nLCB7XG4gICAgICAgICAgICBkZWY6IGRlZlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJsdXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2hhZG93XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2hhZG93IGZpbHRlclxuICAgICAqKlxuICAgICAtIGR4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGR5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBibHVyIChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgYmx1clxuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIG9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIHdoaWNoIG1ha2VzIGJsdXIgZGVmYXVsdCB0byBgNGAuIE9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIG9wYWNpdHkgKG51bWJlcikgI29wdGlvbmFsIGAwLi4xYCBvcGFjaXR5IG9mIHRoZSBzaGFkb3dcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKFNuYXAuZmlsdGVyLnNoYWRvdygwLCAyLCAuMykpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zaGFkb3cgPSBmdW5jdGlvbiAoZHgsIGR5LCBibHVyLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICBpZiAob3BhY2l0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBibHVyO1xuICAgICAgICAgICAgICAgIGJsdXIgPSA0O1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGJsdXI7XG4gICAgICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IFNuYXAuY29sb3IoY29sb3IpO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwie2JsdXJ9XCIvPjxmZU9mZnNldCBkeD1cIntkeH1cIiBkeT1cIntkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPjxmZUZsb29kIGZsb29kLWNvbG9yPVwie2NvbG9yfVwiLz48ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1clwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY0EgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie29wYWNpdHl9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+PC9mZU1lcmdlPicsIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeSxcbiAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2hhZG93LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmdyYXlzY2FsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGdyYXlzY2FsZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7Yn0ge2h9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4yMTI2ICsgMC43ODc0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43MTUyIC0gMC43MTUyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC43MTUyICsgMC4yODQ4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC4wNzIyICsgMC45Mjc4ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuZ3JheXNjYWxlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLnNlcGlhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2VwaWEgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuc2VwaWEgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7aH0ge2l9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4zOTMgKyAwLjYwNyAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzY5IC0gMC43NjkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjE4OSAtIDAuMTg5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4zNDkgLSAwLjM0OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNjg2ICsgMC4zMTQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjE2OCAtIDAuMTY4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yNzIgLSAwLjI3MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuNTM0IC0gMC41MzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBpOiAwLjEzMSArIDAuODY5ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2VwaWEudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2F0dXJhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzYXR1cmF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwie2Ftb3VudH1cIi8+Jywge1xuICAgICAgICAgICAgYW1vdW50OiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2F0dXJhdGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuaHVlUm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgaHVlLXJvdGF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvblxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5odWVSb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJodWVSb3RhdGVcIiB2YWx1ZXM9XCJ7YW5nbGV9XCIvPicsIHtcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmh1ZVJvdGF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5pbnZlcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBpbnZlcnQgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbi8vICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPVwibWF0cml4XCIgdmFsdWVzPVwiLTEgMCAwIDAgMSAgMCAtMSAwIDAgMSAgMCAwIC0xIDAgMSAgMCAwIDAgMSAwXCIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPVwic1JHQlwiLz5cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+Jywge1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmJyaWdodG5lc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBicmlnaHRuZXNzIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuY29udHJhc3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBjb250cmFzdCBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5jb250cmFzdCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPicsIHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogLjUgLSBhbW91bnQgLyAyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuY29udHJhc3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGJveCA9IFNuYXAuXy5ib3gsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgZmlyc3RMZXR0ZXIgPSAvXlteYS16XSooW3RibWxyY10pL2ksXG4gICAgICAgIHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVFwiICsgdGhpcy5keCArIFwiLFwiICsgdGhpcy5keTtcbiAgICAgICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRBbGlnblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzaGlmdCBuZWVkZWQgdG8gYWxpZ24gdGhlIGVsZW1lbnQgcmVsYXRpdmVseSB0byBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIG5vIGVsZW1lbnRzIHNwZWNpZmllZCwgcGFyZW50IGA8c3ZnPmAgY29udGFpbmVyIHdpbGwgYmUgdXNlZC5cbiAgICAgLSBlbCAob2JqZWN0KSBAb3B0aW9uYWwgYWxpZ25tZW50IGVsZW1lbnRcbiAgICAgLSB3YXkgKHN0cmluZykgb25lIG9mIHNpeCB2YWx1ZXM6IGBcInRvcFwiYCwgYFwibWlkZGxlXCJgLCBgXCJib3R0b21cImAsIGBcImxlZnRcImAsIGBcImNlbnRlclwiYCwgYFwicmlnaHRcImBcbiAgICAgPSAob2JqZWN0fHN0cmluZykgT2JqZWN0IGluIGZvcm1hdCBge2R4OiAsIGR5OiB9YCBhbHNvIGhhcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBhIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgICA+IFVzYWdlXG4gICAgIHwgZWwudHJhbnNmb3JtKGVsLmdldEFsaWduKGVsMiwgXCJ0b3BcIikpO1xuICAgICAqIG9yXG4gICAgIHwgdmFyIGR5ID0gZWwuZ2V0QWxpZ24oZWwyLCBcInRvcFwiKS5keTtcbiAgICBcXCovXG4gICAgRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxpZ24gPSBmdW5jdGlvbiAoZWwsIHdheSkge1xuICAgICAgICBpZiAod2F5ID09IG51bGwgJiYgaXMoZWwsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB3YXkgPSBlbDtcbiAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBieCA9IGVsLmdldEJCb3ggPyBlbC5nZXRCQm94KCkgOiBib3goZWwpLFxuICAgICAgICAgICAgYmIgPSB0aGlzLmdldEJCb3goKSxcbiAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICB3YXkgPSB3YXkgJiYgd2F5Lm1hdGNoKGZpcnN0TGV0dGVyKTtcbiAgICAgICAgd2F5ID0gd2F5ID8gd2F5WzFdLnRvTG93ZXJDYXNlKCkgOiBcImNcIjtcbiAgICAgICAgc3dpdGNoICh3YXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC55IC0gYmIueTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSAwO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IGJ4LnkyIC0gYmIueTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC5jeSAtIGJiLmN5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LnggLSBiYi54O1xuICAgICAgICAgICAgICAgIG91dC5keSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gYngueDIgLSBiYi54MjtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LmN4IC0gYmIuY3g7XG4gICAgICAgICAgICAgICAgb3V0LmR5ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG91dC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWxpZ25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFsaWducyB0aGUgZWxlbWVudCByZWxhdGl2ZWx5IHRvIGdpdmVuIG9uZSB2aWEgdHJhbnNmb3JtYXRpb24uXG4gICAgICogSWYgbm8gZWxlbWVudHMgc3BlY2lmaWVkLCBwYXJlbnQgYDxzdmc+YCBjb250YWluZXIgd2lsbCBiZSB1c2VkLlxuICAgICAtIGVsIChvYmplY3QpIEBvcHRpb25hbCBhbGlnbm1lbnQgZWxlbWVudFxuICAgICAtIHdheSAoc3RyaW5nKSBvbmUgb2Ygc2l4IHZhbHVlczogYFwidG9wXCJgLCBgXCJtaWRkbGVcImAsIGBcImJvdHRvbVwiYCwgYFwibGVmdFwiYCwgYFwiY2VudGVyXCJgLCBgXCJyaWdodFwiYFxuICAgICA9IChvYmplY3QpIHRoaXMgZWxlbWVudFxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYWxpZ24oZWwyLCBcInRvcFwiKTtcbiAgICAgKiBvclxuICAgICB8IGVsLmFsaWduKFwibWlkZGxlXCIpO1xuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hbGlnbiA9IGZ1bmN0aW9uIChlbCwgd2F5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShcIi4uLlwiICsgdGhpcy5nZXRBbGlnbihlbCwgd2F5KSk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIjtcbiAgICBmdW5jdGlvbiBzbGljZShmcm9tLCB0bywgZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGFyci5zbGljZShmcm9tLCB0byk7XG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYgPyBmKHJlcykgOiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMuZHVyID0gbXM7XG4gICAgICAgIGVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBlYXNpbmcpO1xuICAgICAgICBjYWxsYmFjayAmJiAodGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFNuYXAuXy5BbmltYXRpb24gPSBBbmltYXRpb247XG4gICAgLypcXFxuICAgICAqIFNuYXAuYW5pbWF0aW9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFuIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgLSBhdHRyIChvYmplY3QpIGF0dHJpYnV0ZXMgb2YgZmluYWwgZGVzdGluYXRpb25cbiAgICAgLSBkdXJhdGlvbiAobnVtYmVyKSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgb25lIG9mIGVhc2luZyBmdW5jdGlvbnMgb2YgQG1pbmEgb3IgY3VzdG9tIG9uZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiBhbmltYXRpb24gZW5kc1xuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3RcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5BbmltXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGEgc2V0IG9mIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgYWJsZSB0byBtYW5pcHVsYXRlIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBhbmltIChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3QsXG4gICAgIG8gICAgIG1pbmEgKG9iamVjdCkgQG1pbmEgb2JqZWN0LFxuICAgICBvICAgICBjdXJTdGF0dXMgKG51bWJlcikgMC4uMSDigJQgc3RhdHVzIG9mIHRoZSBhbmltYXRpb246IDAg4oCUIGp1c3Qgc3RhcnRlZCwgMSDigJQganVzdCBmaW5pc2hlZCxcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5BbmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkIGluIGVsLmFuaW1zKSBpZiAoZWwuYW5pbXNbaGFzXShpZCkpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbTogbmV3IEFuaW1hdGlvbihhLl9hdHRycywgYS5kdXIsIGEuZWFzaW5nLCBhLl9jYWxsYmFjayksXG4gICAgICAgICAgICAgICAgICAgIG1pbmE6IGEsXG4gICAgICAgICAgICAgICAgICAgIGN1clN0YXR1czogYS5zdGF0dXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGF0dXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0oZWwuYW5pbXNbaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJ1bnMgZ2VuZXJpYyBhbmltYXRpb24gb2Ygb25lIG51bWJlciBpbnRvIGFub3RoZXIgd2l0aCBhIGNhcmluZyBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcnxhcnJheSkgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnNcbiAgICAgLSB0byAobnVtYmVyfGFycmF5KSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAtIHNldHRlciAoZnVuY3Rpb24pIGNhcmluZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG51bWJlciBhcmd1bWVudFxuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGFuaW1hdGlvbiBlbmRzXG4gICAgID0gKG9iamVjdCkgYW5pbWF0aW9uIG9iamVjdCBpbiBAbWluYSBmb3JtYXRcbiAgICAgbyB7XG4gICAgIG8gICAgIGlkIChzdHJpbmcpIGFuaW1hdGlvbiBpZCwgY29uc2lkZXIgaXQgcmVhZC1vbmx5LFxuICAgICBvICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgZWFzaW5nIChmdW5jdGlvbikgZWFzaW5nLFxuICAgICBvICAgICBzcGVlZCAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgIHwgdmFyIHJlY3QgPSBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApO1xuICAgICB8IFNuYXAuYW5pbWF0ZSgwLCAxMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICB8ICAgICByZWN0LmF0dHIoe1xuICAgICB8ICAgICAgICAgeDogdmFsXG4gICAgIHwgICAgIH0pO1xuICAgICB8IH0sIDEwMDApO1xuICAgICB8IC8vIGluIGdpdmVuIGNvbnRleHQgaXMgZXF1aXZhbGVudCB0b1xuICAgICB8IHJlY3QuYW5pbWF0ZSh7eDogMTB9LCAxMDAwKTtcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzZXR0ZXIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShmcm9tLCB0bywgbm93LCBub3cgKyBtcywgbWluYS50aW1lLCBzZXR0ZXIsIGVhc2luZyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbXMgPSB0aGlzLmluQW5pbSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbmltcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBhbmltc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIGF0dHJzIChvYmplY3QpIGtleS12YWx1ZSBwYWlycyBvZiBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIHRoZSBhbmltYXRpb24gZW5kc1xuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdHRycy5jYWxsYmFjaztcbiAgICAgICAgICAgIGVhc2luZyA9IGF0dHJzLmVhc2luZztcbiAgICAgICAgICAgIG1zID0gYXR0cnMuZHVyO1xuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5hdHRyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBma2V5cyA9IFtdLCB0a2V5cyA9IFtdLCBrZXlzID0ge30sIGZyb20sIHRvLCBmLCBlcSxcbiAgICAgICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSBpZiAoYXR0cnNbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoZWwuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICBlcSA9IGVsLmVxdWFsKGtleSwgU3RyKGF0dHJzW2tleV0pKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gZXEuZnJvbTtcbiAgICAgICAgICAgICAgICB0byA9IGVxLnRvO1xuICAgICAgICAgICAgICAgIGYgPSBlcS5mO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gK2VsLmF0dHIoa2V5KTtcbiAgICAgICAgICAgICAgICB0byA9ICthdHRyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IGlzKGZyb20sIFwiYXJyYXlcIikgPyBmcm9tLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICBrZXlzW2tleV0gPSBzbGljZShma2V5cy5sZW5ndGgsIGZrZXlzLmxlbmd0aCArIGxlbiwgZik7XG4gICAgICAgICAgICBma2V5cyA9IGZrZXlzLmNvbmNhdChmcm9tKTtcbiAgICAgICAgICAgIHRrZXlzID0gdGtleXMuY29uY2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShma2V5cywgdGtleXMsIG5vdywgbm93ICsgbXMsIG1pbmEudGltZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGtleXMpIGlmIChrZXlzW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyW2tleV0gPSBrZXlzW2tleV0odmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYXR0cihhdHRyKTtcbiAgICAgICAgICAgIH0sIGVhc2luZyk7XG4gICAgICAgIGVsLmFuaW1zW2FuaW0uaWRdID0gYW5pbTtcbiAgICAgICAgYW5pbS5fYXR0cnMgPSBhdHRycztcbiAgICAgICAgYW5pbS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgZXZlKFwic25hcC5hbmltY3JlYXRlZC5cIiArIGVsLmlkLCBhbmltKTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLmZpbmlzaC5cIiArIGFuaW0uaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5vZmYoXCJtaW5hLiouXCIgKyBhbmltLmlkKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5hbmltc1thbmltLmlkXTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLnN0b3AuXCIgKyBhbmltLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUub2ZmKFwibWluYS4qLlwiICsgYW5pbS5pZCk7XG4gICAgICAgICAgICBkZWxldGUgZWwuYW5pbXNbYW5pbS5pZF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICAvLyBDb2xvdXJzIGFyZSBmcm9tIGh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY29cbiAgICB2YXIgcmVkICAgICAgICAgPSBcIiNmZmViZWUjZmZjZGQyI2VmOWE5YSNlNTczNzMjZWY1MzUwI2Y0NDMzNiNlNTM5MzUjZDMyZjJmI2M2MjgyOCNiNzFjMWMjZmY4YTgwI2ZmNTI1MiNmZjE3NDQjZDUwMDAwXCIsXG4gICAgICAgIHBpbmsgICAgICAgID0gXCIjRkNFNEVDI0Y4QkJEMCNGNDhGQjEjRjA2MjkyI0VDNDA3QSNFOTFFNjMjRDgxQjYwI0MyMTg1QiNBRDE0NTcjODgwRTRGI0ZGODBBQiNGRjQwODEjRjUwMDU3I0M1MTE2MlwiLFxuICAgICAgICBwdXJwbGUgICAgICA9IFwiI0YzRTVGNSNFMUJFRTcjQ0U5M0Q4I0JBNjhDOCNBQjQ3QkMjOUMyN0IwIzhFMjRBQSM3QjFGQTIjNkExQjlBIzRBMTQ4QyNFQTgwRkMjRTA0MEZCI0Q1MDBGOSNBQTAwRkZcIixcbiAgICAgICAgZGVlcHB1cnBsZSAgPSBcIiNFREU3RjYjRDFDNEU5I0IzOUREQiM5NTc1Q0QjN0U1N0MyIzY3M0FCNyM1RTM1QjEjNTEyREE4IzQ1MjdBMCMzMTFCOTIjQjM4OEZGIzdDNERGRiM2NTFGRkYjNjIwMEVBXCIsXG4gICAgICAgIGluZGlnbyAgICAgID0gXCIjRThFQUY2I0M1Q0FFOSM5RkE4REEjNzk4NkNCIzVDNkJDMCMzRjUxQjUjMzk0OUFCIzMwM0Y5RiMyODM1OTMjMUEyMzdFIzhDOUVGRiM1MzZERkUjM0Q1QUZFIzMwNEZGRVwiLFxuICAgICAgICBibHVlICAgICAgICA9IFwiI0UzRjJGRCNCQkRFRkIjOTBDQUY5IzY0QjVGNiM2NEI1RjYjMjE5NkYzIzFFODhFNSMxOTc2RDIjMTU2NUMwIzBENDdBMSM4MkIxRkYjNDQ4QUZGIzI5NzlGRiMyOTYyRkZcIixcbiAgICAgICAgbGlnaHRibHVlICAgPSBcIiNFMUY1RkUjQjNFNUZDIzgxRDRGQSM0RkMzRjcjMjlCNkY2IzAzQTlGNCMwMzlCRTUjMDI4OEQxIzAyNzdCRCMwMTU3OUIjODBEOEZGIzQwQzRGRiMwMEIwRkYjMDA5MUVBXCIsXG4gICAgICAgIGN5YW4gICAgICAgID0gXCIjRTBGN0ZBI0IyRUJGMiM4MERFRUEjNEREMEUxIzI2QzZEQSMwMEJDRDQjMDBBQ0MxIzAwOTdBNyMwMDgzOEYjMDA2MDY0Izg0RkZGRiMxOEZGRkYjMDBFNUZGIzAwQjhENFwiLFxuICAgICAgICB0ZWFsICAgICAgICA9IFwiI0UwRjJGMSNCMkRGREIjODBDQkM0IzREQjZBQyMyNkE2OUEjMDA5Njg4IzAwODk3QiMwMDc5NkIjMDA2OTVDIzAwNEQ0MCNBN0ZGRUIjNjRGRkRBIzFERTlCNiMwMEJGQTVcIixcbiAgICAgICAgZ3JlZW4gICAgICAgPSBcIiNFOEY1RTkjQzhFNkM5I0E1RDZBNyM4MUM3ODQjNjZCQjZBIzRDQUY1MCM0M0EwNDcjMzg4RTNDIzJFN0QzMiMxQjVFMjAjQjlGNkNBIzY5RjBBRSMwMEU2NzYjMDBDODUzXCIsXG4gICAgICAgIGxpZ2h0Z3JlZW4gID0gXCIjRjFGOEU5I0RDRURDOCNDNUUxQTUjQUVENTgxIzlDQ0M2NSM4QkMzNEEjN0NCMzQyIzY4OUYzOCM1NThCMkYjMzM2OTFFI0NDRkY5MCNCMkZGNTkjNzZGRjAzIzY0REQxN1wiLFxuICAgICAgICBsaW1lICAgICAgICA9IFwiI0Y5RkJFNyNGMEY0QzMjRTZFRTlDI0RDRTc3NSNENEUxNTcjQ0REQzM5I0MwQ0EzMyNBRkI0MkIjOUU5RDI0IzgyNzcxNyNGNEZGODEjRUVGRjQxI0M2RkYwMCNBRUVBMDBcIixcbiAgICAgICAgeWVsbG93ICAgICAgPSBcIiNGRkZERTcjRkZGOUM0I0ZGRjU5RCNGRkYxNzYjRkZFRTU4I0ZGRUIzQiNGREQ4MzUjRkJDMDJEI0Y5QTgyNSNGNTdGMTcjRkZGRjhEI0ZGRkYwMCNGRkVBMDAjRkZENjAwXCIsXG4gICAgICAgIGFtYmVyICAgICAgID0gXCIjRkZGOEUxI0ZGRUNCMyNGRkUwODIjRkZENTRGI0ZGQ0EyOCNGRkMxMDcjRkZCMzAwI0ZGQTAwMCNGRjhGMDAjRkY2RjAwI0ZGRTU3RiNGRkQ3NDAjRkZDNDAwI0ZGQUIwMFwiLFxuICAgICAgICBvcmFuZ2UgICAgICA9IFwiI0ZGRjNFMCNGRkUwQjIjRkZDQzgwI0ZGQjc0RCNGRkE3MjYjRkY5ODAwI0ZCOEMwMCNGNTdDMDAjRUY2QzAwI0U2NTEwMCNGRkQxODAjRkZBQjQwI0ZGOTEwMCNGRjZEMDBcIixcbiAgICAgICAgZGVlcG9yYW5nZSAgPSBcIiNGQkU5RTcjRkZDQ0JDI0ZGQUI5MSNGRjhBNjUjRkY3MDQzI0ZGNTcyMiNGNDUxMUUjRTY0QTE5I0Q4NDMxNSNCRjM2MEMjRkY5RTgwI0ZGNkU0MCNGRjNEMDAjREQyQzAwXCIsXG4gICAgICAgIGJyb3duICAgICAgID0gXCIjRUZFQkU5I0Q3Q0NDOCNCQ0FBQTQjQTE4ODdGIzhENkU2MyM3OTU1NDgjNkQ0QzQxIzVENDAzNyM0RTM0MkUjM0UyNzIzXCIsXG4gICAgICAgIGdyZXkgICAgICAgID0gXCIjRkFGQUZBI0Y1RjVGNSNFRUVFRUUjRTBFMEUwI0JEQkRCRCM5RTlFOUUjNzU3NTc1IzYxNjE2MSM0MjQyNDIjMjEyMTIxXCIsXG4gICAgICAgIGJsdWVncmV5ICAgID0gXCIjRUNFRkYxI0NGRDhEQyNCMEJFQzUjOTBBNEFFIzc4OTA5QyM2MDdEOEIjNTQ2RTdBIzQ1NUE2NCMzNzQ3NEYjMjYzMjM4XCI7XG4gICAgLypcXFxuICAgICAqIFNuYXAubXVpXG4gICAgIFsgcHJvcGVydHkgXVxuICAgICAqKlxuICAgICAqIENvbnRhaW4gTWF0ZXJpYWwgVUkgY29sb3Vycy5cbiAgICAgfCBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApLmF0dHIoe2ZpbGw6IFNuYXAubXVpLmRlZXBwdXJwbGUsIHN0cm9rZTogU25hcC5tdWkuYW1iZXJbNjAwXX0pO1xuICAgICAjIEZvciBjb2xvdXIgcmVmZXJlbmNlOiA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jb1wiPmh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY288L2E+LlxuICAgIFxcKi9cbiAgICBTbmFwLm11aSA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZsYXRcbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogQ29udGFpbiBGbGF0IFVJIGNvbG91cnMuXG4gICAgIHwgU25hcCgpLnJlY3QoMCwgMCwgMTAsIDEwKS5hdHRyKHtmaWxsOiBTbmFwLmZsYXQuY2Fycm90LCBzdHJva2U6IFNuYXAuZmxhdC53ZXRhc3BoYWx0fSk7XG4gICAgICMgRm9yIGNvbG91ciByZWZlcmVuY2U6IDxhIGhyZWY9XCJodHRwczovL3d3dy5tYXRlcmlhbHVpLmNvXCI+aHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jbzwvYT4uXG4gICAgXFwqL1xuICAgIFNuYXAuZmxhdCA9IHt9O1xuICAgIGZ1bmN0aW9uIHNhdmVDb2xvcihjb2xvcnMpIHtcbiAgICAgICAgY29sb3JzID0gY29sb3JzLnNwbGl0KC8oPz0jKS8pO1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgU3RyaW5nKGNvbG9yc1s1XSk7XG4gICAgICAgIGNvbG9yWzUwXSA9IGNvbG9yc1swXTtcbiAgICAgICAgY29sb3JbMTAwXSA9IGNvbG9yc1sxXTtcbiAgICAgICAgY29sb3JbMjAwXSA9IGNvbG9yc1syXTtcbiAgICAgICAgY29sb3JbMzAwXSA9IGNvbG9yc1szXTtcbiAgICAgICAgY29sb3JbNDAwXSA9IGNvbG9yc1s0XTtcbiAgICAgICAgY29sb3JbNTAwXSA9IGNvbG9yc1s1XTtcbiAgICAgICAgY29sb3JbNjAwXSA9IGNvbG9yc1s2XTtcbiAgICAgICAgY29sb3JbNzAwXSA9IGNvbG9yc1s3XTtcbiAgICAgICAgY29sb3JbODAwXSA9IGNvbG9yc1s4XTtcbiAgICAgICAgY29sb3JbOTAwXSA9IGNvbG9yc1s5XTtcbiAgICAgICAgaWYgKGNvbG9yc1sxMF0pIHtcbiAgICAgICAgICAgIGNvbG9yLkExMDAgPSBjb2xvcnNbMTBdO1xuICAgICAgICAgICAgY29sb3IuQTIwMCA9IGNvbG9yc1sxMV07XG4gICAgICAgICAgICBjb2xvci5BNDAwID0gY29sb3JzWzEyXTtcbiAgICAgICAgICAgIGNvbG9yLkE3MDAgPSBjb2xvcnNbMTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgU25hcC5tdWkucmVkID0gc2F2ZUNvbG9yKHJlZCk7XG4gICAgU25hcC5tdWkucGluayA9IHNhdmVDb2xvcihwaW5rKTtcbiAgICBTbmFwLm11aS5wdXJwbGUgPSBzYXZlQ29sb3IocHVycGxlKTtcbiAgICBTbmFwLm11aS5kZWVwcHVycGxlID0gc2F2ZUNvbG9yKGRlZXBwdXJwbGUpO1xuICAgIFNuYXAubXVpLmluZGlnbyA9IHNhdmVDb2xvcihpbmRpZ28pO1xuICAgIFNuYXAubXVpLmJsdWUgPSBzYXZlQ29sb3IoYmx1ZSk7XG4gICAgU25hcC5tdWkubGlnaHRibHVlID0gc2F2ZUNvbG9yKGxpZ2h0Ymx1ZSk7XG4gICAgU25hcC5tdWkuY3lhbiA9IHNhdmVDb2xvcihjeWFuKTtcbiAgICBTbmFwLm11aS50ZWFsID0gc2F2ZUNvbG9yKHRlYWwpO1xuICAgIFNuYXAubXVpLmdyZWVuID0gc2F2ZUNvbG9yKGdyZWVuKTtcbiAgICBTbmFwLm11aS5saWdodGdyZWVuID0gc2F2ZUNvbG9yKGxpZ2h0Z3JlZW4pO1xuICAgIFNuYXAubXVpLmxpbWUgPSBzYXZlQ29sb3IobGltZSk7XG4gICAgU25hcC5tdWkueWVsbG93ID0gc2F2ZUNvbG9yKHllbGxvdyk7XG4gICAgU25hcC5tdWkuYW1iZXIgPSBzYXZlQ29sb3IoYW1iZXIpO1xuICAgIFNuYXAubXVpLm9yYW5nZSA9IHNhdmVDb2xvcihvcmFuZ2UpO1xuICAgIFNuYXAubXVpLmRlZXBvcmFuZ2UgPSBzYXZlQ29sb3IoZGVlcG9yYW5nZSk7XG4gICAgU25hcC5tdWkuYnJvd24gPSBzYXZlQ29sb3IoYnJvd24pO1xuICAgIFNuYXAubXVpLmdyZXkgPSBzYXZlQ29sb3IoZ3JleSk7XG4gICAgU25hcC5tdWkuYmx1ZWdyZXkgPSBzYXZlQ29sb3IoYmx1ZWdyZXkpO1xuICAgIFNuYXAuZmxhdC50dXJxdW9pc2UgPSBcIiMxYWJjOWNcIjtcbiAgICBTbmFwLmZsYXQuZ3JlZW5zZWEgPSBcIiMxNmEwODVcIjtcbiAgICBTbmFwLmZsYXQuc3VuZmxvd2VyID0gXCIjZjFjNDBmXCI7XG4gICAgU25hcC5mbGF0Lm9yYW5nZSA9IFwiI2YzOWMxMlwiO1xuICAgIFNuYXAuZmxhdC5lbWVybGFuZCA9IFwiIzJlY2M3MVwiO1xuICAgIFNuYXAuZmxhdC5uZXBocml0aXMgPSBcIiMyN2FlNjBcIjtcbiAgICBTbmFwLmZsYXQuY2Fycm90ID0gXCIjZTY3ZTIyXCI7XG4gICAgU25hcC5mbGF0LnB1bXBraW4gPSBcIiNkMzU0MDBcIjtcbiAgICBTbmFwLmZsYXQucGV0ZXJyaXZlciA9IFwiIzM0OThkYlwiO1xuICAgIFNuYXAuZmxhdC5iZWxpemVob2xlID0gXCIjMjk4MGI5XCI7XG4gICAgU25hcC5mbGF0LmFsaXphcmluID0gXCIjZTc0YzNjXCI7XG4gICAgU25hcC5mbGF0LnBvbWVncmFuYXRlID0gXCIjYzAzOTJiXCI7XG4gICAgU25hcC5mbGF0LmFtZXRoeXN0ID0gXCIjOWI1OWI2XCI7XG4gICAgU25hcC5mbGF0Lndpc3RlcmlhID0gXCIjOGU0NGFkXCI7XG4gICAgU25hcC5mbGF0LmNsb3VkcyA9IFwiI2VjZjBmMVwiO1xuICAgIFNuYXAuZmxhdC5zaWx2ZXIgPSBcIiNiZGMzYzdcIjtcbiAgICBTbmFwLmZsYXQud2V0YXNwaGFsdCA9IFwiIzM0NDk1ZVwiO1xuICAgIFNuYXAuZmxhdC5taWRuaWdodGJsdWUgPSBcIiMyYzNlNTBcIjtcbiAgICBTbmFwLmZsYXQuY29uY3JldGUgPSBcIiM5NWE1YTZcIjtcbiAgICBTbmFwLmZsYXQuYXNiZXN0b3MgPSBcIiM3ZjhjOGRcIjtcbiAgICAvKlxcXG4gICAgICogU25hcC5pbXBvcnRNVUlDb2xvcnNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEltcG9ydHMgTWF0ZXJpYWwgVUkgY29sb3VycyBpbnRvIGdsb2JhbCBvYmplY3QuXG4gICAgIHwgU25hcC5pbXBvcnRNVUlDb2xvcnMoKTtcbiAgICAgfCBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApLmF0dHIoe2ZpbGw6IGRlZXBwdXJwbGUsIHN0cm9rZTogYW1iZXJbNjAwXX0pO1xuICAgICAjIEZvciBjb2xvdXIgcmVmZXJlbmNlOiA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jb1wiPmh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY288L2E+LlxuICAgIFxcKi9cbiAgICBTbmFwLmltcG9ydE1VSUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgY29sb3IgaW4gU25hcC5tdWkpIHtcbiAgICAgICAgICAgIGlmIChTbmFwLm11aS5oYXNPd25Qcm9wZXJ0eShjb2xvcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dbY29sb3JdID0gU25hcC5tdWlbY29sb3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBcbiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJldmUiLCJyZXF1aXJlIiwibWluYSIsImFuaW1hdGlvbnMiLCJyZXF1ZXN0QW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiRGF0ZSIsImdldFRpbWUiLCJyZXF1ZXN0SUQiLCJpc0FycmF5IiwiQXJyYXkiLCJhIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaWRnZW4iLCJpZHByZWZpeCIsIklEIiwiZGlmZiIsImIiLCJBIiwiQiIsInJlcyIsImkiLCJpaSIsImxlbmd0aCIsImRpZiIsImJiIiwidGltZXIiLCJub3ciLCJzdGEiLCJ2YWwiLCJzIiwiZHMiLCJkdXIiLCJzcGVlZCIsInNwZCIsImR1cmF0aW9uIiwic3RvcGl0IiwiaWQiLCJ1cGRhdGUiLCJwYXVzZSIsInBkaWYiLCJnZXQiLCJyZXN1bWUiLCJmcmFtZSIsInN0YXJ0IiwiaiIsImpqIiwiZW5kIiwiZWFzaW5nIiwic2V0IiwidGltZVN0YW1wIiwibGVuIiwiaGFzT3duUHJvcGVydHkiLCJhbmltIiwibGluZWFyIiwic3RhdHVzIiwic3RvcCIsInRpbWUiLCJnZXRCeUlkIiwibiIsImVhc2VvdXQiLCJNYXRoIiwicG93IiwiZWFzZWluIiwiZWFzZWlub3V0IiwicSIsIlEiLCJzcXJ0IiwieCIsIlgiLCJhYnMiLCJ5IiwiWSIsInQiLCJiYWNraW4iLCJiYWNrb3V0IiwiZWxhc3RpYyIsInNpbiIsIlBJIiwiYm91bmNlIiwicCIsImwiLCJTbmFwIiwicm9vdCIsInZlcnNpb24iLCJ3IiwiaCIsIm5vZGVUeXBlIiwid3JhcCIsImlzIiwiYXBwbHkiLCJFbGVtZW50IiwiZ2xvYiIsImRvYyIsInF1ZXJ5U2VsZWN0b3IiLCJTdHJpbmciLCJlIiwiUGFwZXIiLCJfIiwid2luIiwiZG9jdW1lbnQiLCJoYXMiLCJTdHIiLCJ0b0Zsb2F0IiwicGFyc2VGbG9hdCIsInRvSW50IiwicGFyc2VJbnQiLCJtYXRoIiwibW1heCIsIm1heCIsIm1taW4iLCJtaW4iLCJyb3VuZCIsIkUiLCJTIiwib2JqZWN0VG9TdHJpbmciLCJJU1VSTCIsImNvbG91clJlZ0V4cCIsImJlemllcnJnIiwic2VwYXJhdG9yIiwid2hpdGVzcGFjZSIsImNvbW1hU3BhY2VzIiwiaHNyZyIsImhzIiwicmciLCJwYXRoQ29tbWFuZCIsInRDb21tYW5kIiwicGF0aFZhbHVlcyIsImVsIiwidHlwZSIsInhsaW5rIiwieG1sbnMiLCJodWIiLCJVUkwiLCJ1cmwiLCIkIiwiYXR0ciIsImNyZWF0ZVRleHROb2RlIiwidGV4dCIsImNyZWF0ZUNvbW1lbnQiLCJzdWJzdHJpbmciLCJnZXRBdHRyaWJ1dGVOUyIsImdldEF0dHJpYnV0ZSIsIm5vZGVWYWx1ZSIsImtleSIsInNldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiY3JlYXRlRWxlbWVudE5TIiwiZ2V0QXR0cnMiLCJhdHRycyIsImF0dHJpYnV0ZXMiLCJuYW1lIiwib3V0IiwibmFtZXNwYWNlVVJJIiwidGV4dENvbnRlbnQiLCJvIiwidG9Mb3dlckNhc2UiLCJpc0Zpbml0ZSIsInNsaWNlIiwiZm9ybWF0IiwidG9rZW5SZWdleCIsIm9iak5vdGF0aW9uUmVnZXgiLCJyZXBsYWNlciIsImFsbCIsIm9iaiIsInJlcGxhY2UiLCJxdW90ZSIsInF1b3RlZE5hbWUiLCJpc0Z1bmMiLCJzdHIiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwicmVwdXNoIiwiYXJyYXkiLCJpdGVtIiwicHVzaCIsInNwbGljZSIsImNhY2hlciIsImYiLCJzY29wZSIsInBvc3Rwcm9jZXNzb3IiLCJuZXdmIiwiYXJnIiwiYXJndW1lbnRzIiwiYXJncyIsImpvaW4iLCJjYWNoZSIsImNvdW50Iiwic2hpZnQiLCJhbmdsZSIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsImF0YW4yIiwicmFkIiwiZGVnIiwieF95IiwieF95X3dfaCIsIndpZHRoIiwiaGVpZ2h0IiwidGFuIiwiY29zIiwiYXNpbiIsIm51bSIsImFjb3MiLCJhdGFuIiwibGVuMiIsImNsb3Nlc3RQb2ludCIsInBhdGgiLCJkaXN0YW5jZTIiLCJkeCIsImR5IiwicGF0aE5vZGUiLCJub2RlIiwicGF0aExlbmd0aCIsImdldFRvdGFsTGVuZ3RoIiwicHJlY2lzaW9uIiwicGF0aFNlZ0xpc3QiLCJudW1iZXJPZkl0ZW1zIiwiYmVzdCIsImJlc3RMZW5ndGgiLCJiZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInNjYW4iLCJzY2FuTGVuZ3RoIiwic2NhbkRpc3RhbmNlIiwiZ2V0UG9pbnRBdExlbmd0aCIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlTGVuZ3RoIiwiYWZ0ZXJMZW5ndGgiLCJiZWZvcmVEaXN0YW5jZSIsImFmdGVyRGlzdGFuY2UiLCJkaXN0YW5jZSIsInNuYXBUbyIsInZhbHVlcyIsInZhbHVlIiwidG9sZXJhbmNlIiwicmVtIiwiZ2V0UkdCIiwiY29sb3VyIiwiaW5kZXhPZiIsInIiLCJnIiwiaGV4IiwiZXJyb3IiLCJyZ2J0b1N0cmluZyIsImNoYXJBdCIsInRvSGV4IiwicmVkIiwiZ3JlZW4iLCJibHVlIiwib3BhY2l0eSIsInJnYiIsIm1hdGNoIiwic3BsaXQiLCJoc2IycmdiIiwiaHNsMnJnYiIsImhzYiIsImhzbCIsInRvRml4ZWQiLCJjb2xvciIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic3R5bGUiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaHNidG9TdHJpbmciLCJoc2x0b1N0cmluZyIsInByZXBhcmVSR0IiLCJzdHJpbmciLCJjbHIiLCJwYWNrYWdlUkdCIiwicmdiMmhzbCIsInJnYjJoc2IiLCJ2IiwiUiIsIkciLCJDIiwiSCIsIlYiLCJMIiwiTSIsIm0iLCJwYXJzZVBhdGhTdHJpbmciLCJwYXRoU3RyaW5nIiwicHRoIiwiYXJyIiwicGFyYW1Db3VudHMiLCJjIiwidSIsInoiLCJkYXRhIiwicGFyYW1zIiwiY29uY2F0IiwicGFyc2VUcmFuc2Zvcm1TdHJpbmciLCJUU3RyaW5nIiwic3ZnVHJhbnNmb3JtMnN0cmluZyIsInRzdHIiLCJyZ1RyYW5zZm9ybSIsInRyYW5zZm9ybTJtYXRyaXgiLCJiYm94IiwidGRhdGEiLCJNYXRyaXgiLCJ0bGVuIiwiY29tbWFuZCIsImFic29sdXRlIiwiaW52ZXIiLCJpbnZlcnQiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJzY2FsZSIsImFkZCIsIl91bml0MnB4IiwidW5pdDJweCIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJhZG93biIsImRvY3VtZW50RWxlbWVudCIsImJ1cCIsInBhcmVudE5vZGUiLCJnZXRTb21lRGVmcyIsIm93bmVyU1ZHRWxlbWVudCIsInNlbGVjdCIsInBkZWZzIiwiZGVmcyIsIm1ha2UiLCJnZXRTb21lU1ZHIiwic3ZnIiwibWdyIiwiZmlsbCIsImFwcGVuZENoaWxkIiwiZ2V0VyIsImdldEJCb3giLCJnZXRIIiwibmFtIiwicmVtb3ZlQ2hpbGQiLCJxdWVyeSIsInNlbGVjdEFsbCIsIm5vZGVsaXN0IiwicXVlcnlTZWxlY3RvckFsbCIsImFkZDJncm91cCIsImxpc3QiLCJmb3JFYWNoIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwic2V0SW50ZXJ2YWwiLCJzbmFwIiwicGFwZXIiLCJ0YWdOYW1lIiwibm9kZU5hbWUiLCJhbmltcyIsInRyYW5zZm9ybSIsIm1hc2siLCJwYXR0ZXJuIiwic3ltYm9sIiwibWV0aG9kIiwianNvbiIsImZpcnN0RGVmaW5lZCIsImF0dCIsInBhcnNlIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImZ1bGwiLCJkaXYiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsIkZyYWdtZW50IiwiZnJhZyIsImZyYWdtZW50IiwicGFyZW50IiwiZGVzYyIsInByb3RvIiwib3duZXJEb2N1bWVudCIsImJvZHkiLCJkb20iLCJjb250ZW50RG9jdW1lbnQiLCJjaCIsImpzb25GaWxsZXIiLCJ0b0pTT04iLCJvbiIsIm50IiwibGFzdEluZGV4T2YiLCJjc3MiLCJsZXR0ZXIiLCJjc3NBdHRyIiwidG9VcHBlckNhc2UiLCJhamF4IiwicG9zdERhdGEiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsInBkIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbmNlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInNlbmQiLCJsb2FkIiwicmVzcG9uc2VUZXh0IiwiZ2V0T2Zmc2V0IiwiZWxlbSIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRvY0VsZW0iLCJjbGllbnRUb3AiLCJjbGllbnRMZWZ0IiwidG9wIiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJsZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwiZ2V0RWxlbWVudEJ5UG9pbnQiLCJjYW52YXMiLCJ0YXJnZXQiLCJlbGVtZW50RnJvbVBvaW50Iiwib3BlcmEiLCJzbyIsInNyIiwiY3JlYXRlU1ZHUmVjdCIsImhpdHMiLCJnZXRJbnRlcnNlY3Rpb25MaXN0IiwicGx1Z2luIiwiZWxwcm90byIsImlzV2l0aG91dFRyYW5zZm9ybSIsImdldENsaWVudFJlY3RzIiwicmVtb3ZlZCIsImxvY2FsTWF0cml4Iiwib3JpZ2luYWwiLCJocmVmIiwiZ2V0RWxlbWVudEJ5SWQiLCJwYXRoZmluZGVyIiwiZGVmbHQiLCJiYm94d3QiLCJyZWFsUGF0aCIsIm1hdHJpeCIsIm1hcCIsInByb3BTdHJpbmciLCJleHRyYWN0VHJhbnNmb3JtIiwiZG9SZXR1cm4iLCJ0ZXN0IiwicGFwYSIsImdsb2JhbCIsImdldENUTSIsImxvY2FsIiwibXMiLCJsb2NhbFN0cmluZyIsInRvVHJhbnNmb3JtU3RyaW5nIiwiZ2xvYmFsTWF0cml4IiwidG90YWxNYXRyaXgiLCJkaWZmTWF0cml4IiwidG90YWwiLCJncmFkaWVudFRyYW5zZm9ybSIsInBhdHRlcm5UcmFuc2Zvcm0iLCJhcHBlbmQiLCJpdCIsImFwcGVuZFRvIiwicHJlcGVuZCIsImZpcnN0IiwiaW5zZXJ0QmVmb3JlIiwicHJlcGVuZFRvIiwibmV4dFNpYmxpbmciLCJpbnNlcnRBZnRlciIsInJlbW92ZSIsImFzUFgiLCJ1c2UiLCJmaXhpZHMiLCJlbHMiLCJpZHMiLCJ1c2VzIiwidXJsdGVzdCIsImxpbmt0ZXN0Iiwib2xkaWQiLCJvbGQiLCJmcyIsImNsb25lTm9kZSIsInRvRGVmcyIsInRvUGF0dGVybiIsInBhdHRlcm5Vbml0cyIsInZpZXdCb3giLCJtYXJrZXIiLCJyZWZYIiwicmVmWSIsImN4IiwiY3kiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsIm9yaWVudCIsImVsZGF0YSIsInJlbW92ZURhdGEiLCJvdXRlclNWRyIsImlubmVyU1ZHIiwiY2hsZCIsInRvRGF0YVVSTCIsImJ0b2EiLCJjb250ZW50cyIsInVuZXNjYXBlIiwiZCIsIm1hdHJpeHByb3RvIiwiYU5ldyIsImJOZXciLCJtdWx0TGVmdCIsImNOZXciLCJlTmV3IiwibWUiLCJza2V3WCIsInNrZXciLCJza2V3WSIsImZyb21DaGFyQ29kZSIsIm9mZnNldCIsIm5vcm0iLCJub3JtYWxpemUiLCJtYWciLCJkZXRlcm1pbmFudCIsInJvdyIsInNjYWxleCIsInNoZWFyIiwic2NhbGV5IiwiaXNTaW1wbGUiLCJpc1N1cGVyU2ltcGxlIiwibm9Sb3RhdGlvbiIsInNob3J0ZXIiLCJyZVVSTFZhbHVlIiwiZGV1cmwiLCJjbGlwSXQiLCJjbGlwIiwidW5kZWZpbmVkIiwiZmlsbFN0cm9rZSIsImdyYWQiLCJncmFkaWVudCIsImdyYWRyZyIsInBhcnNlR3JhZCIsInRva2VucyIsInN0b3BzIiwic2VlZCIsInN0ZXAiLCJrIiwidG9BYnNvbHV0ZSIsInR4dCIsImNsYXNzTmFtZSIsImJhc2VWYWwiLCJ2YiIsInJ4IiwicnkiLCJ0cCIsInRleHRQYXRoIiwidHVuZXIiLCJjaHVuayIsInR1bmVkIiwic2V0Rm9udFNpemUiLCJmb250U2l6ZSIsImdldHRlciIsInNldHRlciIsInRleHRFeHRyYWN0IiwiY2hpIiwiaW50ZXJuYWwiLCJnZXRGb250U2l6ZSIsInJnTm90U3BhY2UiLCJyZ0JhZFNwYWNlIiwicmdUcmltIiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwiY3VyQ2xhc3NlcyIsInBvcyIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwiaGFzQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsImZsYWciLCJvcGVyYXRvcnMiLCJyZVVuaXQiLCJyZUFkZG9uIiwiZ2V0TnVtYmVyIiwiZ2V0VW5pdCIsInVuaXQiLCJwbHVzIiwiZXZudCIsImF0ciIsImFVbml0Iiwib3AiLCJpc05hTiIsImJwbHVzIiwiZnJvbSIsInRvIiwicmVjdCIsImNpcmNsZSIsInByZWxvYWQiLCJvbmVycm9yIiwic3JjIiwiaW1nIiwiY3NzVGV4dCIsIm9ubG9hZCIsImltYWdlIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZWxsaXBzZSIsImdyb3VwIiwidmJ4IiwidmJ5IiwidmJ3IiwidmJoIiwicHRybiIsInZ4IiwidnkiLCJ2dyIsInZoIiwibGluZSIsInBvbHlsaW5lIiwicG9pbnRzIiwicG9seWdvbiIsIkdzdG9wcyIsIkdhZGRTdG9wIiwiaW5zZXJ0ZWQiLCJzdG9wT2Zmc2V0IiwiR2dldEJCb3giLCJHc2V0U3RvcHMiLCJhZGRTdG9wIiwidW5zaGlmdCIsImdyYWRpZW50TGluZWFyIiwiZ3JhZGllbnRSYWRpYWwiLCJncmFkaWVudFVuaXRzIiwic2V0U3RvcHMiLCJmeCIsImZ5IiwiY2xlYXIiLCJuZXh0IiwicDJzIiwicGF0aHMiLCJwcyIsInNsZWVwIiwicjEiLCJyMiIsInIwIiwicmVjdFBhdGgiLCJwYXRoQ2xvbmUiLCJwYXRoQXJyYXkiLCJnZXRQb2ludEF0U2VnbWVudExlbmd0aCIsInAxeCIsInAxeSIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsInAyeCIsInAyeSIsImJlemxlbiIsImZpbmREb3RzQXRTZWdtZW50IiwiZ2V0VG90TGVuIiwiZ2V0TGVuZ3RoRmFjdG9yeSIsImlzdG90YWwiLCJzdWJwYXRoIiwiTyIsIm9ubHlzdGFydCIsInBhdGgyY3VydmUiLCJzcCIsInN1YnBhdGhzIiwicG9pbnQiLCJnZXRTdWJwYXRoc0F0TGVuZ3RoIiwidDEiLCJ0MTMiLCJ0MTIiLCJ0MiIsInQzIiwibXgiLCJteSIsIm54IiwibnkiLCJheCIsImF5IiwiYWxwaGEiLCJiZXppZXJCQm94IiwiY3VydmVEaW0iLCJpc1BvaW50SW5zaWRlQkJveCIsImlzQkJveEludGVyc2VjdCIsImJib3gxIiwiYmJveDIiLCJiYXNlMyIsInAxIiwicDIiLCJwMyIsInA0IiwieDQiLCJ5NCIsInoyIiwiVHZhbHVlcyIsIkN2YWx1ZXMiLCJzdW0iLCJjdCIsInhiYXNlIiwieWJhc2UiLCJjb21iIiwibGwiLCJpbnRlcnNlY3QiLCJkZW5vbWluYXRvciIsInB4IiwicHkiLCJweDIiLCJweTIiLCJpbnRlciIsImJlejEiLCJiZXoyIiwiaW50ZXJIZWxwZXIiLCJpbnRlckNvdW50IiwianVzdENvdW50IiwibDEiLCJsMiIsIm4xIiwibjIiLCJkb3RzMSIsImRvdHMyIiwieHkiLCJkaSIsImRpMSIsImRqIiwiZGoxIiwiY2kiLCJjaiIsInBhdGhJbnRlcnNlY3Rpb24iLCJwYXRoMSIsInBhdGgyIiwiaW50ZXJQYXRoSGVscGVyIiwicGF0aEludGVyc2VjdGlvbk51bWJlciIsIngxbSIsInkxbSIsIngybSIsInkybSIsInBpIiwicGoiLCJpbnRyIiwia2siLCJzZWdtZW50MSIsInNlZ21lbnQyIiwiaXNQb2ludEluc2lkZVBhdGgiLCJwYXRoQkJveCIsImRpbSIsInhtaW4iLCJ5bWluIiwieG1heCIsInltYXgiLCJlbGxpcHNlUGF0aCIsImdldFBhdGgiLCJwYXRoVG9SZWxhdGl2ZSIsImxvd2VyQ2FzZSIsInJlbCIsInBhIiwicGF0aFRvQWJzb2x1dGUiLCJwYTAiLCJjcnoiLCJkb3RzIiwicG9wIiwiY2F0bXVsbFJvbTJiZXppZXIiLCJsMmMiLCJxMmMiLCJfMTMiLCJfMjMiLCJhMmMiLCJsYXJnZV9hcmNfZmxhZyIsInN3ZWVwX2ZsYWciLCJyZWN1cnNpdmUiLCJfMTIwIiwicngyIiwicnkyIiwiZjEiLCJmMiIsImRmIiwiZjJvbGQiLCJ4Mm9sZCIsInkyb2xkIiwiYzEiLCJzMSIsImMyIiwiczIiLCJoeCIsImh5IiwibTEiLCJtMiIsIm0zIiwibTQiLCJuZXdyZXMiLCJmaW5kRG90QXRTZWdtZW50IiwieDAiLCJ5MCIsInR2YWx1ZXMiLCJib3VuZHMiLCJiMmFjIiwic3FydGIyYWMiLCJqbGVuIiwibXQiLCJjdXJ2ZSIsImJ4IiwiYnkiLCJxeCIsInF5IiwiYXR0cnMyIiwicHJvY2Vzc1BhdGgiLCJwY29tIiwiVCIsImZpeEFyYyIsInBwIiwicGNvbXMxIiwicGNvbXMyIiwiZml4TSIsImExIiwiYTIiLCJwZmlyc3QiLCJzZWciLCJzZWcyIiwic2VnbGVuIiwic2VnMmxlbiIsIm1hcFBhdGgiLCJwYXRoaSIsImNycCIsImlMZW4iLCJnZXRTdWJwYXRoIiwiY2xvc2VzdCIsImluc2lkZSIsImZvdW5kIiwiaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0aW9uTnVtYmVyIiwiaXNQb2ludEluc2lkZSIsInRvUmVsYXRpdmUiLCJ0b0N1YmljIiwiU2V0IiwiaXRlbXMiLCJiaW5kaW5ncyIsInNldHByb3RvIiwidGhpc0FyZyIsImFuaW1hdGUiLCJBbmltYXRpb24iLCJlYWNoIiwiYmVnaW4iLCJoYW5kbGVyIiwiY2IiLCJjYWxsYmFja2VyIiwiYmluZCIsImFuYW1lIiwidW5ib3VuZCIsImluZGV4IiwiaW5zZXJ0aW9uIiwidGFpbCIsInRvZGVsIiwiYXJnbGVuIiwiZXhjbHVkZSIsIm5hbWVzIiwic3Ryb2tlIiwiZ2V0RW1wdHkiLCJlcXVhbGlzZVRyYW5zZm9ybSIsIm1heGxlbmd0aCIsInR0MSIsInR0MiIsInBhdGgyYXJyYXkiLCJnZXRWaWV3Qm94IiwiZ2V0Q29sb3VyIiwiRnVuY3Rpb24iLCJpc051bWVyaWMiLCJhcnJheUVxdWFsIiwiYXJyMSIsImFycjIiLCJlcXVhbCIsIk51bWJlciIsImJVbml0Iiwic3VwcG9ydHNUb3VjaCIsImV2ZW50cyIsInRvdWNoTWFwIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsImdldFNjcm9sbCIsInByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJwcmV2ZW50VG91Y2giLCJvcmlnaW5hbEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwic3RvcFRvdWNoIiwiYWRkRXZlbnQiLCJmbiIsImVsZW1lbnQiLCJyZWFsTmFtZSIsInNjcm9sbFkiLCJzY3JvbGxYIiwidGFyZ2V0VG91Y2hlcyIsIm9sZGUiLCJjbGllbnRYIiwiY2xpZW50WSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZHJhZyIsImRyYWdNb3ZlIiwiZHJhZ2kiLCJ0b3VjaGVzIiwidG91Y2giLCJpZGVudGlmaWVyIiwiX2RyYWciLCJkaXNwbGF5IiwibW92ZV9zY29wZSIsImRyYWdVcCIsInVubW91c2Vtb3ZlIiwidW5tb3VzZXVwIiwiZW5kX3Njb3BlIiwic3RhcnRfc2NvcGUiLCJvZmYiLCJldmVudE5hbWUiLCJ1bmJpbmQiLCJob3ZlciIsImZfaW4iLCJmX291dCIsInNjb3BlX2luIiwic2NvcGVfb3V0IiwibW91c2VvdmVyIiwibW91c2VvdXQiLCJ1bmhvdmVyIiwidW5tb3VzZW92ZXIiLCJ1bm1vdXNlb3V0IiwiZHJhZ2dhYmxlIiwib25tb3ZlIiwib25zdGFydCIsIm9uZW5kIiwib3JpZ1RyYW5zZm9ybSIsImluaXQiLCJ1bmRyYWciLCJ1bm1vdXNlZG93biIsInBwcm90byIsInJndXJsIiwiZmlsdGVyIiwiZmlsc3RyIiwiZmlsdGVyVW5pdHMiLCJibHVyIiwiZGVmIiwic2hhZG93IiwiZ3JheXNjYWxlIiwiYW1vdW50Iiwic2VwaWEiLCJzYXR1cmF0ZSIsImh1ZVJvdGF0ZSIsImFtb3VudDIiLCJicmlnaHRuZXNzIiwiY29udHJhc3QiLCJmaXJzdExldHRlciIsImdldEFsaWduIiwid2F5IiwiYWxpZ24iLCJhbmltYXRpb24iLCJpbkFuaW0iLCJfYXR0cnMiLCJfY2FsbGJhY2siLCJjdXJTdGF0dXMiLCJma2V5cyIsInRrZXlzIiwia2V5cyIsImVxIiwicGluayIsInB1cnBsZSIsImRlZXBwdXJwbGUiLCJpbmRpZ28iLCJsaWdodGJsdWUiLCJjeWFuIiwidGVhbCIsImxpZ2h0Z3JlZW4iLCJsaW1lIiwieWVsbG93IiwiYW1iZXIiLCJvcmFuZ2UiLCJkZWVwb3JhbmdlIiwiYnJvd24iLCJncmV5IiwiYmx1ZWdyZXkiLCJtdWkiLCJmbGF0Iiwic2F2ZUNvbG9yIiwiY29sb3JzIiwiQTEwMCIsIkEyMDAiLCJBNDAwIiwiQTcwMCIsInR1cnF1b2lzZSIsImdyZWVuc2VhIiwic3VuZmxvd2VyIiwiZW1lcmxhbmQiLCJuZXBocml0aXMiLCJjYXJyb3QiLCJwdW1wa2luIiwicGV0ZXJyaXZlciIsImJlbGl6ZWhvbGUiLCJhbGl6YXJpbiIsInBvbWVncmFuYXRlIiwiYW1ldGh5c3QiLCJ3aXN0ZXJpYSIsImNsb3VkcyIsInNpbHZlciIsIndldGFzcGhhbHQiLCJtaWRuaWdodGJsdWUiLCJjb25jcmV0ZSIsImFzYmVzdG9zIiwiaW1wb3J0TVVJQ29sb3JzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/snapsvg-cjs/dist/snap.svg-cjs.js\n");

/***/ })

};
;